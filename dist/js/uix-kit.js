/*!
 * 
 * DO NOT OVERRIDE THIS FILE.
 * Generated with "npm run build"
 *
 * ## Project Name        :  Uix Kit 中文
 * ## Project Description :  一个快速网页设计和开发的偏视觉交互的免费开发工具包，与 Bootstrap v5 兼容。
 * ## Project URL         :  https://uix-kit.13aq.com/
 * ## Version             :  4.7.0
 * ## Based on            :  Uix Kit (https://github.com/huikeyun/uix-kit)
 * ## Last Update         :  November 3, 2022
 * ## Created by          :  UIUX Lab (https://uiux.cc) (uiuxlab@gmail.com)
 * ## Released under the MIT license.
 *
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 696:
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ML": () => (/* binding */ _gsScope)
/* harmony export */ });
/* unused harmony exports TweenLite, globals, default, SimpleTimeline, Animation, Ease, Linear, Power0, Power1, Power2, Power3, Power4, TweenPlugin, EventDispatcher */
/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* module decorator */ module = __webpack_require__.hmd(module);

/*!
 * VERSION: 2.1.3
 * DATE: 2019-05-17
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
/* eslint-disable */

/* ES6 changes:
	- declare and export _gsScope at top.
	- set var TweenLite = the result of the main function
	- export default TweenLite at the bottom
	- return TweenLite at the bottom of the main function
	- pass in _gsScope as the first parameter of the main function (which is actually at the bottom)
	- remove the "export to multiple environments" in Definition().
 */
var _gsScope = typeof window !== "undefined" ? window :  true && module.exports && typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : undefined || {};
var TweenLite = function (window) {
  "use strict";

  var _exports = {},
    _doc = window.document,
    _globals = window.GreenSockGlobals = window.GreenSockGlobals || window;
  if (_globals.TweenLite) {
    return _globals.TweenLite; //in case the core set of classes is already loaded, don't instantiate twice.
  }

  var _namespace = function _namespace(ns) {
      var a = ns.split("."),
        p = _globals,
        i;
      for (i = 0; i < a.length; i++) {
        p[a[i]] = p = p[a[i]] || {};
      }
      return p;
    },
    gs = _namespace("com.greensock"),
    _tinyNum = 0.00000001,
    _slice = function _slice(a) {
      //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
      var b = [],
        l = a.length,
        i;
      for (i = 0; i !== l; b.push(a[i++])) {}
      return b;
    },
    _emptyFunc = function _emptyFunc() {},
    _isArray = function () {
      //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
      var toString = Object.prototype.toString,
        array = toString.call([]);
      return function (obj) {
        return obj != null && (obj instanceof Array || (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(obj) === "object" && !!obj.push && toString.call(obj) === array);
      };
    }(),
    a,
    i,
    p,
    _ticker,
    _tickerActive,
    _defLookup = {},
    /**
     * @constructor
     * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
     * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
     * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
     * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
     *
     * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
     * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
     * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
     * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
     * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
     * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
     * sandbox the banner one like:
     *
     * <script>
     *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
     * </script>
     * <script src="js/greensock/v1.7/TweenMax.js"></script>
     * <script>
     *     window.GreenSockGlobals = window._gsQueue = window._gsDefine = null; //reset it back to null (along with the special _gsQueue variable) so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
     * </script>
     * <script src="js/greensock/v1.6/TweenMax.js"></script>
     * <script>
     *     gs.TweenLite.to(...); //would use v1.7
     *     TweenLite.to(...); //would use v1.6
     * </script>
     *
     * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
     * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
     * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
     * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
     */
    Definition = function Definition(ns, dependencies, func, global) {
      this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
      _defLookup[ns] = this;
      this.gsClass = null;
      this.func = func;
      var _classes = [];
      this.check = function (init) {
        var i = dependencies.length,
          missing = i,
          cur,
          a,
          n,
          cl;
        while (--i > -1) {
          if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
            _classes[i] = cur.gsClass;
            missing--;
          } else if (init) {
            cur.sc.push(this);
          }
        }
        if (missing === 0 && func) {
          a = ("com.greensock." + ns).split(".");
          n = a.pop();
          cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

          //exports to multiple environments
          if (global) {
            _globals[n] = _exports[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
            /*
            if (typeof(module) !== "undefined" && module.exports) { //node
            	if (ns === moduleName) {
            		module.exports = _exports[moduleName] = cl;
            		for (i in _exports) {
            			cl[i] = _exports[i];
            		}
            	} else if (_exports[moduleName]) {
            		_exports[moduleName][n] = cl;
            	}
            } else if (typeof(define) === "function" && define.amd){ //AMD
            	define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").pop(), [], function() { return cl; });
            }
            */
          }

          for (i = 0; i < this.sc.length; i++) {
            this.sc[i].check();
          }
        }
      };
      this.check(true);
    },
    //used to create Definition instances (which basically registers a class that has dependencies).
    _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
      return new Definition(ns, dependencies, func, global);
    },
    //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
    _class = gs._class = function (ns, func, global) {
      func = func || function () {};
      _gsDefine(ns, [], function () {
        return func;
      }, global);
      return func;
    };
  _gsDefine.globals = _globals;

  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */
  var _baseParams = [0, 0, 1, 1],
    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
      this._func = func;
      this._type = type || 0;
      this._power = power || 0;
      this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
    }, true),
    _easeMap = Ease.map = {},
    _easeReg = Ease.register = function (ease, names, types, create) {
      var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e,
        name,
        j,
        type;
      while (--i > -1) {
        name = na[i];
        e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
        j = ta.length;
        while (--j > -1) {
          type = ta[j];
          _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
        }
      }
    };
  p = Ease.prototype;
  p._calcEnd = false;
  p.getRatio = function (p) {
    if (this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }
    var t = this._type,
      pw = this._power,
      r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
    if (pw === 1) {
      r *= r;
    } else if (pw === 2) {
      r *= r * r;
    } else if (pw === 3) {
      r *= r * r * r;
    } else if (pw === 4) {
      r *= r * r * r * r;
    }
    return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
  };

  //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;
  while (--i > -1) {
    p = a[i] + ",Power" + i;
    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }
  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */
  var EventDispatcher = _class("events.EventDispatcher", function (target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });
  p = EventDispatcher.prototype;
  p.addEventListener = function (type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
      index = 0,
      listener,
      i;
    if (this === _ticker && !_tickerActive) {
      _ticker.wake();
    }
    if (list == null) {
      this._listeners[type] = list = [];
    }
    i = list.length;
    while (--i > -1) {
      listener = list[i];
      if (listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }
    list.splice(index, 0, {
      c: callback,
      s: scope,
      up: useParam,
      pr: priority
    });
  };
  p.removeEventListener = function (type, callback) {
    var list = this._listeners[type],
      i;
    if (list) {
      i = list.length;
      while (--i > -1) {
        if (list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };
  p.dispatchEvent = function (type) {
    var list = this._listeners[type],
      i,
      t,
      listener;
    if (list) {
      i = list.length;
      if (i > 1) {
        list = list.slice(0); //in case addEventListener() is called from within a listener/callback (otherwise the index could change, resulting in a skip)
      }

      t = this._eventTarget;
      while (--i > -1) {
        listener = list[i];
        if (listener) {
          if (listener.up) {
            listener.c.call(listener.s || t, {
              type: type,
              target: t
            });
          } else {
            listener.c.call(listener.s || t);
          }
        }
      }
    }
  };

  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */
  var _reqAnimFrame = window.requestAnimationFrame,
    _cancelAnimFrame = window.cancelAnimationFrame,
    _getTime = Date.now || function () {
      return new Date().getTime();
    },
    _lastUpdate = _getTime();

  //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
  a = ["ms", "moz", "webkit", "o"];
  i = a.length;
  while (--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }
  _class("Ticker", function (fps, useRAF) {
    var _self = this,
      _startTime = _getTime(),
      _useRAF = useRAF !== false && _reqAnimFrame ? "auto" : false,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _tickWord = "tick",
      //helps reduce gc burden
      _fps,
      _req,
      _id,
      _gap,
      _nextTime,
      _tick = function _tick(manual) {
        var elapsed = _getTime() - _lastUpdate,
          overlap,
          dispatch;
        if (elapsed > _lagThreshold) {
          _startTime += elapsed - _adjustedLag;
        }
        _lastUpdate += elapsed;
        _self.time = (_lastUpdate - _startTime) / 1000;
        overlap = _self.time - _nextTime;
        if (!_fps || overlap > 0 || manual === true) {
          _self.frame++;
          _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
          dispatch = true;
        }
        if (manual !== true) {
          //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
          _id = _req(_tick);
        }
        if (dispatch) {
          _self.dispatchEvent(_tickWord);
        }
      };
    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;
    _self.tick = function () {
      _tick(true);
    };
    _self.lagSmoothing = function (threshold, adjustedLag) {
      if (!arguments.length) {
        //if lagSmoothing() is called with no arguments, treat it like a getter that returns a boolean indicating if it's enabled or not. This is purposely undocumented and is for internal use.
        return _lagThreshold < 1 / _tinyNum;
      }
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited
      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    };
    _self.sleep = function () {
      if (_id == null) {
        return;
      }
      if (!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }
      _req = _emptyFunc;
      _id = null;
      if (_self === _ticker) {
        _tickerActive = false;
      }
    };
    _self.wake = function (seamless) {
      if (_id !== null) {
        _self.sleep();
      } else if (seamless) {
        _startTime += -_lastUpdate + (_lastUpdate = _getTime());
      } else if (_self.frame > 10) {
        //don't trigger lagSmoothing if we're just waking up, and make sure that at least 10 frames have elapsed because of the iOS bug that we work around below with the 1.5-second setTimout().
        _lastUpdate = _getTime() - _lagThreshold + 5;
      }
      _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
        return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
      } : _reqAnimFrame;
      if (_self === _ticker) {
        _tickerActive = true;
      }
      _tick(2);
    };
    _self.fps = function (value) {
      if (!arguments.length) {
        return _fps;
      }
      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;
      _self.wake();
    };
    _self.useRAF = function (value) {
      if (!arguments.length) {
        return _useRAF;
      }
      _self.sleep();
      _useRAF = value;
      _self.fps(_fps);
    };
    _self.fps(fps);

    //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
    setTimeout(function () {
      if (_useRAF === "auto" && _self.frame < 5 && (_doc || {}).visibilityState !== "hidden") {
        _self.useRAF(false);
      }
    }, 1500);
  });
  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;

  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */
  var Animation = _class("core.Animation", function (duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = !!vars.immediateRender;
    this.data = vars.data;
    this._reversed = !!vars.reversed;
    if (!_rootTimeline) {
      return;
    }
    if (!_tickerActive) {
      //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }
    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);
    if (this.vars.paused) {
      this.paused(true);
    }
  });
  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false;

  //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
  var _checkTimeout = function _checkTimeout() {
    if (_tickerActive && _getTime() - _lastUpdate > 2000 && ((_doc || {}).visibilityState !== "hidden" || !_ticker.lagSmoothing())) {
      //note: if the tab is hidden, we should still wake if lagSmoothing has been disabled.
      _ticker.wake();
    }
    var t = setTimeout(_checkTimeout, 2000);
    if (t.unref) {
      // allows a node process to exit even if the timeout’s callback hasn't been invoked. Without it, the node process could hang as this function is called every two seconds.
      t.unref();
    }
  };
  _checkTimeout();
  p.play = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }
    return this.reversed(false).paused(false);
  };
  p.pause = function (atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }
    return this.paused(true);
  };
  p.resume = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }
    return this.paused(false);
  };
  p.seek = function (time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };
  p.restart = function (includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
  };
  p.reverse = function (from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }
    return this.reversed(true).paused(false);
  };
  p.render = function (time, suppressEvents, force) {
    //stub - we override this method in subclasses.
  };
  p.invalidate = function () {
    this._time = this._totalTime = 0;
    this._initted = this._gc = false;
    this._rawPrevTime = -1;
    if (this._gc || !this.timeline) {
      this._enabled(true);
    }
    return this;
  };
  p.isActive = function () {
    var tl = this._timeline,
      //the 2 root timelines won't have a _timeline; they're always active.
      startTime = this._startTime,
      rawTime;
    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime(true)) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale - _tinyNum;
  };
  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    this._gc = !enabled;
    this._active = this.isActive();
    if (ignoreTimeline !== true) {
      if (enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if (!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }
    return false;
  };
  p._kill = function (vars, target) {
    return this._enabled(false, false);
  };
  p.kill = function (vars, target) {
    this._kill(vars, target);
    return this;
  };
  p._uncache = function (includeSelf) {
    var tween = includeSelf ? this : this.timeline;
    while (tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }
    return this;
  };
  p._swapSelfInParams = function (params) {
    var i = params.length,
      copy = params.concat();
    while (--i > -1) {
      if (params[i] === "{self}") {
        copy[i] = this;
      }
    }
    return copy;
  };
  p._callback = function (type) {
    var v = this.vars,
      callback = v[type],
      params = v[type + "Params"],
      scope = v[type + "Scope"] || v.callbackScope || this,
      l = params ? params.length : 0;
    switch (l) {
      //speed optimization; call() is faster than apply() so use it when there are only a few parameters (which is by far most common). Previously we simply did var v = this.vars; v[type].apply(v[type + "Scope"] || v.callbackScope || this, v[type + "Params"] || _blankArray);
      case 0:
        callback.call(scope);
        break;
      case 1:
        callback.call(scope, params[0]);
        break;
      case 2:
        callback.call(scope, params[0], params[1]);
        break;
      default:
        callback.apply(scope, params);
    }
  };

  //----Animation getters/setters --------------------------------------------------------

  p.eventCallback = function (type, callback, params, scope) {
    if ((type || "").substr(0, 2) === "on") {
      var v = this.vars;
      if (arguments.length === 1) {
        return v[type];
      }
      if (callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }
      if (type === "onUpdate") {
        this._onUpdate = callback;
      }
    }
    return this;
  };
  p.delay = function (value) {
    if (!arguments.length) {
      return this._delay;
    }
    if (this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }
    this._delay = value;
    return this;
  };
  p.duration = function (value) {
    if (!arguments.length) {
      this._dirty = false;
      return this._duration;
    }
    this._duration = this._totalDuration = value;
    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
    if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
      this.totalTime(this._totalTime * (value / this._duration), true);
    }
    return this;
  };
  p.totalDuration = function (value) {
    this._dirty = false;
    return !arguments.length ? this._totalDuration : this.duration(value);
  };
  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }
    if (this._dirty) {
      this.totalDuration();
    }
    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
  };
  p.totalTime = function (time, suppressEvents, uncapped) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    if (!arguments.length) {
      return this._totalTime;
    }
    if (this._timeline) {
      if (time < 0 && !uncapped) {
        time += this.totalDuration();
      }
      if (this._timeline.smoothChildTiming) {
        if (this._dirty) {
          this.totalDuration();
        }
        var totalDuration = this._totalDuration,
          tl = this._timeline;
        if (time > totalDuration && !uncapped) {
          time = totalDuration;
        }
        this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
        if (!tl._dirty) {
          //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        }
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
        if (tl._timeline) {
          while (tl._timeline) {
            if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }
            tl = tl._timeline;
          }
        }
      }
      if (this._gc) {
        this._enabled(true, false);
      }
      if (this._totalTime !== time || this._duration === 0) {
        if (_lazyTweens.length) {
          _lazyRender();
        }
        this.render(time, suppressEvents, false);
        if (_lazyTweens.length) {
          //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
          _lazyRender();
        }
      }
    }
    return this;
  };
  p.progress = p.totalProgress = function (value, suppressEvents) {
    var duration = this.duration();
    return !arguments.length ? duration ? this._time / duration : this.ratio : this.totalTime(duration * value, suppressEvents);
  };
  p.startTime = function (value) {
    if (!arguments.length) {
      return this._startTime;
    }
    if (value !== this._startTime) {
      this._startTime = value;
      if (this.timeline) if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
      }
    }

    return this;
  };
  p.endTime = function (includeRepeats) {
    return this._startTime + (includeRepeats != false ? this.totalDuration() : this.duration()) / this._timeScale;
  };
  p.timeScale = function (value) {
    if (!arguments.length) {
      return this._timeScale;
    }
    var pauseTime, t;
    value = value || _tinyNum; //can't allow zero because it'll throw the math off
    if (this._timeline && this._timeline.smoothChildTiming) {
      pauseTime = this._pauseTime;
      t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
      this._startTime = t - (t - this._startTime) * this._timeScale / value;
    }
    this._timeScale = value;
    t = this.timeline;
    while (t && t.timeline) {
      //must update the duration/totalDuration of all ancestor timelines immediately in case in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
      t._dirty = true;
      t.totalDuration();
      t = t.timeline;
    }
    return this;
  };
  p.reversed = function (value) {
    if (!arguments.length) {
      return this._reversed;
    }
    if (value != this._reversed) {
      this._reversed = value;
      this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, true);
    }
    return this;
  };
  p.paused = function (value) {
    if (!arguments.length) {
      return this._paused;
    }
    var tl = this._timeline,
      raw,
      elapsed;
    if (value != this._paused) if (tl) {
      if (!_tickerActive && !value) {
        _ticker.wake();
      }
      raw = tl.rawTime();
      elapsed = raw - this._pauseTime;
      if (!value && tl.smoothChildTiming) {
        this._startTime += elapsed;
        this._uncache(false);
      }
      this._pauseTime = value ? raw : null;
      this._paused = value;
      this._active = this.isActive();
      if (!value && elapsed !== 0 && this._initted && this.duration()) {
        raw = tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale;
        this.render(raw, raw === this._totalTime, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
      }
    }

    if (this._gc && !value) {
      this._enabled(true, false);
    }
    return this;
  };

  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */
  var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });
  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = p._recent = null;
  p._sortChildren = false;
  p.add = p.insert = function (child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if (child._paused) if (this !== child._timeline) {
      //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
      child._pauseTime = this.rawTime() - (child._timeline.rawTime() - child._pauseTime);
    }
    if (child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
    }

    child.timeline = child._timeline = this;
    if (child._gc) {
      child._enabled(true, true);
    }
    prevTween = this._last;
    if (this._sortChildren) {
      st = child._startTime;
      while (prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }
    if (prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }
    child._prev = prevTween;
    this._recent = child;
    if (this._timeline) {
      this._uncache(true);
    }
    return this;
  };
  p._remove = function (tween, skipDisable) {
    if (tween.timeline === this) {
      if (!skipDisable) {
        tween._enabled(false, true);
      }
      if (tween._prev) {
        tween._prev._next = tween._next;
      } else if (this._first === tween) {
        this._first = tween._next;
      }
      if (tween._next) {
        tween._next._prev = tween._prev;
      } else if (this._last === tween) {
        this._last = tween._prev;
      }
      tween._next = tween._prev = tween.timeline = null;
      if (tween === this._recent) {
        this._recent = this._last;
      }
      if (this._timeline) {
        this._uncache(true);
      }
    }
    return this;
  };
  p.render = function (time, suppressEvents, force) {
    var tween = this._first,
      next;
    this._totalTime = this._time = this._rawPrevTime = time;
    while (tween) {
      next = tween._next; //record it here because the value could change after rendering...
      if (tween._active || time >= tween._startTime && !tween._paused && !tween._gc) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
        }
      }
      tween = next;
    }
  };
  p.rawTime = function () {
    if (!_tickerActive) {
      _ticker.wake();
    }
    return this._totalTime;
  };

  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */
  var TweenLite = _class("TweenLite", function (target, duration, vars) {
      Animation.call(this, duration, vars);
      this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

      if (target == null) {
        throw "Cannot tween a null target.";
      }
      this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
      var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
        overwrite = this.vars.overwrite,
        i,
        targ,
        targets;
      this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];
      if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
        this._targets = targets = _slice(target); //don't use Array.prototype.slice.call(target, 0) because that doesn't work in IE8 with a NodeList that's returned by querySelectorAll()
        this._propLookup = [];
        this._siblings = [];
        for (i = 0; i < targets.length; i++) {
          targ = targets[i];
          if (!targ) {
            targets.splice(i--, 1);
            continue;
          } else if (typeof targ === "string") {
            targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
            if (typeof targ === "string") {
              targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
            }

            continue;
          } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
            //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
            targets.splice(i--, 1);
            this._targets = targets = targets.concat(_slice(targ));
            continue;
          }
          this._siblings[i] = _register(targ, this, false);
          if (overwrite === 1) if (this._siblings[i].length > 1) {
            _applyOverwrite(targ, this, null, 1, this._siblings[i]);
          }
        }
      } else {
        this._propLookup = {};
        this._siblings = _register(target, this, false);
        if (overwrite === 1) if (this._siblings.length > 1) {
          _applyOverwrite(target, this, null, 1, this._siblings);
        }
      }
      if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
        this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
        this.render(Math.min(0, -this._delay)); //in case delay is negative
      }
    }, true),
    _isSelector = function _isSelector(v) {
      return v && v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
    },
    _autoCSS = function _autoCSS(vars, target) {
      var css = {},
        p;
      for (p in vars) {
        if (!_reservedProps[p] && (!(p in target) || p === "transform" || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
          //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
          css[p] = vars[p];
          delete vars[p];
        }
      }
      vars.css = css;
    };
  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false;

  //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = p._lazy = false;
  TweenLite.version = "2.1.3";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = 120;
  TweenLite.lagSmoothing = function (threshold, adjustedLag) {
    _ticker.lagSmoothing(threshold, adjustedLag);
  };
  TweenLite.selector = window.$ || window.jQuery || function (e) {
    var selector = window.$ || window.jQuery;
    if (selector) {
      TweenLite.selector = selector;
      return selector(e);
    }
    if (!_doc) {
      //in some dev environments (like Angular 6), GSAP gets loaded before the document is defined! So re-query it here if/when necessary.
      _doc = window.document;
    }
    return !_doc ? e : _doc.querySelectorAll ? _doc.querySelectorAll(e) : _doc.getElementById(e.charAt(0) === "#" ? e.substr(1) : e);
  };
  var _lazyTweens = [],
    _lazyLookup = {},
    _numbersExp = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    _relExp = /[\+-]=-?[\.\d]/,
    //_nonNumbersExp = /(?:([\-+](?!(\d|=)))|[^\d\-+=e]|(e(?![\-+][\d])))+/ig,
    _setRatio = function _setRatio(v) {
      var pt = this._firstPT,
        min = 0.000001,
        val;
      while (pt) {
        val = !pt.blob ? pt.c * v + pt.s : v === 1 && this.end != null ? this.end : v ? this.join("") : this.start;
        if (pt.m) {
          val = pt.m.call(this._tween, val, this._target || pt.t, this._tween);
        } else if (val < min) if (val > -min && !pt.blob) {
          //prevents issues with converting very small numbers to strings in the browser
          val = 0;
        }
        if (!pt.f) {
          pt.t[pt.p] = val;
        } else if (pt.fp) {
          pt.t[pt.p](pt.fp, val);
        } else {
          pt.t[pt.p](val);
        }
        pt = pt._next;
      }
    },
    _blobRound = function _blobRound(v) {
      return (v * 1000 | 0) / 1000 + "";
    },
    //compares two strings (start/end), finds the numbers that are different and spits back an array representing the whole value but with the changing values isolated as elements. For example, "rgb(0,0,0)" and "rgb(100,50,0)" would become ["rgb(", 0, ",", 50, ",0)"]. Notice it merges the parts that are identical (performance optimization). The array also has a linked list of PropTweens attached starting with _firstPT that contain the tweening data (t, p, s, c, f, etc.). It also stores the starting value as a "start" property so that we can revert to it if/when necessary, like when a tween rewinds fully. If the quantity of numbers differs between the start and end, it will always prioritize the end value(s). The pt parameter is optional - it's for a PropTween that will be appended to the end of the linked list and is typically for actually setting the value after all of the elements have been updated (with array.join("")).
    _blobDif = function _blobDif(start, end, filter, pt) {
      var a = [],
        charIndex = 0,
        s = "",
        color = 0,
        startNums,
        endNums,
        num,
        i,
        l,
        nonNumbers,
        currentNum;
      a.start = start;
      a.end = end;
      start = a[0] = start + ""; //ensure values are strings
      end = a[1] = end + "";
      if (filter) {
        filter(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.
        start = a[0];
        end = a[1];
      }
      a.length = 0;
      startNums = start.match(_numbersExp) || [];
      endNums = end.match(_numbersExp) || [];
      if (pt) {
        pt._next = null;
        pt.blob = 1;
        a._firstPT = a._applyPT = pt; //apply last in the linked list (which means inserting it first)
      }

      l = endNums.length;
      for (i = 0; i < l; i++) {
        currentNum = endNums[i];
        nonNumbers = end.substr(charIndex, end.indexOf(currentNum, charIndex) - charIndex);
        s += nonNumbers || !i ? nonNumbers : ","; //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        charIndex += nonNumbers.length;
        if (color) {
          //sense rgba() values and round them.
          color = (color + 1) % 5;
        } else if (nonNumbers.substr(-5) === "rgba(") {
          color = 1;
        }
        if (currentNum === startNums[i] || startNums.length <= i) {
          s += currentNum;
        } else {
          if (s) {
            a.push(s);
            s = "";
          }
          num = parseFloat(startNums[i]);
          a.push(num);
          a._firstPT = {
            _next: a._firstPT,
            t: a,
            p: a.length - 1,
            s: num,
            c: (currentNum.charAt(1) === "=" ? parseInt(currentNum.charAt(0) + "1", 10) * parseFloat(currentNum.substr(2)) : parseFloat(currentNum) - num) || 0,
            f: 0,
            m: color && color < 4 ? Math.round : _blobRound
          }; //limiting to 3 decimal places and casting as a string can really help performance when array.join() is called!
          //note: we don't set _prev because we'll never need to remove individual PropTweens from this list.
        }

        charIndex += currentNum.length;
      }
      s += end.substr(charIndex);
      if (s) {
        a.push(s);
      }
      a.setRatio = _setRatio;
      if (_relExp.test(end)) {
        //if the end string contains relative values, delete it so that on the final render (in _setRatio()), we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
        a.end = null;
      }
      return a;
    },
    //note: "funcParam" is only necessary for function-based getters/setters that require an extra parameter like getAttribute("width") and setAttribute("width", value). In this example, funcParam would be "width". Used by AttrPlugin for example.
    _addPropTween = function _addPropTween(target, prop, start, end, overwriteProp, mod, funcParam, stringFilter, index) {
      if (typeof end === "function") {
        end = end(index || 0, target);
      }
      var type = (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(target[prop]),
        getterName = type !== "function" ? "" : prop.indexOf("set") || typeof target["get" + prop.substr(3)] !== "function" ? prop : "get" + prop.substr(3),
        s = start !== "get" ? start : !getterName ? target[prop] : funcParam ? target[getterName](funcParam) : target[getterName](),
        isRelative = typeof end === "string" && end.charAt(1) === "=",
        pt = {
          t: target,
          p: prop,
          s: s,
          f: type === "function",
          pg: 0,
          n: overwriteProp || prop,
          m: !mod ? 0 : typeof mod === "function" ? mod : Math.round,
          pr: 0,
          c: isRelative ? parseInt(end.charAt(0) + "1", 10) * parseFloat(end.substr(2)) : parseFloat(end) - s || 0
        },
        blob;
      if (typeof s !== "number" || typeof end !== "number" && !isRelative) {
        if (funcParam || isNaN(s) || !isRelative && isNaN(end) || typeof s === "boolean" || typeof end === "boolean") {
          //a blob (string that has multiple numbers in it)
          pt.fp = funcParam;
          blob = _blobDif(s, isRelative ? parseFloat(pt.s) + pt.c + (pt.s + "").replace(/[0-9\-\.]/g, "") : end, stringFilter || TweenLite.defaultStringFilter, pt);
          pt = {
            t: blob,
            p: "setRatio",
            s: 0,
            c: 1,
            f: 2,
            pg: 0,
            n: overwriteProp || prop,
            pr: 0,
            m: 0
          }; //"2" indicates it's a Blob property tween. Needed for RoundPropsPlugin for example.
        } else {
          pt.s = parseFloat(s);
          if (!isRelative) {
            pt.c = parseFloat(end) - pt.s || 0;
          }
        }
      }
      if (pt.c) {
        //only add it to the linked list if there's a change.
        if (pt._next = this._firstPT) {
          pt._next._prev = pt;
        }
        this._firstPT = pt;
        return pt;
      }
    },
    _internals = TweenLite._internals = {
      isArray: _isArray,
      isSelector: _isSelector,
      lazyTweens: _lazyTweens,
      blobDif: _blobDif
    },
    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
    _plugins = TweenLite._plugins = {},
    _tweenLookup = _internals.tweenLookup = {},
    _tweenLookupNum = 0,
    _reservedProps = _internals.reservedProps = {
      ease: 1,
      delay: 1,
      overwrite: 1,
      onComplete: 1,
      onCompleteParams: 1,
      onCompleteScope: 1,
      useFrames: 1,
      runBackwards: 1,
      startAt: 1,
      onUpdate: 1,
      onUpdateParams: 1,
      onUpdateScope: 1,
      onStart: 1,
      onStartParams: 1,
      onStartScope: 1,
      onReverseComplete: 1,
      onReverseCompleteParams: 1,
      onReverseCompleteScope: 1,
      onRepeat: 1,
      onRepeatParams: 1,
      onRepeatScope: 1,
      easeParams: 1,
      yoyo: 1,
      immediateRender: 1,
      repeat: 1,
      repeatDelay: 1,
      data: 1,
      paused: 1,
      reversed: 1,
      autoCSS: 1,
      lazy: 1,
      onOverwrite: 1,
      callbackScope: 1,
      stringFilter: 1,
      id: 1,
      yoyoEase: 1,
      stagger: 1
    },
    _overwriteLookup = {
      none: 0,
      all: 1,
      auto: 2,
      concurrent: 3,
      allOnStart: 4,
      preexisting: 5,
      "true": 1,
      "false": 0
    },
    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
    _rootTimeline = Animation._rootTimeline = new SimpleTimeline(),
    _nextGCFrame = 30,
    _lazyRender = _internals.lazyRender = function () {
      var l = _lazyTweens.length,
        i,
        tween;
      _lazyLookup = {};
      for (i = 0; i < l; i++) {
        tween = _lazyTweens[i];
        if (tween && tween._lazy !== false) {
          tween.render(tween._lazy[0], tween._lazy[1], true);
          tween._lazy = false;
        }
      }
      _lazyTweens.length = 0;
    };
  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  setTimeout(_lazyRender, 1); //on some mobile devices, there isn't a "tick" before code runs which means any lazy renders wouldn't run before the next official "tick".

  Animation._updateRoot = TweenLite.render = function () {
    var i, a, p;
    if (_lazyTweens.length) {
      //if code is run outside of the requestAnimationFrame loop, there may be tweens queued AFTER the engine refreshed, so we need to ensure any pending renders occur before we refresh again.
      _lazyRender();
    }
    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
    if (_lazyTweens.length) {
      _lazyRender();
    }
    if (_ticker.frame >= _nextGCFrame) {
      //dump garbage every 120 frames or whatever the user sets TweenLite.autoSleep to
      _nextGCFrame = _ticker.frame + (parseInt(TweenLite.autoSleep, 10) || 120);
      for (p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;
        while (--i > -1) {
          if (a[i]._gc) {
            a.splice(i, 1);
          }
        }
        if (a.length === 0) {
          delete _tweenLookup[p];
        }
      }
      //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
      p = _rootTimeline._first;
      if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
        while (p && p._paused) {
          p = p._next;
        }
        if (!p) {
          _ticker.sleep();
        }
      }
    }
  };
  _ticker.addEventListener("tick", Animation._updateRoot);
  var _register = function _register(target, tween, scrub) {
      var id = target._gsTweenID,
        a,
        i;
      if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
        _tweenLookup[id] = {
          target: target,
          tweens: []
        };
      }
      if (tween) {
        a = _tweenLookup[id].tweens;
        a[i = a.length] = tween;
        if (scrub) {
          while (--i > -1) {
            if (a[i] === tween) {
              a.splice(i, 1);
            }
          }
        }
      }
      return _tweenLookup[id].tweens;
    },
    _onOverwrite = function _onOverwrite(overwrittenTween, overwritingTween, target, killedProps) {
      var func = overwrittenTween.vars.onOverwrite,
        r1,
        r2;
      if (func) {
        r1 = func(overwrittenTween, overwritingTween, target, killedProps);
      }
      func = TweenLite.onOverwrite;
      if (func) {
        r2 = func(overwrittenTween, overwritingTween, target, killedProps);
      }
      return r1 !== false && r2 !== false;
    },
    _applyOverwrite = function _applyOverwrite(target, tween, props, mode, siblings) {
      var i, changed, curTween, l;
      if (mode === 1 || mode >= 4) {
        l = siblings.length;
        for (i = 0; i < l; i++) {
          if ((curTween = siblings[i]) !== tween) {
            if (!curTween._gc) {
              if (curTween._kill(null, target, tween)) {
                changed = true;
              }
            }
          } else if (mode === 5) {
            break;
          }
        }
        return changed;
      }
      //NOTE: Add tiny amount to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
      var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = tween._duration === 0,
        globalStart;
      i = siblings.length;
      while (--i > -1) {
        if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
          //ignore
        } else if (curTween._timeline !== tween._timeline) {
          globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
          if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
            overlaps[oCount++] = curTween;
          }
        } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= _tinyNum * 2)) {
          overlaps[oCount++] = curTween;
        }
      }
      i = oCount;
      while (--i > -1) {
        curTween = overlaps[i];
        l = curTween._firstPT; //we need to discern if there were property tweens originally; if they all get removed in the next line's _kill() call, the tween should be killed. See https://github.com/greensock/GreenSock-JS/issues/278
        if (mode === 2) if (curTween._kill(props, target, tween)) {
          changed = true;
        }
        if (mode !== 2 || !curTween._firstPT && curTween._initted && l) {
          if (mode !== 2 && !_onOverwrite(curTween, tween)) {
            continue;
          }
          if (curTween._enabled(false, false)) {
            //if all property tweens have been overwritten, kill the tween.
            changed = true;
          }
        }
      }
      return changed;
    },
    _checkOverlap = function _checkOverlap(tween, reference, zeroDur) {
      var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;
      while (tl._timeline) {
        t += tl._startTime;
        ts *= tl._timeScale;
        if (tl._paused) {
          return -100;
        }
        tl = tl._timeline;
      }
      t /= ts;
      return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
    };

  //---- TweenLite instance methods -----------------------------------------------------------------------------

  p._init = function () {
    var v = this.vars,
      op = this._overwrittenProps,
      dur = this._duration,
      immediate = !!v.immediateRender,
      ease = v.ease,
      startAt = this._startAt,
      i,
      initPlugins,
      pt,
      p,
      startVars,
      l;
    if (v.startAt) {
      if (startAt) {
        startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
        startAt.kill();
      }
      startVars = {};
      for (p in v.startAt) {
        //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, 1, from, to).fromTo(e, 1, to, from);
        startVars[p] = v.startAt[p];
      }
      startVars.data = "isStart";
      startVars.overwrite = false;
      startVars.immediateRender = true;
      startVars.lazy = immediate && v.lazy !== false;
      startVars.startAt = startVars.delay = null; //no nesting of startAt objects allowed (otherwise it could cause an infinite loop).
      startVars.onUpdate = v.onUpdate;
      startVars.onUpdateParams = v.onUpdateParams;
      startVars.onUpdateScope = v.onUpdateScope || v.callbackScope || this;
      this._startAt = TweenLite.to(this.target || {}, 0, startVars);
      if (immediate) {
        if (this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if (dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (startAt) {
        startAt.render(-1, true);
        startAt.kill();
        this._startAt = null;
      } else {
        if (this._time !== 0) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediate = false;
        }
        pt = {};
        for (p in v) {
          //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if (!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }
        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        pt.lazy = immediate && v.lazy !== false;
        pt.immediateRender = immediate; //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
        this._startAt = TweenLite.to(this.target, 0, pt);
        if (!immediate) {
          this._startAt._init(); //ensures that the initial values are recorded
          this._startAt._enabled(false); //no need to have the tween render on the next cycle. Disable it because we'll always manually control the renders of the _startAt tween.
          if (this.vars.immediateRender) {
            this._startAt = null;
          }
        } else if (this._time === 0) {
          return;
        }
      }
    }
    this._ease = ease = !ease ? TweenLite.defaultEase : ease instanceof Ease ? ease : typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
    if (v.easeParams instanceof Array && ease.config) {
      this._ease = ease.config.apply(ease, v.easeParams);
    }
    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;
    if (this._targets) {
      l = this._targets.length;
      for (i = 0; i < l; i++) {
        if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null, i)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op, 0);
    }
    if (initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
    }

    if (op) if (!this._firstPT) if (typeof this.target !== "function") {
      //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
      this._enabled(false, false);
    }
    if (v.runBackwards) {
      pt = this._firstPT;
      while (pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }
    this._onUpdate = v.onUpdate;
    this._initted = true;
  };
  p._initProps = function (target, propLookup, siblings, overwrittenProps, index) {
    var p, i, initPlugins, plugin, pt, v;
    if (target == null) {
      return false;
    }
    if (_lazyLookup[target._gsTweenID]) {
      _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)
    }

    if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
      //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
      _autoCSS(this.vars, target);
    }
    for (p in this.vars) {
      v = this.vars[p];
      if (_reservedProps[p]) {
        if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
          this.vars[p] = v = this._swapSelfInParams(v, this);
        }
      } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this, index)) {
        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        //m - mod           [function | 0]
        this._firstPT = pt = {
          _next: this._firstPT,
          t: plugin,
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          n: p,
          pg: 1,
          pr: plugin._priority,
          m: 0
        };
        i = plugin._overwriteProps.length;
        while (--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }
        if (plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }
        if (plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }
        if (pt._next) {
          pt._next._prev = pt;
        }
      } else {
        propLookup[p] = _addPropTween.call(this, target, p, "get", v, p, 0, null, this.vars.stringFilter, index);
      }
    }
    if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
      //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
      this._kill(propLookup, target);
      return this._initProps(target, propLookup, siblings, overwrittenProps, index);
    }
    if (this._firstPT) if (this.vars.lazy !== false && this._duration || this.vars.lazy && !this._duration) {
      //zero duration tweens don't lazy render by default; everything else does.
      _lazyLookup[target._gsTweenID] = true;
    }
    return initPlugins;
  };
  p.render = function (time, suppressEvents, force) {
    var self = this,
      prevTime = self._time,
      duration = self._duration,
      prevRawPrevTime = self._rawPrevTime,
      isComplete,
      callback,
      pt,
      rawPrevTime;
    if (time >= duration - _tinyNum && time >= 0) {
      //to work around occasional floating point math artifacts.
      self._totalTime = self._time = duration;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(1) : 1;
      if (!self._reversed) {
        isComplete = true;
        callback = "onComplete";
        force = force || self._timeline.autoRemoveChildren; //otherwise, if the animation is unpaused/activated after it's already finished, it doesn't get removed from the parent timeline.
      }

      if (duration === 0) if (self._initted || !self.vars.lazy || force) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        if (self._startTime === self._timeline._duration) {
          //if a zero-duration tween is at the VERY end of a timeline and that timeline renders at its end, it will typically add a tiny bit of cushion to the render time to prevent rounding errors from getting in the way of tweens rendering their VERY end. If we then reverse() that timeline, the zero-duration tween will trigger its onReverseComplete even though technically the playhead didn't pass over it again. It's a very specific edge case we must accommodate.
          time = 0;
        }
        if (prevRawPrevTime < 0 || time <= 0 && time >= -_tinyNum || prevRawPrevTime === _tinyNum && self.data !== "isPause") if (prevRawPrevTime !== time) {
          //note: when this.data is "isPause", it's a callback added by addPause() on a timeline that we should not be triggered when LEAVING its exact start time. In other words, tl.addPause(1).play(1) shouldn't pause.
          force = true;
          if (prevRawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < _tinyNum) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      self._totalTime = self._time = 0;
      self.ratio = self._ease._calcEnd ? self._ease.getRatio(0) : 0;
      if (prevTime !== 0 || duration === 0 && prevRawPrevTime > 0) {
        callback = "onReverseComplete";
        isComplete = self._reversed;
      }
      if (time > -_tinyNum) {
        time = 0;
      } else if (time < 0) {
        self._active = false;
        if (duration === 0) if (self._initted || !self.vars.lazy || force) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (prevRawPrevTime >= 0 && !(prevRawPrevTime === _tinyNum && self.data === "isPause")) {
            force = true;
          }
          self._rawPrevTime = rawPrevTime = !suppressEvents || time || prevRawPrevTime === time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      }

      if (!self._initted || self._startAt && self._startAt.progress()) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately. Also, we check progress() because if startAt has already rendered at its end, we should force a render at its beginning. Otherwise, if you put the playhead directly on top of where a fromTo({immediateRender:false}) starts, and then move it backwards, the from() won't revert its values.
        force = true;
      }
    } else {
      self._totalTime = self._time = time;
      if (self._easeType) {
        var r = time / duration,
          type = self._easeType,
          pow = self._easePower;
        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }
        if (type === 3) {
          r *= 2;
        }
        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }
        self.ratio = type === 1 ? 1 - r : type === 2 ? r : time / duration < 0.5 ? r / 2 : 1 - r / 2;
      } else {
        self.ratio = self._ease.getRatio(time / duration);
      }
    }
    if (self._time === prevTime && !force) {
      return;
    } else if (!self._initted) {
      self._init();
      if (!self._initted || self._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      } else if (!force && self._firstPT && (self.vars.lazy !== false && self._duration || self.vars.lazy && !self._duration)) {
        self._time = self._totalTime = prevTime;
        self._rawPrevTime = prevRawPrevTime;
        _lazyTweens.push(self);
        self._lazy = [time, suppressEvents];
        return;
      }
      //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
      if (self._time && !isComplete) {
        self.ratio = self._ease.getRatio(self._time / duration);
      } else if (isComplete && self._ease._calcEnd) {
        self.ratio = self._ease.getRatio(self._time === 0 ? 0 : 1);
      }
    }
    if (self._lazy !== false) {
      //in case a lazy render is pending, we should flush it because the new render is occurring now (imagine a lazy tween instantiating and then immediately the user calls tween.seek(tween.duration()), skipping to the end - the end render would be forced, and then if we didn't flush the lazy render, it'd fire AFTER the seek(), rendering it at the wrong time.
      self._lazy = false;
    }
    if (!self._active) if (!self._paused && self._time !== prevTime && time >= 0) {
      self._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }

    if (prevTime === 0) {
      if (self._startAt) {
        if (time >= 0) {
          self._startAt.render(time, true, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }

      if (self.vars.onStart) if (self._time !== 0 || duration === 0) if (!suppressEvents) {
        self._callback("onStart");
      }
    }
    pt = self._firstPT;
    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * self.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * self.ratio + pt.s;
      }
      pt = pt._next;
    }
    if (self._onUpdate) {
      if (time < 0) if (self._startAt && time !== -0.0001) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        self._startAt.render(time, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
      }

      if (!suppressEvents) if (self._time !== prevTime || isComplete || force) {
        self._callback("onUpdate");
      }
    }
    if (callback) if (!self._gc || force) {
      //check _gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && self._startAt && !self._onUpdate && time !== -0.0001) {
        //-0.0001 is a special value that we use when looping back to the beginning of a repeated TimelineMax, in which case we shouldn't render the _startAt values.
        self._startAt.render(time, true, force);
      }
      if (isComplete) {
        if (self._timeline.autoRemoveChildren) {
          self._enabled(false, false);
        }
        self._active = false;
      }
      if (!suppressEvents && self.vars[callback]) {
        self._callback(callback);
      }
      if (duration === 0 && self._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        self._rawPrevTime = 0;
      }
    }
  };
  p._kill = function (vars, target, overwritingTween) {
    if (vars === "all") {
      vars = null;
    }
    if (vars == null) if (target == null || target === this.target) {
      this._lazy = false;
      return this._enabled(false, false);
    }
    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
    var simultaneousOverwrite = overwritingTween && this._time && overwritingTween._startTime === this._startTime && this._timeline === overwritingTween._timeline,
      firstPT = this._firstPT,
      i,
      overwrittenProps,
      p,
      pt,
      propLookup,
      changed,
      killProps,
      record,
      killed;
    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      while (--i > -1) {
        if (this._kill(vars, target[i], overwritingTween)) {
          changed = true;
        }
      }
    } else {
      if (this._targets) {
        i = this._targets.length;
        while (--i > -1) {
          if (target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if (target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }
      if (propLookup) {
        killProps = vars || propLookup;
        record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(vars) !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
        if (overwritingTween && (TweenLite.onOverwrite || this.vars.onOverwrite)) {
          for (p in killProps) {
            if (propLookup[p]) {
              if (!killed) {
                killed = [];
              }
              killed.push(p);
            }
          }
          if ((killed || !vars) && !_onOverwrite(this, overwritingTween, target, killed)) {
            //if the onOverwrite returned false, that means the user wants to override the overwriting (cancel it).
            return false;
          }
        }
        for (p in killProps) {
          if (pt = propLookup[p]) {
            if (simultaneousOverwrite) {
              //if another tween overwrites this one and they both start at exactly the same time, yet this tween has already rendered once (for example, at 0.001) because it's first in the queue, we should revert the values to where they were at 0 so that the starting values aren't contaminated on the overwriting tween.
              if (pt.f) {
                pt.t[pt.p](pt.s);
              } else {
                pt.t[pt.p] = pt.s;
              }
              changed = true;
            }
            if (pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }

            if (!pt.pg || pt.t._overwriteProps.length === 0) {
              if (pt._prev) {
                pt._prev._next = pt._next;
              } else if (pt === this._firstPT) {
                this._firstPT = pt._next;
              }
              if (pt._next) {
                pt._next._prev = pt._prev;
              }
              pt._next = pt._prev = null;
            }
            delete propLookup[p];
          }
          if (record) {
            overwrittenProps[p] = 1;
          }
        }
        if (!this._firstPT && this._initted && firstPT) {
          //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }
    return changed;
  };
  p.invalidate = function () {
    if (this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }
    var t = this._time;
    this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null;
    this._notifyPluginsOfEnabled = this._active = this._lazy = false;
    this._propLookup = this._targets ? {} : [];
    Animation.prototype.invalidate.call(this);
    if (this.vars.immediateRender) {
      this._time = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)
      this.render(t, false, this.vars.lazy !== false);
    }
    return this;
  };
  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    if (enabled && this._gc) {
      var targets = this._targets,
        i;
      if (targets) {
        i = targets.length;
        while (--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }
    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
    if (this._notifyPluginsOfEnabled) if (this._firstPT) {
      return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
    }
    return false;
  };

  //----TweenLite static methods -----------------------------------------------------

  TweenLite.to = function (target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };
  TweenLite.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenLite(target, duration, vars);
  };
  TweenLite.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenLite(target, duration, toVars);
  };
  TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      callbackScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      immediateRender: false,
      lazy: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };
  TweenLite.set = function (target, vars) {
    return new TweenLite(target, 0, vars);
  };
  TweenLite.getTweensOf = function (target, onlyActive) {
    if (target == null) {
      return [];
    }
    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var i, a, j, t;
    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      a = [];
      while (--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }
      i = a.length;
      //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
      while (--i > -1) {
        t = a[i];
        j = i;
        while (--j > -1) {
          if (t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else if (target._gsTweenID) {
      a = _register(target).concat();
      i = a.length;
      while (--i > -1) {
        if (a[i]._gc || onlyActive && !a[i].isActive()) {
          a.splice(i, 1);
        }
      }
    }
    return a || [];
  };
  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
    if ((0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(onlyActive) === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
      onlyActive = false;
    }
    var a = TweenLite.getTweensOf(target, onlyActive),
      i = a.length;
    while (--i > -1) {
      a[i]._kill(vars, target);
    }
  };

  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another script call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */
  var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);
  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.19.0";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = _addPropTween;
  p.setRatio = _setRatio;
  p._kill = function (lookup) {
    var a = this._overwriteProps,
      pt = this._firstPT,
      i;
    if (lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;
      while (--i > -1) {
        if (lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }
    while (pt) {
      if (lookup[pt.n] != null) {
        if (pt._next) {
          pt._next._prev = pt._prev;
        }
        if (pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }
      pt = pt._next;
    }
    return false;
  };
  p._mod = p._roundProps = function (lookup) {
    var pt = this._firstPT,
      val;
    while (pt) {
      val = lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")];
      if (val && typeof val === "function") {
        //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        if (pt.f === 2) {
          pt.t._applyPT.m = val;
        } else {
          pt.m = val;
        }
      }
      pt = pt._next;
    }
  };
  TweenLite._onPluginEvent = function (type, tween) {
    var pt = tween._firstPT,
      changed,
      pt2,
      first,
      last,
      next;
    if (type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while (pt) {
        next = pt._next;
        pt2 = first;
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
        pt = next;
      }
      pt = tween._firstPT = first;
    }
    while (pt) {
      if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
        changed = true;
      }
      pt = pt._next;
    }
    return changed;
  };
  TweenPlugin.activate = function (plugins) {
    var i = plugins.length;
    while (--i > -1) {
      if (plugins[i].API === TweenPlugin.API) {
        _plugins[new plugins[i]()._propName] = plugins[i];
      }
    }
    return true;
  };

  //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
  _gsDefine.plugin = function (config) {
    if (!config || !config.propName || !config.init || !config.API) {
      throw "illegal plugin definition.";
    }
    var propName = config.propName,
      priority = config.priority || 0,
      overwriteProps = config.overwriteProps,
      map = {
        init: "_onInitTween",
        set: "setRatio",
        kill: "_kill",
        round: "_mod",
        mod: "_mod",
        initAll: "_onInitAllProps"
      },
      Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
        TweenPlugin.call(this, propName, priority);
        this._overwriteProps = overwriteProps || [];
      }, config.global === true),
      p = Plugin.prototype = new TweenPlugin(propName),
      prop;
    p.constructor = Plugin;
    Plugin.API = config.API;
    for (prop in map) {
      if (typeof config[prop] === "function") {
        p[map[prop]] = config[prop];
      }
    }
    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  };

  //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
  a = window._gsQueue;
  if (a) {
    for (i = 0; i < a.length; i++) {
      a[i]();
    }
    for (p in _defLookup) {
      if (!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: " + p);
      }
    }
  }
  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated

  return TweenLite;
}(_gsScope, "TweenLite");
var globals = _gsScope.GreenSockGlobals;
var nonGlobals = globals.com.greensock;

var SimpleTimeline = nonGlobals.core.SimpleTimeline;
var Animation = nonGlobals.core.Animation;
var Ease = globals.Ease;
var Linear = globals.Linear;
var Power0 = (/* unused pure expression or super */ null && (Linear));
var Power1 = globals.Power1;
var Power2 = globals.Power2;
var Power3 = globals.Power3;
var Power4 = globals.Power4;
var TweenPlugin = globals.TweenPlugin;
var EventDispatcher = nonGlobals.events.EventDispatcher;

/***/ }),

/***/ 319:
/***/ (() => {

/* 
 *************************************
 * Get all attributes of an element using jQuery
 *
 * @return {array}                        - Returns a new array.
 * @usage:
 
	$( '#demo' ).attr();  // { "data-a": "1", "id": "b" }

 *************************************
 */
(function (old) {
  $.fn.attr = function () {
    if (arguments.length === 0) {
      if (this.length === 0) {
        return null;
      }
      var obj = {};
      $.each(this[0].attributes, function () {
        if (this.specified) {
          obj[this.name] = this.value;
        }
      });
      return obj;
    }
    return old.apply(this, arguments);
  };
})($.fn.attr);

/***/ }),

/***/ 111:
/***/ (() => {

/* 
 *************************************
 * Scroll Lock
 * @https://gist.github.com/barneycarroll/6550066
 * @return {Void}
 *************************************
 */
/*
	 // Locks the page
	$.scrollLock( true );
	
	// Unlocks the page
	$.scrollLock( false );
*/

(function ($) {
  'use strict';

  $.scrollLock = function scrollLockClosure() {
    var $html = $('html'),
      // State: unlocked by default
      locked = false,
      // State: scroll to revert to
      prevScroll = {
        scrollLeft: $(window).scrollLeft(),
        scrollTop: $(window).scrollTop()
      },
      // State: styles to revert to
      prevStyles = {},
      lockStyles = {
        'overflow-y': 'scroll',
        'position': 'fixed',
        'width': '100%'
      };

    // Instantiate cache in case someone tries to unlock before locking
    saveStyles();

    // Save context's inline styles in cache
    function saveStyles() {
      var styleAttr = $html.attr('style'),
        styleStrs = [],
        styleHash = {};
      if (!styleAttr) {
        return;
      }
      styleStrs = styleAttr.split(/;\s/);
      $.each(styleStrs, function serializeStyleProp(styleString) {
        if (!styleString) {
          return;
        }
        var keyValue = styleString.split(/\s:\s/);
        if (keyValue.length < 2) {
          return;
        }
        styleHash[keyValue[0]] = keyValue[1];
      });
      $.extend(prevStyles, styleHash);
    }
    function lock() {
      var appliedLock = {};

      // Duplicate execution will break DOM statefulness
      if (locked) {
        return;
      }

      // Save scroll state...
      prevScroll = {
        scrollLeft: $(window).scrollLeft(),
        scrollTop: $(window).scrollTop()
      };

      // ...and styles
      saveStyles();

      // Compose our applied CSS
      $.extend(appliedLock, lockStyles, {
        // And apply scroll state as styles
        'left': -prevScroll.scrollLeft + 'px',
        'top': -prevScroll.scrollTop + 'px'
      });

      // Then lock styles...
      $html.css(appliedLock);

      // ...and scroll state
      $(window).scrollLeft(0).scrollTop(0);
      locked = true;
    }
    function unlock() {
      // Duplicate execution will break DOM statefulness
      if (!locked) {
        return;
      }

      // Revert styles
      $html.attr('style', $('<x>').css(prevStyles).attr('style') || '');

      // Revert scroll values
      $(window).scrollLeft(prevScroll.scrollLeft).scrollTop(prevScroll.scrollTop);
      locked = false;
    }
    return function scrollLock(on) {
      // If an argument is passed, lock or unlock depending on truthiness
      if (arguments.length) {
        if (on) {
          lock();
        } else {
          unlock();
        }
      }
      // Otherwise, toggle
      else {
        if (locked) {
          unlock();
        } else {
          lock();
        }
      }
    };
  }();
})(jQuery);

/***/ }),

/***/ 798:
/***/ (() => {

/* 
 *************************************
 * Count To
 *
 * @param  {Number} fixed                - formats a number using fixed-point notation.
 * @param  {Number} from                 - the number the element should start at
 * @param  {Number} to                   - the number the element should end at
 * @param  {Number} speed                - how long it should take to count between the target numbers
 * @param  {Number} refreshInterval      - how often the element should be updated
 * @param  {Boolean} dilimiter           - the number of decimal places to show
 * @param  {Boolean} doubleDigits        - two digits are used by default
 * @param  {Function} onUpdate           - callback method for every time the element is updated
 * @param  {Function} onComplete         - callback method for when the element finishes updating,
 * @return {Void}
 *
 *************************************
 */
(function ($) {
  $.fn.UixCountTo = function (options) {
    options = options || {};
    return $(this).each(function () {
      // set options for current element
      var settings = $.extend({}, $.fn.UixCountTo.defaults, {
        from: $(this).data('counter-start'),
        to: $(this).data('counter-number'),
        fixed: $(this).data('counter-fixed'),
        speed: $(this).data('counter-duration'),
        refreshInterval: $(this).data('counter-refresh-interval'),
        dilimiter: $(this).data('counter-dilimiter'),
        doubleDigits: $(this).data('counter-double-digits'),
        onUpdate: null,
        onComplete: null
      }, options);

      // how many times to update the value, and how much to increment the value on each update
      var loops = Math.ceil(settings.speed / settings.refreshInterval),
        increment = (settings.to - settings.from) / loops;

      // references & variables that will change with each update
      var self = this,
        $self = $(this),
        loopCount = 0,
        value = settings.from,
        data = $self.data('count-to') || {};
      $self.data('count-to', data);

      // if an existing interval can be found, clear it first
      if (data.interval) {
        clearInterval(data.interval);
      }
      data.interval = setInterval(updateTimer, settings.refreshInterval);

      // initialize the element with the starting value
      render(value);
      function updateTimer() {
        value += increment;
        loopCount++;
        render(value);
        if (typeof settings.onUpdate == 'function') {
          settings.onUpdate.call(self, value);
        }
        if (loopCount >= loops) {
          // remove the interval
          $self.removeData('count-to');
          clearInterval(data.interval);
          value = settings.to;
          if (typeof settings.onComplete == 'function') {
            settings.onComplete.call(self, value);
          }
        }
      }
      function render(value) {
        var formattedValue = Number(value).toFixed(settings.fixed);
        if (settings.dilimiter && formattedValue > 0) {
          formattedValue = formattedValue.toString().replace(/\B(?=(?:\d{3})+\b)/g, ',');
        }
        if (settings.doubleDigits) {
          if (formattedValue < 10) {
            formattedValue = '0' + formattedValue;
          }
        }
        $self.html(formattedValue);
      }
    });
  };
  $.fn.UixCountTo.defaults = {
    from: 0,
    to: 0,
    fixed: 0,
    speed: 500,
    refreshInterval: 1,
    dilimiter: true,
    doubleDigits: false,
    onUpdate: null,
    onComplete: null
  };
})(jQuery);

/***/ }),

/***/ 260:
/***/ (() => {

/*
 * Disabled Controls
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsDisable = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: 'input.is-disabled'
    }, options);
    this.each(function () {
      $(settings.controls).prop('disabled', true);
    });
  };
})(jQuery);

/***/ }),

/***/ 366:
/***/ (() => {

/*
 * Hover Effect
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsHover = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.js-uix-float-label'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);

        // on focus add cladd active to label
        $this.on('focus', function () {
          $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
        });

        //on blur check field and remove class if needed
        $this.on('blur change', function (e) {
          if ($this.val() === '' || $this.val() === 'blank') {
            $(this).closest('div').find('label').removeClass('is-active');
          }

          //----
          if ($this.val() === '' || $this.val() === 'blank' || $this.val() != '' && $this.val() != 'blank') {
            $(this).closest('div').find('.uix-controls__bar').removeClass('is-active');
          }
        });

        // if exist cookie value
        if ($this.val() != '' && $this.val() != 'blank') {
          $(this).closest('div').find('label').addClass('is-active');
        }
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 283:
/***/ (() => {

/*
 * Render Custom File Dropzone
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFileDropzone = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-field-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $dropZone = $(this).find('input[type="file"]');
        $(document).on('dragover', function (e) {
          var timeout = window.dropZoneTimeout;
          if (!timeout) {
            $dropZone.addClass('in');
          } else {
            clearTimeout(timeout);
          }
          var found = false,
            node = e.target;
          do {
            if (node === $dropZone[0]) {
              found = true;
              break;
            }
            node = node.parentNode;
          } while (node != null);
          if (found) {
            $dropZone.addClass('hover');
          } else {
            $dropZone.removeClass('hover');
          }
          window.dropZoneTimeout = setTimeout(function () {
            window.dropZoneTimeout = null;
            $dropZone.removeClass('in hover');
          }, 100);
        });
        $dropZone.on('change', function (e) {
          var input = $(this)[0];
          if (input.files && input.files[0]) {
            var reader = new FileReader();
            reader.onload = function (e) {
              var imgData = e.target.result;
              var imgName = input.files[0].name;
              input.setAttribute('data-title', imgName);
              //console.log(e.target.result);
            };

            reader.readAsDataURL(input.files[0]);
          }
        });
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 433:
/***/ (() => {

/*
 * Render Custom File Type
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomFile = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__file-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $fileInput = $(this).find('input[type="file"]'),
          $fileBtn = $(this).find('.uix-controls__file-trigger'),
          $filePath = $(this).next('.uix-controls__file-return');
        $fileBtn.off('click').on('click', function () {
          $fileInput.focusin();
        });
        $fileInput.on('change', function () {
          $filePath.text($(this).val());
        });
      });
    });
  };
})(jQuery);

/***/ }),

/***/ 126:
/***/ (() => {

/*!
 * jQuery Mousewheel 3.1.13
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 */

(function ($) {
  var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
    toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
    slice = Array.prototype.slice,
    nullLowestDeltaTimeout,
    lowestDelta;
  if ($.event.fixHooks) {
    for (var i = toFix.length; i;) {
      $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
    }
  }
  var special = $.event.special.mousewheel = {
    version: '3.1.12',
    setup: function setup() {
      if (this.addEventListener) {
        for (var i = toBind.length; i;) {
          this.addEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = handler;
      }
      // Store the line height and page height for this particular element
      $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
      $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
    },
    teardown: function teardown() {
      if (this.removeEventListener) {
        for (var i = toBind.length; i;) {
          this.removeEventListener(toBind[--i], handler, false);
        }
      } else {
        this.onmousewheel = null;
      }
      // Clean up the data we added to the element
      $.removeData(this, 'mousewheel-line-height');
      $.removeData(this, 'mousewheel-page-height');
    },
    getLineHeight: function getLineHeight(elem) {
      var $elem = $(elem),
        $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
      if (!$parent.length) {
        $parent = $('body');
      }
      return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
    },
    getPageHeight: function getPageHeight(elem) {
      return $(elem).height();
    },
    settings: {
      adjustOldDeltas: true,
      // see shouldAdjustOldDeltas() below
      normalizeOffset: true // calls getBoundingClientRect for each event
    }
  };

  $.fn.extend({
    mousewheel: function mousewheel(fn) {
      return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
    },
    unmousewheel: function unmousewheel(fn) {
      return this.unbind('mousewheel', fn);
    }
  });
  function handler(event) {
    var orgEvent = event || window.event,
      args = slice.call(arguments, 1),
      delta = 0,
      deltaX = 0,
      deltaY = 0,
      absDelta = 0,
      offsetX = 0,
      offsetY = 0;
    event = $.event.fix(orgEvent);
    event.type = 'mousewheel';

    // Old school scrollwheel delta
    if ('detail' in orgEvent) {
      deltaY = orgEvent.detail * -1;
    }
    if ('wheelDelta' in orgEvent) {
      deltaY = orgEvent.wheelDelta;
    }
    if ('wheelDeltaY' in orgEvent) {
      deltaY = orgEvent.wheelDeltaY;
    }
    if ('wheelDeltaX' in orgEvent) {
      deltaX = orgEvent.wheelDeltaX * -1;
    }

    // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
    if ('axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
      deltaX = deltaY * -1;
      deltaY = 0;
    }

    // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
    delta = deltaY === 0 ? deltaX : deltaY;

    // New school wheel delta (wheel event)
    if ('deltaY' in orgEvent) {
      deltaY = orgEvent.deltaY * -1;
      delta = deltaY;
    }
    if ('deltaX' in orgEvent) {
      deltaX = orgEvent.deltaX;
      if (deltaY === 0) {
        delta = deltaX * -1;
      }
    }

    // No change actually happened, no reason to go any further
    if (deltaY === 0 && deltaX === 0) {
      return;
    }

    // Need to convert lines and pages to pixels if we aren't already in pixels
    // There are three delta modes:
    //   * deltaMode 0 is by pixels, nothing to do
    //   * deltaMode 1 is by lines
    //   * deltaMode 2 is by pages
    if (orgEvent.deltaMode === 1) {
      var lineHeight = $.data(this, 'mousewheel-line-height');
      delta *= lineHeight;
      deltaY *= lineHeight;
      deltaX *= lineHeight;
    } else if (orgEvent.deltaMode === 2) {
      var pageHeight = $.data(this, 'mousewheel-page-height');
      delta *= pageHeight;
      deltaY *= pageHeight;
      deltaX *= pageHeight;
    }

    // Store lowest absolute delta to normalize the delta values
    absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
    if (!lowestDelta || absDelta < lowestDelta) {
      lowestDelta = absDelta;

      // Adjust older deltas if necessary
      if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
        lowestDelta /= 40;
      }
    }

    // Adjust older deltas if necessary
    if (shouldAdjustOldDeltas(orgEvent, absDelta)) {
      // Divide all the things by 40!
      delta /= 40;
      deltaX /= 40;
      deltaY /= 40;
    }

    // Get a whole, normalized value for the deltas
    delta = Math[delta >= 1 ? 'floor' : 'ceil'](delta / lowestDelta);
    deltaX = Math[deltaX >= 1 ? 'floor' : 'ceil'](deltaX / lowestDelta);
    deltaY = Math[deltaY >= 1 ? 'floor' : 'ceil'](deltaY / lowestDelta);

    // Normalise offsetX and offsetY properties
    if (special.settings.normalizeOffset && this.getBoundingClientRect) {
      var boundingRect = this.getBoundingClientRect();
      offsetX = event.clientX - boundingRect.left;
      offsetY = event.clientY - boundingRect.top;
    }

    // Add information to the event object
    event.deltaX = deltaX;
    event.deltaY = deltaY;
    event.deltaFactor = lowestDelta;
    event.offsetX = offsetX;
    event.offsetY = offsetY;
    // Go ahead and set deltaMode to 0 since we converted to pixels
    // Although this is a little odd since we overwrite the deltaX/Y
    // properties with normalized deltas.
    event.deltaMode = 0;

    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);

    // Clearout lowestDelta after sometime to better
    // handle multiple device types that give different
    // a different lowestDelta
    // Ex: trackpad = 3 and mouse wheel = 120
    if (nullLowestDeltaTimeout) {
      clearTimeout(nullLowestDeltaTimeout);
    }
    nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);
    return ($.event.dispatch || $.event.handle).apply(this, args);
  }
  function nullLowestDelta() {
    lowestDelta = null;
  }
  function shouldAdjustOldDeltas(orgEvent, absDelta) {
    // If this is an older event and the delta is divisable by 120,
    // then we are assuming that the browser is treating this as an
    // older mouse wheel event and that we should divide the deltas
    // by 40 to try and get a more usable deltaFactor.
    // Side note, this actually impacts the reported scroll distance
    // in older browsers and can cause scrolling to be slower than native.
    // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
    return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
  }
})(jQuery);

/***/ }),

/***/ 782:
/***/ (() => {

/**
 * jQuery.fn.sortElements
 * --------------
 * @author James Padolsey (http://james.padolsey.com)
 * @version 0.11
 * @updated 18-MAR-2010
 * --------------
 * @param Function comparator:
 *   Exactly the same behaviour as [1,2,3].sort(comparator)
 *   
 * @param Function getSortable
 *   A function that should return the element that is
 *   to be sorted. The comparator will run on the
 *   current collection, but you may want the actual
 *   resulting sort to occur on a parent or another
 *   associated element.
 *   
 *   E.g. $('td').sortElements(comparator, function(){
 *      return this.parentNode; 
 *   })
 *   
 *   The <td>'s parent (<tr>) will be sorted instead
 *   of the <td> itself.
 */
jQuery.fn.sortElements = function () {
  var sort = [].sort;
  return function (comparator, getSortable) {
    getSortable = getSortable || function () {
      return this;
    };
    var placements = this.map(function () {
      var sortElement = getSortable.call(this),
        parentNode = sortElement.parentNode,
        // Since the element itself will change position, we have
        // to have some way of storing it's original position in
        // the DOM. The easiest way is to have a 'flag' node:
        nextSibling = parentNode.insertBefore(document.createTextNode(''), sortElement.nextSibling);
      return function () {
        if (parentNode === this) {
          throw new Error("You can't sort elements if any one is a descendant of another.");
        }

        // Insert before flag:
        parentNode.insertBefore(this, nextSibling);
        // Remove flag:
        parentNode.removeChild(nextSibling);
      };
    });
    return sort.call(this, comparator).each(function (i) {
      placements[i].call(getSortable.call(this));
    });
  };
}();

/***/ }),

/***/ 2:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (/* binding */ _typeof)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";

// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__(2);
;// CONCATENATED MODULE: ./src/components/_global/js/index.js

/**

	TABLE OF CONTENTS
	---------------------------


	1.Base
    2.Body And Header
    3.Common Height
    4.Get all custom attributes of an element like "data-*"
    5.Loader
    6.Mega Menu
    7.Mobile Menu
    8.Navigation
    9.Specify a background image
    10.Videos
    11.Theme Scripts
    12.Accordion Background Images
    13.Accordion
    14.Advanced Slider (Basic)
    15.Advanced Slider (Special Effects)
    16.Ajax Push Content
    17.Ajax Page Loader (Loading A Page via Ajax Into Div)
    18.Back to Top
    19.Circle Layout
    20.Counter
    21.Dropdown Menu
    22.Dropdown Menu 2 (Multi-level drop-down navigation)
    23.Cascading DropDown List
    24.Flexslider (Third-party plugin)
    25.Floating Side Element
    26.Form Progress
    27.Form
    28.Gallery
    29.Hybrid Content Slider
    30.Hover Delay Interaction
    31.Image Shapes
    32.Infinite Scrolling Element
    33.Lava-Lamp Style Menu
    34.Custom Lightbox
    35.Bulleted List
    36.Posts List With Ajax
    37.Full Width Column to Edge
    38.Login Templates
    39.Modal Dialog
    40.Mousewheel Interaction
    41.Multiple Items Carousel
    42.Full Page/One Page Transition
    43.Full Page/One Page Transition 2
    44.Parallax
    45.Periodical Scroll
    46.Pricing
    47.Progress Bar
    48.Progress Line
    49.Retina Graphics for Website
    50.Rotating Elements
    51.Scroll Reveal
    52.Scrollspy Animate
    53.Show More Less
    54.Skew Based On Velocity of Scroll
    55.Smooth Scrolling When Clicking An Anchor Link
    56.Smooth Scrolling Page
    57.Sticky Elements
    58.SVG Map (China)
    59.SVG Map (World)
    60.SVG Mask Slider


*/

/*
 *************************************
 * <!-- Base -->
 *************************************
 */
/* !!! To build a table of contents (TOC), you need to import this scss file into JS */


/*
 * Global variables from front pages
 *
 * @private
 */
var
  //If the file is in the root directory, you can leave it empty.
  //If in another directory, you can write: "/blog"
  templateUrl,
  //Eg. https://uiux.cc
  homeUrl,
  //Eg. https://uiux.cc/wp-admin/admin-ajax.php
  ajaxUrl;
if (typeof APP_ROOTPATH === 'undefined') {
  templateUrl = '';
  homeUrl = '';
  ajaxUrl = '';
} else {
  templateUrl = APP_ROOTPATH.templateUrl.replace(/\/\s*$/, '');
  homeUrl = APP_ROOTPATH.homeUrl.replace(/\/\s*$/, '');
  ajaxUrl = APP_ROOTPATH.ajaxUrl.replace(/\/\s*$/, '');
}

/*
 * Determine whether it is a special browser
 *
 * @private
 */
// Add feature test for passive event listener support
var supportsPassive = false;
try {
  document.addEventListener("test", null, {
    get passive() {
      supportsPassive = true;
    }
  });
} catch (e) {}
var browser = {
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
  isAndroid: /(android)/i.test(navigator.userAgent),
  isPC: !navigator.userAgent.match(/(iPhone|iPod|Android|ios|Mobile)/i),
  isSafari: !!navigator.userAgent.match(/Version\/[\d\.]+.*Safari/),
  /*Test to 9, 10. */
  isIE: !!window.ActiveXObject || "ActiveXObject" in window,
  /*Test to 6 ~ 11 (not edge) */
  supportsPassive: supportsPassive
};

/*
 * Core scripts for current site
 *
 * @private
 * @description Used for all modules from ./src/components/[__]/js
 * @requires ./examples/assets/js/min/jquery.waitforimages.min.js
 * @requires ./examples/assets/js/min/video.min.js
 * @requires ./examples/assets/js/min/TweenMax.min.js
 */
var UixModuleInstance = function ($, window, document) {
  var _APP = {},
    components = {
      documentReady: [],
      pageLoaded: []
    };
  if ($('img').length == 0) {
    $('body').prepend('<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" style="display:none">');
  }
  if ($.isFunction($.fn.waitForImages)) {
    $('body').waitForImages(pageLoaded);
  } else {
    $(window).on('load', pageLoaded);
  }
  $(document).ready(documentReady);
  function documentReady(context) {
    context = (0,esm_typeof/* default */.Z)(context) == ( true ? "undefined" : 0) ? $ : context;
    components.documentReady.forEach(function (component) {
      component(context);
    });
  }
  function pageLoaded(context) {
    context = (0,esm_typeof/* default */.Z)(context) == "object" ? $ : context;
    components.pageLoaded.forEach(function (component) {
      component(context);
    });
  }
  _APP.setContext = function (contextSelector) {
    var context = $;
    if ((0,esm_typeof/* default */.Z)(contextSelector) !== ( true ? "undefined" : 0)) {
      return function (selector) {
        return $(contextSelector).find(selector);
      };
    }
    return context;
  };
  _APP.components = components;
  _APP.documentReady = documentReady;
  _APP.pageLoaded = pageLoaded;
  return _APP;
}($, window, document);

/*
 * Create GUID / UUID
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}                        - The globally-unique identifiers.
 */
var UixGUID = UixGUID || function () {
  function t() {}
  return t.version = "0.0.1", t.create = function () {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
      var r = Math.random() * 16 | 0,
        v = c == 'x' ? r : r & 0x3 | 0x8;
      return v.toString(16);
    });
  },
  //
  t;
}();

/*
 * Evaluating a string as a mathematical expression in JavaScript
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @return {String}            - New calculation result.
 */
var UixMath = UixMath || function () {
  function t() {}
  return t.version = "0.0.1", t.evaluate = function (s) {
    var chars = s.replace(/\s/g, '').split("");
    var n = [],
      op = [],
      index = 0,
      oplast = true;
    n[index] = "";

    // Parse the expression
    for (var c = 0; c < chars.length; c++) {
      if (isNaN(parseInt(chars[c])) && chars[c] !== "." && !oplast) {
        op[index] = chars[c];
        index++;
        n[index] = "";
        oplast = true;
      } else {
        n[index] += chars[c];
        oplast = false;
      }
    }

    // Calculate the expression
    s = parseFloat(n[0]);
    for (var o = 0; o < op.length; o++) {
      var num = parseFloat(n[o + 1]);
      switch (op[o]) {
        case "+":
          s = s + num;
          break;
        case "-":
          s = s - num;
          break;
        case "*":
          s = s * num;
          break;
        case "/":
          s = s / num;
          break;
      }
    }
    return s;
  },
  //
  t;
}();

/*
 * Get the CSS property
 *
 * @private
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {!Element} el     - The Element for which to get the computed style. Using class name or ID to locate.
 * @return {String|Object}   - The value of property.
 */
var UixCssProperty = UixCssProperty || function () {
  function t() {}
  return t.version = "0.0.1", t.getTransitionDuration = function (el) {
    if ((0,esm_typeof/* default */.Z)(el) === ( true ? "undefined" : 0)) {
      return 0;
    }
    var style = window.getComputedStyle(el),
      duration = style.webkitTransitionDuration,
      delay = style.webkitTransitionDelay;
    if ((0,esm_typeof/* default */.Z)(duration) != ( true ? "undefined" : 0)) {
      // fix miliseconds vs seconds
      duration = duration.indexOf("ms") > -1 ? parseFloat(duration) : parseFloat(duration) * 1000;
      delay = delay.indexOf("ms") > -1 ? parseFloat(delay) : parseFloat(delay) * 1000;
      return duration;
    } else {
      return 0;
    }
  },
  //
  t.getAbsoluteCoordinates = function (el) {
    var windowWidth = window.innerWidth,
      leftPos = null,
      topPos = null;
    if (!document.getElementsByTagName('body')[0].className.match(/rtl/)) {
      leftPos = el.offsetLeft == 0 ? el.parentElement.offsetLeft : el.offsetLeft;
      topPos = el.offsetTop == 0 ? el.parentElement.offsetTop : el.offsetTop;
    } else {
      // width and height in pixels, including padding and border
      // Corresponds to jQuery outerWidth(), outerHeight()
      leftPos = el.offsetLeft == 0 ? windowWidth - (el.parentElement.offsetLeft + el.parentElement.offsetWidth) : windowWidth - (el.offsetLeft + el.offsetWidth);
      topPos = el.offsetTop == 0 ? windowWidth - (el.parentElement.offsetTop + el.parentElement.offsetHeight) : windowWidth - (el.offsetTop + el.offsetHeight);
    }
    return {
      'left': leftPos,
      'top': topPos
    };
  },
  //
  t;
}();

/*
* Throttle
*
* @param  {Function} fn    - A function to be executed within the time limit.
* @param  {Number} limit   - Waiting time.
* @return {Void}    
*/
var UixThrottle = function UixThrottle(fn) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  var waiting = false;
  return function () {
    if (!waiting) {
      fn.apply(this, arguments);
      waiting = true;
      setTimeout(function () {
        waiting = false;
      }, limit);
    }
  };
};

/*
* Debounce
*
* @param  {Function} fn    - A function to be executed within the time limit.
* @param  {Number} limit   - Waiting time.
* @return {Void}    
*/
var UixDebounce = function UixDebounce(fn) {
  var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;
  var timer;
  return function () {
    //Every time this returned function is called, the timer is cleared to ensure that fn is not executed
    clearTimeout(timer);

    // When the returned function is called for the last time (that is the user stops a continuous operation)
    // Execute fn after another delay milliseconds
    timer = setTimeout(function () {
      fn.apply(this, arguments);
    }, limit);
  };
};
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixModuleFilter.js

/*
 * Method of deleting or adding a module
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean|String} destroy       - If it is a string, it means destroying this module from UixModuleInstance
 * @param  {Object} add                     - New module data via JSON.
 * @param  {String} add.moduleName        - The name of the module (the default is all uppercase).
 * @param  {Boolean} add.pageLoaded       - Window loading module method. If true or 1, the module will execute after the page is loaded.
 * @param  {Number} add.version           - The new module version number.
 * @param  {Function} add.callback        - The new module script of function.
 * @return {Void}      
 *
 * @Usage:
 * !!! The code is to be inserted in front of the uix-kit core script.
	
	
<script>
window.MAIN = null;
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixModuleFilter( { 
		   'destroy' : 'MAIN',
		   'add'     : {
							moduleName    : 'YOUR_MODULE_NAME',
							pageLoaded    : true,
							version       : '0.0.1',
							callback      : function() {
								//the module will execute after the page is loaded.

							}
						}
		} );
    } );
} ) ( jQuery );
</script>

 *
 * 
 */


(function ($) {
  'use strict';

  $.fn.UixModuleFilter = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      destroy: false,
      add: {
        moduleName: 'OLD_MODULE_NAME',
        pageLoaded: false,
        version: '0.0.1',
        callback: function callback() {}
      }
    }, options);
    this.each(function () {
      //remove a module
      //-------------------------------------	
      if (settings.destroy && Object.prototype.toString.call(settings.destroy) == '[object String]') {
        var moduleName = settings.destroy;
        if ((0,esm_typeof/* default */.Z)(UixModuleInstance[moduleName]) != ( true ? "undefined" : 0)) {
          delete UixModuleInstance[moduleName];
        }
      }

      //add or replace a module
      //-------------------------------------	
      if (settings.add && Object.prototype.toString.call(settings.add) == '[object Object]' && settings.add.hasOwnProperty('pageLoaded')) {
        var _moduleName2 = settings.add.moduleName;

        //delete the old module if exist
        if ((0,esm_typeof/* default */.Z)(UixModuleInstance[_moduleName2]) != ( true ? "undefined" : 0)) {
          console.log('The module already exists, please destroy the old module or change the new module name.');
        } else {
          //loading mode "documentReady"
          if (!settings.add.pageLoaded || settings.add.pageLoaded == 0) {
            var _moduleName = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;
              module[_moduleName2].documentReady = function ($) {
                settings.add.callback();
              };
              module.components.documentReady.push(module[_moduleName2].documentReady);
              return _moduleName;
            }(UixModuleInstance, jQuery, window, document);
            UixModuleInstance[_moduleName2].documentReady($);
          }

          //loading mode "pageLoaded"
          if (settings.add.pageLoaded || settings.add.pageLoaded == 1) {
            var _moduleName3 = function (module, $, window, document) {
              module[_moduleName2] = module[_moduleName2] || {};
              module[_moduleName2].version = settings.add.version;
              module[_moduleName2].pageLoaded = function () {
                settings.add.callback();
              };
              module.components.pageLoaded.push(module[_moduleName2].pageLoaded);
              return _moduleName3;
            }(UixModuleInstance, jQuery, window, document);
            UixModuleInstance[_moduleName2].pageLoaded();
          }
        }
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncScripts.js
/*
 * Apply some asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} scrollReveal          - Run script of module "Scroll Reveal". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxPostList          - Run script of module "Posts List With Ajax". a page commonly used to
 *                                           load asynchronous information
 * @param  {Boolean} ajaxDDList            - Run script of module "Cascading DropDown List".
 * @param  {Boolean} counterAnim           - Run script of module "Counter".
 * @return {Void}
 *
 * @Usage:
    
	
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncScripts({
			scrollReveal    : true,
			ajaxPostList    : true,
			ajaxDDList      : true,
			counterAnim     : true,
			lightBox        : true 
		});
    } );
} ) ( jQuery );
</script>

 

 *
 * 
 */

(function ($) {
  'use strict';

  $.fn.UixApplyAsyncScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      scrollReveal: true,
      // @from ./src/components/scroll-reveal
      ajaxPostList: true,
      // @from ./src/components/list-posts
      ajaxDDList: true,
      // @from ./src/components/cascading-dropdown-list
      counterAnim: true,
      // @from ./src/components/counter
      lightBox: true // @from ./src/components/lightbox
    }, options);
    this.each(function () {
      //----
      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.pageLoaded(); //Theme Scripts
      if (UixModuleInstance.COMMON_HEIGHT) UixModuleInstance.COMMON_HEIGHT.pageLoaded(); //Common Height
      if (UixModuleInstance.ADVANCED_SLIDER) UixModuleInstance.ADVANCED_SLIDER.pageLoaded(); //Advanced Slider (Basic)
      if (UixModuleInstance.ADVANCED_SLIDER_FILTER) UixModuleInstance.ADVANCED_SLIDER_FILTER.pageLoaded(); //Advanced Slider
      if (UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE) UixModuleInstance.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded(); //Full Width Column to Edge
      if (UixModuleInstance.STICKY_EL) UixModuleInstance.STICKY_EL.pageLoaded(); //Sticky Elements
      if (UixModuleInstance.TEXT_EFFECT) UixModuleInstance.TEXT_EFFECT.pageLoaded(); //Text effect
      if (UixModuleInstance.TIMELINE) UixModuleInstance.TIMELINE.pageLoaded(); //Timeline
      if (UixModuleInstance.HYBRID_CONTENT_SLIDER) UixModuleInstance.HYBRID_CONTENT_SLIDER.pageLoaded(); //Hybrid Content Slider

      //----
      if (UixModuleInstance.MAIN) UixModuleInstance.MAIN.documentReady($); //Theme Scripts
      if (UixModuleInstance.TABLE) UixModuleInstance.TABLE.documentReady($); //Responsive Table
      if (UixModuleInstance.TABLE_SORTER) UixModuleInstance.TABLE_SORTER.documentReady($); //Table Sorter
      if (UixModuleInstance.MODAL_DIALOG) UixModuleInstance.MODAL_DIALOG.documentReady($); //Modal Dialog
      if (UixModuleInstance.PARALLAX) UixModuleInstance.PARALLAX.documentReady($); //Parallax
      if (UixModuleInstance.VIDEOS) UixModuleInstance.VIDEOS.documentReady($); //Videos
      if (UixModuleInstance.BODY_AND_HEADER) UixModuleInstance.BODY_AND_HEADER.documentReady($); //Header Area
      if (UixModuleInstance.SET_BG) UixModuleInstance.SET_BG.documentReady($); //Specify a background image
      if (UixModuleInstance.GET_CUSTOM_ATTRS) UixModuleInstance.GET_CUSTOM_ATTRS.documentReady($); //Get all custom attributes of an element like "data-*"
      if (UixModuleInstance.PAGINATION) UixModuleInstance.PAGINATION.documentReady($); //Pagination
      if (UixModuleInstance.FORM) UixModuleInstance.FORM.documentReady($); //Form
      if (UixModuleInstance.FLEXSLIDER) UixModuleInstance.FLEXSLIDER.documentReady($); //Flexslider (Third-party plugin)
      if (UixModuleInstance.RETINA) UixModuleInstance.RETINA.documentReady($); //Retina Graphics for Website
      if (UixModuleInstance.SHOW_MORELESS) UixModuleInstance.SHOW_MORELESS.documentReady($); //Show More Less
      if (UixModuleInstance.DROPDOWN_MENU) UixModuleInstance.DROPDOWN_MENU.documentReady($); //Dropdown Menu
      if (UixModuleInstance.DROPDOWN_MENU2) UixModuleInstance.DROPDOWN_MENU2.documentReady($); //Dropdown Menu2
      if (UixModuleInstance.ACCORDION) UixModuleInstance.ACCORDION.documentReady($); //Accordion
      if (UixModuleInstance.GALLERY) UixModuleInstance.GALLERY.documentReady($); //Gallery
      if (UixModuleInstance.IMAGE_SHAPES) UixModuleInstance.IMAGE_SHAPES.documentReady($); //Image Shapes
      if (UixModuleInstance.PERIODICAL_SCROLL) UixModuleInstance.PERIODICAL_SCROLL.documentReady($); //Periodical Scroll
      if (UixModuleInstance.PRICING) UixModuleInstance.PRICING.documentReady($); //Pricing
      if (UixModuleInstance.PROGRESS_BAR) UixModuleInstance.PROGRESS_BAR.documentReady($); //Progress Bar
      if (UixModuleInstance.PROGRESS_LINE) UixModuleInstance.PROGRESS_LINE.documentReady($); //Progress Line
      if (UixModuleInstance.ROTATING_EL) UixModuleInstance.ROTATING_EL.documentReady($); //Rotating Elements
      if (UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK) UixModuleInstance.SMOOTH_SCROLLING_ANCHORLINK.documentReady($); //Smooth Scrolling When Clicking An Anchor Link
      if (UixModuleInstance.SWIPER) UixModuleInstance.SWIPER.documentReady($); //SWIPER (Third-party plugin)
      if (UixModuleInstance.TABS) UixModuleInstance.TABS.documentReady($); //Tabs
      if (UixModuleInstance.TEAM_FOCUS) UixModuleInstance.TEAM_FOCUS.documentReady($); //Team Focus
      if (UixModuleInstance.LAVA_LAMP_STYLE_MENU) UixModuleInstance.LAVA_LAMP_STYLE_MENU.documentReady($); //Lava-Lamp Style Menu
      if (UixModuleInstance.CIRCLE_LAYOUT) UixModuleInstance.CIRCLE_LAYOUT.documentReady($); //Circle Layout
      if (UixModuleInstance.MULTI_ITEMS_CAROUSEL) UixModuleInstance.MULTI_ITEMS_CAROUSEL.documentReady($); //Multiple Items Carousel
      if (UixModuleInstance.THREE_BACKGROUND) UixModuleInstance.THREE_BACKGROUND.documentReady($); //3D Background
      if (UixModuleInstance.THREE_CAROUSEL) UixModuleInstance.THREE_CAROUSEL.documentReady($); //3D Carousel
      if (UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER) UixModuleInstance.THREE_LIQUID_SCROLLSPY_SLIDER.documentReady($); //3D Liquid Scrollspy Slider

      //---- Prevent overlay clicks on asynchronous requests
      //---- Commonly used for AJAX modules that are clicked by button
      //Scroll Reveal
      if (settings.scrollReveal) {
        if (UixModuleInstance.SCROLL_REVEAL) UixModuleInstance.SCROLL_REVEAL.documentReady($);
      }

      //Posts List With Ajax
      if (settings.ajaxPostList) {
        if (UixModuleInstance.POST_LIST_AJAX) UixModuleInstance.POST_LIST_AJAX.documentReady($);
      }

      //Cascading DropDown List
      if (settings.ajaxDDList) {
        if (UixModuleInstance.CASCADING_DD_LIST) UixModuleInstance.CASCADING_DD_LIST.documentReady($);
      }

      //Counter
      if (settings.counterAnim) {
        if (UixModuleInstance.COUNTER) UixModuleInstance.COUNTER.documentReady($);
      }

      //Custom Lightbox
      if (settings.lightBox) {
        if (UixModuleInstance.LIGHTBOX) UixModuleInstance.LIGHTBOX.pageLoaded();
      }

      //----Uix Shortcodes (WordPress Plugin)
      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixApplyAsyncAllScripts.js
/*
 * Apply all the asynchronism scripts
 *
 * @global
 * @description This function can be used separately in HTML pages or custom JavaScript.
 * @param  {Boolean} runAll          - Run all module scripts.
 * @return {Void}
 *
 * @Usage:
    
<script>
( function( $ ) {
"use strict";
    $( document ).ready( function() {
		$( document ).UixApplyAsyncAllScripts();
    } );
} ) ( jQuery );
</script>
	

 *
 * 
 */

(function ($) {
  'use strict';

  $.fn.UixApplyAsyncAllScripts = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      runAll: true
    }, options);
    this.each(function () {
      var scipts_pageLoaded = UixModuleInstance.components.pageLoaded,
        scipts_documentReady = UixModuleInstance.components.documentReady;
      if (settings.runAll) {
        for (var i = 0; i < scipts_pageLoaded.length; i++) {
          scipts_pageLoaded[i]();
        }
        for (var j = 0; j < scipts_documentReady.length; j++) {
          scipts_documentReady[j]($);
        }
      }

      //Uix Shortcodes
      if ($.isFunction($.uix_sc_init)) {
        $.uix_sc_init();
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./src/components/_global/js/modules/body-and-header.js


/* 
 *************************************
 * <!-- Body And Header -->
 *************************************
 */

var BODY_AND_HEADER = function (module, $, window, document) {
  if (window.BODY_AND_HEADER === null) return false;
  module.BODY_AND_HEADER = module.BODY_AND_HEADER || {};
  module.BODY_AND_HEADER.version = '0.0.8';
  module.BODY_AND_HEADER.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //-------- Header initialize
    headerInit(windowWidth);
    function headerInit(w) {
      var $headerPlaceholder = $('.uix-header__placeholder.js-uix-header__placeholder-autoheight');
      if (w > 768) {
        $headerPlaceholder.css('height', $('.uix-header__container').outerHeight(true) + 'px');
        $('body').removeClass('is-mobile');
      } else {
        $headerPlaceholder.css('height', 0);
        $('body').addClass('is-mobile');
      }
    }
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        headerInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    //-------- Sticky header area
    var $el = $('.uix-header__container, .uix-header__placeholder');
    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
        spyTop = 220;
      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };
  module.components.documentReady.push(module.BODY_AND_HEADER.documentReady);
  return /*#__PURE__*/_createClass(function BODY_AND_HEADER() {
    _classCallCheck(this, BODY_AND_HEADER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/common-height.js


/* 
 *************************************
 * <!-- Common Height -->
 
 *
 * Note: 
 *
 * Automatically sets the div height of the grid system to the height of the 
 * outer container when ".js-uix-common-height" class on ".row" or ".uix-core-grid__row" div.
 *
 *************************************
 */

var COMMON_HEIGHT = function (module, $, window, document) {
  if (window.COMMON_HEIGHT === null) return false;
  module.COMMON_HEIGHT = module.COMMON_HEIGHT || {};
  module.COMMON_HEIGHT.version = '0.0.4';
  module.COMMON_HEIGHT.pageLoaded = function () {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    commonHeightInit(windowWidth);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        commonHeightInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    function commonHeightInit(w) {
      $('.js-uix-common-height').each(function () {
        var $this = $(this);
        var element = $this;
        var selectors = '[class*=col-], [class*=uix-core-grid__col-]'; //Bootstrap grid system and Custom uix grid system
        var maxHeight = 0;

        // Select and loop the elements you want to equalise
        element.children(selectors).each(function () {
          var element = $(this);

          //Solve the problem that the image cannot be read accurately
          element.find('img').each(function () {
            var imgOuter = $(this).parent('a').css('display');
            if (imgOuter == 'inline') {
              $(this).parent('a').css('display', 'inline-block');
            }
          });
          if (element.hasClass('max-height')) {
            // if has max-height
            maxHeight = element.outerHeight();
          } else {
            // if this box is higher than the cached highest then store it
            if (element.height() > maxHeight) {
              maxHeight = element.outerHeight();
            }
          }
        });

        // Set the height of all those children to whichever was highest 
        if (w > 768) {
          element.children(selectors).each(function () {
            $(this).css('height', maxHeight);
          });
        } else {
          element.children(selectors).each(function () {
            $(this).css('height', 'auto');
          });
        }
      });
    }
  };
  module.components.pageLoaded.push(module.COMMON_HEIGHT.pageLoaded);
  return /*#__PURE__*/_createClass(function COMMON_HEIGHT() {
    _classCallCheck(this, COMMON_HEIGHT);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/Miscellaneous/attrExt.js
var attrExt = __webpack_require__(319);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/custom-data-attrs.js


/* 
 *************************************
 * <!-- Get all custom attributes of an element like "data-*" -->
 *************************************
 */


var GET_CUSTOM_ATTRS = function (module, $, window, document) {
  if (window.GET_CUSTOM_ATTRS === null) return false;
  module.GET_CUSTOM_ATTRS = module.GET_CUSTOM_ATTRS || {};
  module.GET_CUSTOM_ATTRS.version = '0.0.1';
  module.GET_CUSTOM_ATTRS.documentReady = function ($) {
    $('[data-my-custom-datas]').each(function () {
      var $this = $(this);

      //Get all attributes of an element and push the new attributes like "data-*"
      var curAttrs = $this.attr(),
        customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-custom-field-') >= 0) {
          customPostData += '"' + i.replace('data-custom-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, '');
    });
  };
  module.components.documentReady.push(module.GET_CUSTOM_ATTRS.documentReady);
  return /*#__PURE__*/_createClass(function GET_CUSTOM_ATTRS() {
    _classCallCheck(this, GET_CUSTOM_ATTRS);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/loader.js



/* 
 *************************************
 * <!-- Loader -->
 *************************************
 */

var LOADER = function (module, $, window, document) {
  if (window.LOADER === null) return false;
  module.LOADER = module.LOADER || {};
  module.LOADER.version = '0.0.5';
  module.LOADER.documentReady = function ($) {
    // Disable devices scaling
    //-------------------------------------	
    document.addEventListener('touchstart', function (event) {
      if (event.touches.length > 1) {
        event.preventDefault();
      }
    });
    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      var now = new Date().getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // Loader Process
    //-------------------------------------	

    // Detect if video.load is successful or not 
    var videos = [];
    var videosTotal = 0;
    var videosLoaded = 0;
    $('.uix-video__slider > video').each(function () {
      videos.push($(this));
    });
    videosTotal = videos.length;
    console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded);

    // Loading progress event
    var loadedPercent = 0;
    var imgTotal = 0;
    var loadingAnim = function loadingAnim(per) {
      $('.uix-loader-progress > span').text($('.uix-loader-progress').data('txt').replace(/\{progress\}/g, per));
      TweenMax.to('.uix-loader-progress__line', 0.3, {
        width: per / 100.0 * window.innerWidth
      });
    };
    $('body').waitForImages().progress(function (loaded, count, success) {
      imgTotal = count;
      var per = parseInt(loaded / (count - (1 - videosTotal)) * 100);

      //
      if ($('img').length <= 1) {
        per = 100;
      }

      //
      if (isNaN(per)) per = 100;

      //
      loadedPercent = per;

      //animation classes for loader
      for (var i = 1; i < 10; i++) {
        if (per < i * 10) $('body').addClass('loaded' + i);
      }

      //loading animation
      loadingAnim(per);
    }).done(function () {
      //Event after loading is complete
      // Main scene
      console.log('loadedPercent: ' + loadedPercent + ', imageTotal: ' + imgTotal);
      mainObjLoader(loadedPercent, imgTotal);
    });

    /*
     * Main Object Loader
     *
     * @param  {Number} loadedPercent  - The percentage value after the page loads the image.
     * @param  {Number} imgTotal       - The total number of imags.
     * @return {Void}
     */
    function mainObjLoader(loadedPercent, imgTotal) {
      var remainedPercentComplete = 0;
      var loadedFun = function loadedFun() {
        //loading animation
        loadingAnim(100);

        //animation classes for loader
        $('body').addClass('loaded10');

        // Remove loader
        TweenMax.to('.uix-loader, .uix-loader-progress, .uix-loader-progress__line', 0.5, {
          css: {
            opacity: 0,
            display: 'none'
          }
        });

        //page animation when elements loaded
        //...
      };

      //
      if (loadedPercent < 100) {
        videos.forEach(function (element) {
          var _src = element.find('source:first').attr('src');
          if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = element.attr('src');
          var video = document.getElementById(element.attr('id')),
            videoURL = _src;
          video.addEventListener('loadedmetadata', function (e) {
            //Video has started loading successfully
            videosLoaded++;

            //get remained percent
            remainedPercentComplete = (1 - videosLoaded / videosTotal) * (100 - loadedPercent);

            //current percent
            var currentPercent = loadedPercent + (100 - loadedPercent - remainedPercentComplete);

            //loading animation
            loadingAnim(currentPercent);

            // All videos loaded
            if (currentPercent == 100) {
              loadedFun();
            }

            //debug
            console.log('remainedPercentComplete: ' + remainedPercentComplete + ', currentPercent: ' + currentPercent);
            console.log('videosTotal: ' + videosTotal + ', videosLoaded: ' + videosLoaded);
          }, false);
          video.src = videoURL;
        });
      } else {
        // All videos loaded
        if (remainedPercentComplete == 0) {
          loadedFun();
        }
      }
    }
  };
  module.components.documentReady.push(module.LOADER.documentReady);
  return /*#__PURE__*/_createClass(function LOADER() {
    _classCallCheck(this, LOADER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/mega-menu.js


/* 
 *************************************
 * <!-- Mega Menu -->
 *************************************
 */

var MEGA_MENU = function (module, $, window, document) {
  if (window.MEGA_MENU === null) return false;
  module.MEGA_MENU = module.MEGA_MENU || {};
  module.MEGA_MENU.version = '0.0.5';
  module.MEGA_MENU.pageLoaded = function () {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    // Using delay is for more accurate calculation
    setTimeout(function () {
      megaMenuInit(windowWidth);
    }, 500);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        megaMenuInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    // Initialize mega menu
    function megaMenuInit(w) {
      var $menuWrap = $('.uix-menu__container:not(.is-mobile)'),
        maxWidth = 1140,
        //The maximum width of the mega menu wrapper

        //This value is equal to the $nav-mega-li-w variable in the SCSS
        perDefaultW = 270; //Default width of each column

      //New XL container for Bootstrap 5.x
      if (w > 1430) maxWidth = 1278;

      //Full width container
      maxWidth = windowWidth - 15;

      // Remove the html tag for mega menu item
      $menuWrap.find('li.multi-column  > ul .multi-column-title').each(function () {
        var megaOldItem = $(this).html();
        if (megaOldItem != '') {
          $(this).html(megaOldItem.replace(/<[^>]+>/g, ''));
        }
      });
      if (w > 768) {
        $menuWrap.find('li.multi-column').each(function (index) {
          var $rootLi = $(this),
            colTotal = $rootLi.find('> ul > li').length,
            itemWidth = $rootLi.find('> ul > li').first().width(),
            $megaDiv = $rootLi.find('> ul.sub-menu');
          var megaPerWidth = null,
            rootLiLeft = null;

          // Get width or other style data of element when Not Visible (Display: None)
          var megaDivWidth = $megaDiv.width();

          // Add mega arrow
          if ($rootLi.find('.uix-menu__arrow-mega').length < 1) $rootLi.prepend('<span class="uix-menu__arrow-mega"></span>');

          // Detecting if the right or left of the div is touching the browser window edge.
          if (colTotal > 0) {
            rootLiLeft = UixCssProperty.getAbsoluteCoordinates($megaDiv[0]).left;

            //Determine the mega menu wrapper within document width, in order to limit the width of each column for mega menu
            if (maxWidth > w) maxWidth = w;
            if (megaDivWidth + 20 > maxWidth) {
              megaDivWidth = maxWidth;
              megaPerWidth = maxWidth / colTotal - 2.888;

              //Resetting the width of each column
              $megaDiv.find('> li').css({
                'width': megaPerWidth + 'px'
              });

              //Resetting the width of each <li> tag
              $megaDiv.find('> li ul li').css({
                'width': megaPerWidth + 'px'
              });
              if (!$('body').hasClass('rtl')) {
                $megaDiv.css({
                  'margin-left': -rootLiLeft + (w - megaDivWidth) / 2 + 'px'
                });
              } else {
                $megaDiv.css({
                  'margin-right': -rootLiLeft + (w - megaDivWidth) / 2 + 'px'
                });
              }
            } else {
              //Resetting the width of each column
              $megaDiv.find('> li').css({
                'width': perDefaultW + 'px'
              });

              //Resetting the width of each <li> tag
              $megaDiv.find('> li ul li').css({
                'width': perDefaultW + 'px'
              });
              var chkWidth = rootLiLeft + megaDivWidth;
              if (chkWidth > w) {
                if (!$('body').hasClass('rtl')) {
                  $megaDiv.css({
                    'margin-left': -(chkWidth - w) + 'px'
                  });
                } else {
                  $megaDiv.css({
                    'margin-right': -(chkWidth - w) + 'px'
                  });
                }

                //If the CSS sets the offset of ul::before
                //								const $megaDiv_offset = megaDivWidth/2 - 0;
                //								
                //								if ( ! $( 'body' ).hasClass( 'rtl' ) ) {
                //									$megaDiv.css( {
                //										'margin-left' : - ( chkWidth - w ) + $megaDiv_offset + 'px'
                //									} );
                //								} else {
                //									$megaDiv.css( {
                //										'margin-right' : - ( chkWidth - w ) + $megaDiv_offset + 'px'
                //									} );
                //								}	
              }
            }
          }
        });
      }
    }
  };

  module.components.pageLoaded.push(module.MEGA_MENU.pageLoaded);
  return /*#__PURE__*/_createClass(function MEGA_MENU() {
    _classCallCheck(this, MEGA_MENU);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/mobile-menu.js



/* 
 *************************************
 * <!-- Mobile Menu -->
 *************************************
 */

var MOBILE_MENU = function (module, $, window, document) {
  if (window.MOBILE_MENU === null) return false;
  module.MOBILE_MENU = module.MOBILE_MENU || {};
  module.MOBILE_MENU.version = '0.0.9';
  module.MOBILE_MENU.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //-------- Show Toolbar when viewing site for WordPress
    var $el = $('.admin-bar .uix-menu-mobile__toggle');
    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
        spyTop = 46;
      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();

    //-------- Mobile Menu
    var $toggle = $('.uix-menu-mobile__toggle'),
      $toggleBody = $('body');

    //-------- Add mobile menu to your website
    $('nav.uix-menu__container').clone().addClass('is-mobile').appendTo('body');
    //Wait until previous .appendTo() is complete
    $.when($('.uix-menu__container.is-mobile').length > 0).then(function () {
      $toggle.on('touchstart click', function (e) {
        e.preventDefault();

        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation();
        $(this).toggleClass('is-active');
        if ($(this).hasClass('is-active')) {
          //Add mobile brand
          var logoURL = $('.uix-brand--mobile img').attr('src');
          if ((0,esm_typeof/* default */.Z)(logoURL) !== ( true ? "undefined" : 0) && logoURL != '') {
            if (logoURL.indexOf('blank.gif') >= 0) $('.mobile-inner').css('margin-top', '-70px');
          }

          //Toggle effect
          $toggleBody.addClass('js-uix-menu-opened');
        } else {
          $toggleBody.removeClass('js-uix-menu-opened');
        }
      });

      //Mobile menu mask event
      $('.uix-menu-mobile__mask').on('click', function () {
        $toggle.removeClass('is-active');
        $toggleBody.removeClass('js-uix-menu-opened');
      });

      // Fires drop-menu event 
      var $drMenuLi = $('.uix-menu__container.is-mobile ul li');
      $drMenuLi.find('> a').on('click', function (e) {
        var arrowText = $(this).find('.uix-menu__arrow-mobile').text().replace(/(.).*\1/g, "$1"),
          $sub = $(this).next('ul');
        if ($sub.length > 0) {
          e.preventDefault();

          //Its value is not a boolean but a string
          var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;
          if (expanded) {
            //Hide other all sibling <ul> of the selected element
            var $e = $(this).parent('li').siblings().find('> a');
            $e.removeClass('is-opened').attr('aria-expanded', false);
            $e.parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $e.parent('li').removeClass('is-opened');
            $(this).addClass('is-opened').attr('aria-expanded', true);
            $(this).parent('li').find('.uix-menu__arrow-mobile').addClass('is-opened');
            $(this).parent('li').addClass('is-opened');
            TweenMax.to($e.next('ul'), 0.5, {
              height: 0
            });

            //to open
            // - temporarilty set height:auto
            // - tween from height:0
            TweenMax.set($sub, {
              height: 'auto'
            });
            TweenMax.from($sub, 0.5, {
              height: 0
            });
          } else {
            $(this).removeClass('is-opened').attr('aria-expanded', false);
            $(this).parent('li').find('.uix-menu__arrow-mobile').removeClass('is-opened');
            $(this).parent('li').removeClass('is-opened');

            //to close
            TweenMax.to($sub, 0.5, {
              height: 0
            });
          }
          return false;
        }
      });
      mobileMenuInit(windowWidth);
      function windowUpdate() {
        // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
        if (window.innerWidth != windowWidth) {
          // Update the window width for next time
          windowWidth = window.innerWidth;

          // Do stuff here
          $toggleBody.removeClass('js-uix-menu-opened');
          $toggle.removeClass('is-active');
          mobileMenuInit(windowWidth);
        }
      }

      // Add function to the window that should be resized
      var debounceFuncWindow = UixDebounce(windowUpdate, 50);
      window.removeEventListener('resize', debounceFuncWindow);
      window.addEventListener('resize', debounceFuncWindow);
    });

    /*
     * Initialize mobile menu
     *
     * @param  {Number} w                  - Returns width of browser viewport.
     * @return {Void}
     */
    function mobileMenuInit(w) {
      if (w <= 768) {
        $('.uix-menu__container.is-mobile .uix-menu > li').each(function () {
          if ($(this).find('ul').length > 0) {
            if ($(this).find('.uix-menu__arrow-mobile').length < 1) $(this).prepend('<em class="uix-menu__arrow-mobile"></em>');
            $(this).find('ul ul').addClass('sub-sub');
            $(this).find(' > a').attr('href', 'javascript:void(0);');
          }
        });
      }
    }
  };
  module.components.documentReady.push(module.MOBILE_MENU.documentReady);
  return /*#__PURE__*/_createClass(function MOBILE_MENU() {
    _classCallCheck(this, MOBILE_MENU);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/navigation.js



/* 
 *************************************
 * <!-- Navigation -->
 *************************************
 */

var NAVIGATION = function (module, $, window, document) {
  if (window.NAVIGATION === null) return false;
  module.NAVIGATION = module.NAVIGATION || {};
  module.NAVIGATION.version = '0.1.0';
  module.NAVIGATION.documentReady = function ($) {
    var ulForDesktop = '.uix-menu__container:not(.is-mobile) ul.uix-menu';

    //-------- Menu selected (if it exists "data-current" property in <ul>)
    var curMenuIndex = $(ulForDesktop).data('current');
    if ((0,esm_typeof/* default */.Z)(curMenuIndex) !== ( true ? "undefined" : 0)) {
      $(ulForDesktop + ' > li:eq(' + curMenuIndex + ')').addClass('is-active');
    }

    //-------- Menu Hover
    var mTop = 15;
    $(ulForDesktop + ' > li.multi-column > ul li ul').addClass('multi');
    $(ulForDesktop + ' > li:not(.multi-column) ul, .uix-menu__container:not(.is-mobile) li.multi-column > ul.sub-menu > li > ul, ' + ulForDesktop + ' li.multi-column > ul').css('margin-top', mTop + 'px');
    $(ulForDesktop + ' li').on('mouseenter', function () {
      TweenMax.set($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), {
        css: {
          opacity: 0,
          display: 'block',
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.3, {
            css: {
              opacity: 1,
              marginTop: 0
            },
            ease: Power2.easeOut
          });
        }
      });
    }).on('mouseleave', function () {
      TweenMax.to($(this).find(' > ul.sub-menu:not(.multi), .uix-menu__arrow-mega'), 0.3, {
        css: {
          opacity: 0,
          marginTop: mTop + 'px'
        },
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              display: 'none'
            }
          });
        }
      });
    });

    //-------- Add Sub-menu Arrow
    $(ulForDesktop + ' li').each(function () {
      if ($(this).find('ul').length > 0) {
        $(this).prepend('<span class="uix-menu__arrow"></span>');
      }
    });

    //-------- Sticky primary navigation
    var $el = $('.uix-menu__container:not(.is-mobile)');
    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
        spyTop = 220;
      if (scrolled >= spyTop) {
        $el.addClass('is-fixed');
      } else {
        $el.removeClass('is-fixed');
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };
  module.components.documentReady.push(module.NAVIGATION.documentReady);
  return /*#__PURE__*/_createClass(function NAVIGATION() {
    _classCallCheck(this, NAVIGATION);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/fn/UixParallax.js
/* 
 *************************************
 * Parallax Effect
 *
 * @param  {Number} speed       - The speed of movement between elements.
 * @param  {String} transition  - Transition time can simulate easing effect.
 * @param  {Object} bg            - Specify the background display. Default value: { enable: true, xPos: '50%' }
 * @return {Void}
 *
 *************************************
 */

(function ($) {
  'use strict';

  $.fn.UixParallax = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      speed: 0.25,
      offsetTop: 0,
      transition: 'all 0.4s cubic-bezier(0, 0, 0.34, 0.96) 0s',
      bg: {
        enable: true,
        xPos: '50%'
      }
    }, options);
    this.each(function () {
      var bgEff = settings.bg,
        $this = $(this),
        bgXpos = '50%',
        offsetTop = parseFloat(settings.offsetTop),
        speed = -parseFloat(settings.speed);
      if (bgEff) {
        bgEff = settings.bg.enable;
        bgXpos = settings.bg.xPos;
      }

      //Prohibit transition delay
      $this.css({
        'transition': 'none'
      });

      //Initialize the position of the background
      if (bgEff) {
        //background parallax
        TweenMax.set($this, {
          backgroundPosition: bgXpos + ' ' + (-$this[0].getBoundingClientRect().top * speed + -offsetTop) + 'px'
        });
      } else {
        //element parallax
        TweenMax.set($this, {
          y: 0
        });
      }
      function scrollUpdate() {
        var spyTop = $this[0].getBoundingClientRect().top;
        if (bgEff) {
          //background parallax
          TweenMax.set($this, {
            css: {
              'background-position': bgXpos + ' ' + (0 - (spyTop * speed + offsetTop)) + 'px',
              'transition': settings.transition
            }
          });
        } else {
          //element parallax
          TweenMax.set($this, {
            css: {
              'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - (spyTop * speed + offsetTop)) + ')',
              'transition': settings.transition
            }
          });
        }
      }

      // Add function to the element that should be used as the scrollable area.
      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);

      // Prevent calculation errors caused by unloaded completion
      if (document.readyState != 'loading') {
        throttleFunc();
      } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', throttleFunc);
      } else {
        document.attachEvent('onreadystatechange', function () {
          if (document.readyState != 'loading') throttleFunc();
        });
      }
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/set-background.js



/* 
 *************************************
 * <!-- Specify a background image -->
 *************************************
 */


var SET_BG = function (module, $, window, document) {
  if (window.SET_BG === null) return false;
  module.SET_BG = module.SET_BG || {};
  module.SET_BG.version = '0.0.8';
  module.SET_BG.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //  Initialize
    setBGInit();
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        setBGInit();
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize background using "data-bg" attribute.
     *
     * @return {Void}
     */
    function setBGInit() {
      $('[data-bg]').each(function () {
        var $this = $(this);
        var config = $this.data('bg');
        if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0)) {
          config = {
            "src": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
            "position": "top left",
            "size": "cover",
            "repeat": "no-repeat",
            "offsetTop": 0,
            "fill": false,
            "parallax": 0,
            "transition": "none 0s ease 0s",
            "move": false // {"dir":"left","duration":"10s","easing":"linear","loop":true}
          };
        }

        if (config) {
          var dataImg = config.src,
            dataPos = config.position,
            dataSize = config.size,
            dataRepeat = config.repeat,
            dataEasing = config.transition,
            dataOffsetTop = config.offsetTop,
            dataParallax = config.parallax,
            dataMove = config.move;
          if ((0,esm_typeof/* default */.Z)(dataPos) === ( true ? "undefined" : 0)) dataPos = 'top left';
          if ((0,esm_typeof/* default */.Z)(dataSize) === ( true ? "undefined" : 0)) dataSize = 'cover';
          if ((0,esm_typeof/* default */.Z)(dataRepeat) === ( true ? "undefined" : 0)) dataRepeat = 'no-repeat';
          if ((0,esm_typeof/* default */.Z)(dataOffsetTop) === ( true ? "undefined" : 0)) dataOffsetTop = 0;
          if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) dataEasing = 'none 0s ease 0s';
          if ((0,esm_typeof/* default */.Z)(dataMove) === ( true ? "undefined" : 0)) dataMove = false;

          //Using parallax
          if (dataParallax && (0,esm_typeof/* default */.Z)(dataParallax) != ( true ? "undefined" : 0) && dataParallax != 0) {
            dataPos = dataPos.replace('top', '50%');
          }

          //background animation
          var moveAnim = 'none',
            moveAnimLoop = 'infinite',
            moveEasing = 'linear',
            moveKeyframesTop = '@keyframes js-uix-cssanim--move-t{from{background-position:0 0;}to{background-position:0 -19999px;}',
            moveKeyframesBottom = '@keyframes js-uix-cssanim--move-b{from{background-position:0 0;}to{background-position:0 19999px;}',
            moveKeyframesLeft = '@keyframes js-uix-cssanim--move-l{from{background-position:0 0;}to{background-position:-19999px 0;}',
            moveKeyframesRight = '@keyframes js-uix-cssanim--move-r{from{background-position:0 0;}to{background-position:19999px 0;}';
          if (dataMove && Object.prototype.toString.call(dataMove) == '[object Object]') {
            if (!dataMove.loop) moveAnimLoop = '1 forwards';
            dataPos = '0 0';
            switch (dataMove.dir) {
              case 'top':
                moveAnim = 'js-uix-cssanim--move-t ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
              case 'bottom':
                moveAnim = 'js-uix-cssanim--move-b ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
              case 'left':
                moveAnim = 'js-uix-cssanim--move-l ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
              case 'right':
                moveAnim = 'js-uix-cssanim--move-r ' + parseInt(dataMove.speed) + 's ' + moveEasing + ' ' + moveAnimLoop;
                break;
            }

            //  CSS3 animation keyframe attributes inline
            if ($('#js-uix-cssanim--move-t').length == 0) {
              $('<style id="js-uix-cssanim--move-t">').text(moveKeyframesTop).appendTo('head');
            }
            if ($('#js-uix-cssanim--move-b').length == 0) {
              $('<style id="js-uix-cssanim--move-b">').text(moveKeyframesBottom).appendTo('head');
            }
            if ($('#js-uix-cssanim--move-l').length == 0) {
              $('<style id="js-uix-cssanim--move-l">').text(moveKeyframesLeft).appendTo('head');
            }
            if ($('#js-uix-cssanim--move-r').length == 0) {
              $('<style id="js-uix-cssanim--move-r">').text(moveKeyframesRight).appendTo('head');
            }
          }

          //-----
          if ((0,esm_typeof/* default */.Z)(dataImg) != ( true ? "undefined" : 0) && dataImg != '') {
            if (config.fill) {
              //Show Image Under Text
              if (Modernizr.cssanimations) {
                $this.css({
                  'background': 'url(' + dataImg + ') ' + dataRepeat + '',
                  'background-size': dataSize,
                  '-webkit-background-clip': 'text',
                  '-webkit-text-fill-color': 'transparent',
                  'animation': moveAnim
                });
              }
            } else {
              $this.css({
                'background-image': 'url(' + dataImg + ')',
                'background-position': dataPos,
                'background-size': dataSize,
                'background-repeat': dataRepeat,
                'animation': moveAnim
              });
            }

            //Using parallax
            if (dataParallax && (0,esm_typeof/* default */.Z)(dataParallax) != ( true ? "undefined" : 0) && dataParallax != 0) {
              $this.UixParallax({
                'speed': dataParallax,
                'transition': dataEasing,
                'offsetTop': dataOffsetTop,
                'bg': {
                  enable: true,
                  xPos: '50%'
                }
              });
            }
          }
        }
      });
    }
  };
  module.components.documentReady.push(module.SET_BG.documentReady);
  return /*#__PURE__*/_createClass(function SET_BG() {
    _classCallCheck(this, SET_BG);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_global/js/modules/videos.js



/* 
 *************************************
 * <!-- Videos -->
 *************************************
 */

var VIDEOS = function (module, $, window, document) {
  if (window.VIDEOS === null) return false;
  module.VIDEOS = module.VIDEOS || {};
  module.VIDEOS.version = '0.1.3';
  module.VIDEOS.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    /* 
     ---------------------------
     Video Embed
     ---------------------------
     */
    $('.uix-video').each(function () {
      var $this = $(this);
      var curVideoID = $this.find('video').attr('id'),
        coverPlayBtnID = 'videocover-' + curVideoID,
        videoWrapperW = $this.closest('[data-embed-video-wrapper]').width();
      var dataAuto = $this.data('embed-video-autoplay'),
        dataLoop = $this.data('embed-video-loop'),
        dataControls = $this.data('embed-video-controls'),
        dataW = $this.data('embed-video-width'),
        dataH = $this.data('embed-video-height');

      //Push a new ID to video
      //Solve the problem that ajax asynchronous loading does not play
      $this.find('.video-js').attr('id', curVideoID);
      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
        dataAuto = true;
      }
      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
        dataLoop = true;
      }
      if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
        dataControls = false;
      }
      if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
        dataW = videoWrapperW;
      }
      if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
        dataH = videoWrapperW / 1.77777777777778;
      }

      //Display cover and play buttons when some mobile device browsers cannot automatically play video
      if ($('#' + coverPlayBtnID).length == 0) {
        $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
        var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
        $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
          e.preventDefault();
          myPlayer.play();
          $('#' + coverPlayBtnID).hide();
        });

        //Prevent some devices from automatically playing video and trigger with buttons
        if (!dataAuto || browser.isAndroid) {
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
        }
      }

      /* ---------  HTML5 video autoplay on mobile revisited  */
      if (windowWidth <= 768) {
        $this.find('.video-js').attr({
          'playsinline': 'true'
        });
      }
      var myPlayer = videojs(curVideoID, {
        width: dataW,
        height: dataH,
        loop: dataLoop,
        autoplay: dataAuto
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
            curH = obj.videoHeight(),
            newW = curW,
            newH = curH;
          newW = videoWrapperW;

          //Scaled/Proportional Content 
          newH = curH * (newW / curW);
          if (!isNaN(newW) && !isNaN(newH)) {
            obj.height(newH);
            obj.width(newW);
          }

          //Show this video wrapper
          $this.css('visibility', 'visible');

          //Hide loading effect
          $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
        };
        initVideo(this);

        /* ---------  Video initialize */
        this.on('loadedmetadata', function () {
          initVideo(this);
        });

        /* ---------  Set, tell the player it's in fullscreen  */
        if (dataAuto) {
          this.muted(true); //Fix an error of Video auto play is not working in browser
          this.play();
        }

        /* ---------  Disable control bar play button click */
        if (!dataControls) {
          this.controls(false);
        }

        /* ---------  Determine if the video is auto played from mobile devices  */
        var autoPlayOK = false;
        this.on('timeupdate', function () {
          var duration = this.duration();
          if (duration > 0) {
            autoPlayOK = true;
            if (this.currentTime() > 0) {
              autoPlayOK = true;
              this.off('timeupdate');

              //Hide cover and play buttons when the video automatically played
              $('#' + coverPlayBtnID).hide();
            }
          }
        });
      });
    });

    /* 
     ---------------------------
     Video Popup Interaction
     ---------------------------
     */
    var modalDialogTrigger = '[data-video-win]';

    //Add video container
    $(modalDialogTrigger).each(function () {
      var $this = $(this);
      var videoSrcIfm = '',
        videoSrcMp4 = $this.data('video-mp4'),
        videoSrcWebm = $this.data('video-webm'),
        videoSrcOgv = $this.data('video-ogv'),
        videoPoster = $this.data('video-poster'),
        videoContainerMid = $this.data('modal-id'),
        videoContainerVid = videoContainerMid + '--videopush';
      if ((0,esm_typeof/* default */.Z)(videoSrcMp4) === ( true ? "undefined" : 0)) {
        videoSrcMp4 = '';
      }
      if ((0,esm_typeof/* default */.Z)(videoSrcWebm) === ( true ? "undefined" : 0)) {
        videoSrcWebm = '';
      }
      if ((0,esm_typeof/* default */.Z)(videoSrcOgv) === ( true ? "undefined" : 0)) {
        videoSrcOgv = '';
      }
      if ($this.find('[data-video-iframe]').length > 0) {
        videoSrcIfm = $this.find('[data-video-iframe]').html();
      }

      //Add modal dialog
      if ($('#' + videoContainerMid).length == 0) {
        var v = '',
          vmp4 = '',
          vwebm = '',
          vogv = '';
        if (videoSrcMp4 != '') {
          vmp4 = '<source src="' + videoSrcMp4 + '" type="video/mp4">';
        }
        if (videoSrcWebm != '') {
          vwebm = '<source src="' + videoSrcWebm + '" type="video/webm">';
        }
        if (videoSrcOgv != '') {
          vogv = '<source src="' + videoSrcOgv + '" type="video/ogv">';
        }
        v += '<div class="uix-modal-box is-fullscreen is-video" role="dialog" tabindex="-1" aria-hidden="true" id="' + videoContainerMid + '">';
        v += '<button type="button" class="uix-modal-box__close" data-modal-close-trigger="true"></button>';
        v += '<div class="uix-modal-box__content" role="document">';
        v += '<div class="uix-modal-box__video-waiting"></div><div class="uix-modal-box__video-container" data-video-player-init="0">';
        if ($this.find('[data-video-iframe]').length > 0 && videoSrcIfm != '') {
          //If iframe
          v += '<div id="' + videoContainerVid + '" class="ratio ratio-16x9">';
          v += videoSrcIfm;
          v += '</div>';
        } else {
          //If local video
          v += '<video id="' + videoContainerVid + '" class="video-js vjs-default-skin" controls poster="' + videoPoster + '">';
          v += vmp4 + vwebm + vogv;
          v += '</video>';
        }
        v += '</div>';
        v += '</div>';
        v += '</div>';

        //Wait until previous .append() is complete
        $(v).appendTo('body');
      }
    });

    //Check out: http://docs.videojs.com/tutorial-player-workflows.html
    $(document).off('click.VIDEOS').on('click.VIDEOS', modalDialogTrigger, function () {
      var vid = $(this).data('modal-id') + '--videopush',
        newMaxW = windowWidth - 80,
        newMaxH = windowHeight - 80,
        $vContainer = $('#' + vid).closest('.uix-modal-box__video-container'),
        $vLoader = $vContainer.prev('.uix-modal-box__video-waiting'),
        myPlayerInit = $vContainer.data('video-player-init');
      var $ifm = false;

      //----- Hidden/Display the wrapper of video
      var displayVC = function displayVC() {
        TweenMax.set($vContainer, {
          alpha: 1
        });
        $vLoader.removeClass('is-active');
      };
      var hiddenVC = function hiddenVC() {
        TweenMax.set($vContainer, {
          alpha: 0
        });
        $vLoader.addClass('is-active');
      };

      //----- Embed iframe
      if ($('#' + vid).find('iframe').length > 0) {
        $ifm = $('#' + vid).find('iframe');
      } else {
        hiddenVC();
      }
      if ($ifm && (0,esm_typeof/* default */.Z)($ifm) === 'object') {
        if ($ifm.length > 0) {
          var curW = $ifm.width(),
            curH = $ifm.height(),
            newW = curW,
            newH = curH;
          if (curH > newMaxH) {
            newH = newMaxH;

            //Scaled/Proportional Content 
            newW = curW * (newH / curH);
          }
          if (newW > newMaxW) {
            newW = newMaxW;

            //Scaled/Proportional Content 
            newH = curH * (newW / curW);
          }
          $ifm.css({
            'left': (newMaxW - newW) / 2 + 'px',
            'top': (newMaxH - newH) / 2 + 'px',
            'height': newH + 'px',
            'width': newW + 'px'
          });
          if (windowWidth <= 768) {
            $ifm.css({
              'top': 0
            }).parent('.ratio').css({
              'top': (newMaxH - newH) / 2 + 'px'
            });
          }
        }
        return false;
      }

      //----- HTML5 video autoplay on mobile revisited
      if (windowWidth <= 768) {
        $('#' + vid).attr({
          'playsinline': 'true'
        });
      }

      //----- Embed local video
      var myPlayer = videojs(vid, {
        width: 1,
        height: 1,
        autoplay: true,
        loop: true
      }, function onPlayerReady() {
        var initVideo = function initVideo(obj) {
          //Get Video Dimensions
          var curW = obj.videoWidth(),
            curH = obj.videoHeight(),
            newW = curW,
            newH = curH;

          //Resise modal
          if (curH > newMaxH) {
            newH = newMaxH;

            //Scaled/Proportional Content 
            newW = curW * (newH / curH);
          }
          if (newW > newMaxW) {
            newW = newMaxW;

            //Scaled/Proportional Content 
            newH = curH * (newW / curW);
          }
          obj.height(newH);
          obj.width(newW);

          //In order to allow CSS to support video centering
          $vContainer.find(' > div.video-js').css({
            'width': newW + 'px'
          });

          //Vertically center the video area
          var mt = parseFloat(windowHeight - newH) / 2 - 50;
          $vContainer.css({
            'transform': 'translateY(' + mt + 'px)'
          });

          //Display the wrapper of video
          displayVC();
        };
        initVideo(this);

        /* ---------  Video Modal initialize */
        this.on('loadedmetadata', function () {
          initVideo(this);

          //If a player instance has already been created for this variable.
          $vContainer.data('video-player-init', 1);
        });

        /* ---------  Set, tell the player it's in fullscreen  */
        //this.exitFullscreen();
        //this.requestFullscreen();
        this.play();

        /* ---------  Disable control bar play button click */
        //this.controls( false );

        /* ---------  Display video playback progress  */
        this.on('timeupdate', function () {
          var duration = this.duration(),
            progressAmount = '0%';
          if (duration > 0) {
            progressAmount = this.currentTime() / duration * 100 + "%";
          }

          //console.log( progressAmount );
        });

        /* ---------  Callback for when a video has ended */
        this.on('ended', function () {
          //console.log( 'video is done!' );
        });
      });

      /* ---------  Display the wrapper of video  */
      if (myPlayerInit === 1) {
        displayVC();
      }

      /* ---------  Close the modal  */
      $(document).off('click.VIDEOS_CLOSE').on('click.VIDEOS_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
        myPlayer.ready(function () {
          this.pause();
        });
      });
    });
  };
  module.components.documentReady.push(module.VIDEOS.documentReady);
  return /*#__PURE__*/_createClass(function VIDEOS() {
    _classCallCheck(this, VIDEOS);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_main/js/index.js


/* 
 *************************************
 * <!-- Theme Scripts  -->
 *************************************
 */



var MAIN = function (module, $, window, document) {
  if (window.MAIN === null) return false;
  module.MAIN = module.MAIN || {};
  module.MAIN.version = '0.0.1';
  module.MAIN.documentReady = function ($) {

    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };
  module.MAIN.pageLoaded = function () {

    /* 
     ---------------------------
     Function Here
     ---------------------------
     */
    //your code here...
  };
  module.components.documentReady.push(module.MAIN.documentReady);
  module.components.pageLoaded.push(module.MAIN.pageLoaded);
  return /*#__PURE__*/_createClass(function MAIN() {
    _classCallCheck(this, MAIN);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/accordion-img/js/index.js



/* 
 *************************************
 * <!-- Accordion Background Images -->
 *************************************
 */


var ACCORDION_BG = function (module, $, window, document) {
  if (window.ACCORDION_BG === null) return false;
  module.ACCORDION_BG = module.ACCORDION_BG || {};
  module.ACCORDION_BG.version = '0.0.7';
  module.ACCORDION_BG.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    if (windowWidth <= 768) return false;
    $('.uix-accordion-img').each(function () {
      var $this = $(this);
      var aEvent = $this.data('event'),
        outReset = $this.data('out-reset'),
        activeIndex = $this.data('actived-item'),
        offsetVal = $this.data('offset'),
        dir = $this.data('direction'),
        closeBtn = $this.data('close-btn'),
        $li = $this.find('> ul').children('li'),
        total = $li.length;
      if ((0,esm_typeof/* default */.Z)(activeIndex) === ( true ? "undefined" : 0)) {
        activeIndex = false;
      }
      if ((0,esm_typeof/* default */.Z)(aEvent) === ( true ? "undefined" : 0)) {
        aEvent = 'click';
      }
      if ((0,esm_typeof/* default */.Z)(outReset) === ( true ? "undefined" : 0)) {
        outReset = true;
      }
      if ((0,esm_typeof/* default */.Z)(offsetVal) === ( true ? "undefined" : 0)) {
        offsetVal = '60%';
      }

      //Initialize the width or height of each item
      itemInit();
      $li.on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation();

        //Apply click method to outer div but not inner div
        if (e.target.className == 'uix-accordion-img__content__info' || e.target.className == 'uix-accordion-img__content') {
          if ($(this).hasClass('is-active')) {
            $(this).addClass('is-active');
          } else {
            $li.addClass('active-sub');
            $(this).addClass('is-active');
            $(this).siblings().removeClass('is-active');
            if (dir == 'verticle') {
              $li.css('height', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
              $(this).css('height', offsetVal);
            } else {
              $li.css('width', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
              $(this).css('width', offsetVal);
            }
          }
        }
      });
      if (outReset) {
        $this.on('mouseleave', function (e) {
          itemInit();
        });
      }
      if ((0,esm_typeof/* default */.Z)(closeBtn) != ( true ? "undefined" : 0) && closeBtn != false && closeBtn != '') {
        $(closeBtn).off('click').on('click', function (e) {
          e.preventDefault();
          itemInit();
        });
      }

      /*
       * Active the target item
       *
          * @param  {Number} index     - The index value of the item to be activated.
       * @return {Void}
       */
      function itemActiveItem(index) {
        if (index >= 0) {
          if (dir == 'verticle') {
            $li.css('height', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
            $li.eq(index).css('height', offsetVal).addClass('is-active');
          } else {
            $li.css('width', (100 - parseFloat(offsetVal)) / (total - 1) + '%');
            $li.eq(index).css('width', offsetVal).addClass('is-active');
          }
        }
      }
      itemActiveItem(parseFloat(activeIndex));

      /*
       * Initialize the width or height of each item
       *
       * @return {Void}
       */
      function itemInit() {
        if (dir == 'verticle') {
          $li.removeClass('is-active active-sub').css('height', 100 / total + '%');
        } else {
          $li.removeClass('is-active active-sub').css('width', 100 / total + '%');
        }
      }
    });
  };
  module.components.documentReady.push(module.ACCORDION_BG.documentReady);
  return /*#__PURE__*/_createClass(function ACCORDION_BG() {
    _classCallCheck(this, ACCORDION_BG);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/accordion/js/index.js



/* 
 *************************************
 * <!-- Accordion -->
 *************************************
 */


var ACCORDION = function (module, $, window, document) {
  if (window.ACCORDION === null) return false;
  module.ACCORDION = module.ACCORDION || {};
  module.ACCORDION.version = '0.0.3';
  module.ACCORDION.documentReady = function ($) {
    $('.uix-accordion').each(function () {
      var $this = $(this);
      var $li = $this.children('dl'),
        $titlebox = $this.find('dt');
      var aEvent = $this.data('event'),
        firstShow = $this.data('first-show');
      var openItem = function openItem(obj) {
        //to open
        // - temporarilty set height:auto
        // - tween from height:0
        TweenMax.set(obj, {
          height: 'auto'
        });
        TweenMax.from(obj, 0.5, {
          height: 0
        });
      };
      if ((0,esm_typeof/* default */.Z)(aEvent) === ( true ? "undefined" : 0)) {
        aEvent = 'click';
      }
      if ((0,esm_typeof/* default */.Z)(firstShow) === ( true ? "undefined" : 0)) {
        firstShow = false;
      }
      if (firstShow) {
        $li.first().addClass('is-active').attr('aria-expanded', true);
        openItem($li.first().find('dd'));
      }
      $li.off(aEvent).on(aEvent, function (e) {
        //Prevents further propagation of the current event in the capturing and bubbling phases.
        e.stopPropagation();

        //Its value is not a boolean but a string
        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true,
          $content = $(this).find('dd');
        if (expanded) {
          //Hide other all sibling <dt> of the selected element
          var $e = $(this).siblings();
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.find('dd'), 0.5, {
            height: 0
          });

          //to open
          openItem($content);
        } else {
          if (e.type == 'click') {
            $(this).removeClass('is-active').attr('aria-expanded', false);

            //to close
            TweenMax.to($content, 0.5, {
              height: 0
            });
          }
        }
      });
    });
  };
  module.components.documentReady.push(module.ACCORDION.documentReady);
  return /*#__PURE__*/_createClass(function ACCORDION() {
    _classCallCheck(this, ACCORDION);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/advanced-slider/js/basic.js



/* 
 *************************************
 * <!-- Advanced Slider (Basic) -->
 *************************************
 */


var ADVANCED_SLIDER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER === null) return false;
  module.ADVANCED_SLIDER = module.ADVANCED_SLIDER || {};
  module.ADVANCED_SLIDER.version = '0.2.7';
  module.ADVANCED_SLIDER.pageLoaded = function () {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var animDelay = 0;
    var $sliderWrapper = $('.uix-advanced-slider');
    sliderInit(false);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        sliderInit(true);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */
    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider__item'),
          $first = $items.first(),
          activated = $this.data('activated');
        var nativeItemW, nativeItemH;
        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
            dataControlsArrows = $this.data('controls-arrows'),
            dataDraggable = $this.data('draggable'),
            dataDraggableCursor = $this.data('draggable-cursor'),
            dataCountTotal = $this.data('count-total'),
            dataCountCur = $this.data('count-now');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-advanced-slider__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current';

          //Autoplay parameters
          var dataAuto = $this.data('auto'),
            dataTiming = $this.data('timing'),
            dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;

          //Autoplay times
          var playTimes;
          //A function called "timer" once every second (like a digital watch).
          $this[0].animatedSlides;

          //Get the duration of the animation from CSS/SCSS
          //-------------------------------------	
          animDelay = UixCssProperty.getTransitionDuration($first[0]);

          //Initialize the properties of each Item
          //-------------------------------------	
          $items.each(function (index) {
            var _item = $(this);
            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          });

          //Initialize the first item container
          //-------------------------------------		
          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay);
          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $first.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
              nativeItemW = this.videoWidth;
              nativeItemH = this.videoHeight;

              //Initialize all the items to the stage
              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $first.find('img').attr('src');
            if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
              var img = new Image();
              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height;

                //Initialize all the items to the stage
                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur);
              };
              img.src = imgURL;
            }
          }

          //Autoplay Slider
          //-------------------------------------		
          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };
              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              };

              // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid
              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave);

              // To determine if it is a touch screen.
              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          }

          //Prevents front-end javascripts that are activated with AJAX to repeat loading.
          $this.data('activated', 1);
        } //endif activated
      });
    }

    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */
    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider__item'),
        total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;
        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }

    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
    * @return {Void}
    */
    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID) {
      var $this = slider,
        $items = $this.find('.uix-advanced-slider__item'),
        $first = $items.first(),
        itemsTotal = $items.length;

      //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.
      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider__arrows--prev"></a><a href="#" class="uix-advanced-slider__arrows--next"></a></div>');
      }

      //Add identifiers for the first and last items
      $items.last().addClass('last');
      $items.first().addClass('first');

      //Prevent bubbling
      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      }

      // Fires local videos asynchronously with slider switch.
      //-------------------------------------
      normalSliderVideoInit($items, false);

      //Pagination dots 
      //-------------------------------------	
      var _dot = '',
        _dotActive = '';
      _dot += '<ul>';
      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }
      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault();

        //Prevent buttons' events from firing multiple times
        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        });

        //
        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';
          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }
          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop);

          //Pause the auto play event
          clearInterval($this[0].animatedSlides);
        }
      });

      //Next/Prev buttons
      //-------------------------------------		
      var _prev = $(arrowsID).find('.uix-advanced-slider__arrows--prev'),
        _next = $(arrowsID).find('.uix-advanced-slider__arrows--next');
      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');
      if (!loop) {
        _prev.addClass('is-disabled');
      }
      _prev.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        prevMove();
      });
      _next.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        nextMove();
      });
      function prevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;
        _prev.attr('aria-disabled', 'true');
        _prev.delay(animDelay).queue(function (next) {
          _prev.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_prev.hasClass('is-disabled')) return false;

        //
        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }
      function nextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;
        _next.attr('aria-disabled', 'true');
        _next.delay(animDelay).queue(function (next) {
          _next.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_next.hasClass('is-disabled')) return false;

        //
        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      //Added touch method to mobile device and desktop
      //-------------------------------------	
      var $dragTrigger = $this.find('.uix-advanced-slider__inner');
      var mouseX, mouseY;
      var isMoving = false;

      //Avoid images causing mouseup to fail
      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      });

      //Make the cursor a move icon when a user hovers over an item
      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor);

      //draggable for touch devices
      if (Modernizr.touchevents) draggable = true;
      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd);

        //
        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }
      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;
        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }
      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;
        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        }

        //--- left
        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        }

        //--- right
        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        }

        //--- up
        if (offsetY >= 50) {}

        //--- down
        if (offsetY <= -50) {}
      }
      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess);

        //restore move action status
        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }

    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */
    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider__item'),
        total = $items.length;

      //Prevent bubbling
      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      }

      //Transition Interception
      //-------------------------------------
      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
      }

      // To determine if it is a touch screen.
      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0;

        //Prevent bubbling
        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider__arrows--prev').addClass('is-disabled');
          }

          //last item
          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider__arrows--next').addClass('is-disabled');
          }
        }
      }

      // call the current item
      //-------------------------------------
      var $current = $items.eq(elementIndex);

      //Determine the direction and add class to switching direction indicator.
      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next';

      //Add transition class to Controls Pagination
      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave');

      //Add transition class to each item
      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave');

      //Display counter
      //-------------------------------------
      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1);

      // Fires local videos asynchronously with slider switch.
      //-------------------------------------
      normalSliderVideoInit($items, false);
      normalSliderVideoInit($current, true);

      //Reset the default height of item
      //-------------------------------------	
      itemDefaultInit(slider, $current);
    }

    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */
    function itemDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          slider.css('height', this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth) + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');
        if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
          var img = new Image();
          img.onload = function () {
            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };
          img.src = imgURL;
        }
      }
    }

    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */
    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
          curVideoID = $this.find('video').attr('id') + '-slider-videopush',
          coverPlayBtnID = 'videocover-' + curVideoID,
          $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
          dataAuto = $this.data('embed-video-autoplay'),
          dataLoop = $this.data('embed-video-loop'),
          dataW = $this.data('embed-video-width'),
          dataH = $this.data('embed-video-height');

        //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play
        $this.find('.video-js').attr('id', curVideoID);
        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }
        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }
        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        }

        //Display cover and play buttons when some mobile device browsers cannot automatically play video
        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        }

        //Add replay button to video 
        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        }

        //HTML5 video autoplay on mobile revisited
        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }
        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH;
            newW = videoWrapperW;

            //Scaled/Proportional Content 
            newH = curH * (newW / curW);
            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            }

            //Show this video wrapper
            $this.css('visibility', 'visible');

            //Hide loading effect
            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };

          /* ---------  Video initialize */
          this.on('loadedmetadata', function () {
            initVideo(this);
          });

          /* ---------  Display the play button  */
          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });

          /* ---------  Set, tell the player it's in fullscreen  */
          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true);

            //Prevent autoplay error: Uncaught (in promise) DOMException
            var promise = this.play();
            if (promise !== undefined) {
              promise.then(function () {
                // Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }

          /* ---------  Disable control bar play button click */
          if (!dataControls) {
            this.controls(false);
          }

          /* ---------  Determine if the video is auto played from mobile devices  */
          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();
            if (duration > 0) {
              autoPlayOK = true;
              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate');

                //Hide cover and play buttons when the video automatically played
                $('#' + coverPlayBtnID).hide();
              }
            }
          });

          /* ---------  Pause the video when it is not current slider  */
          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);
            if (dataAuto) {
              this.currentTime(0);

              //Prevent autoplay error: Uncaught (in promise) DOMException
              var _promise = this.play();
              if (_promise !== undefined) {
                _promise.then(function () {
                  // Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              }

              //Hidden replay button
              $replayBtn.hide();

              //Should the video go to the beginning when it ends
              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };
  module.components.pageLoaded.push(module.ADVANCED_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function ADVANCED_SLIDER() {
    _classCallCheck(this, ADVANCED_SLIDER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/GSAP/esm/TweenLite.js
var esm_TweenLite = __webpack_require__(696);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/PixiPlugin.js
/*!
 * VERSION: 0.3.0
 * DATE: 2019-05-13
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * PixiPlugin is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 */
/* eslint-disable */


var _numExp = /(\d|\.)+/g,
  _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
  _colorLookup = {
    aqua: [0, 255, 255],
    lime: [0, 255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, 255],
    navy: [0, 0, 128],
    white: [255, 255, 255],
    fuchsia: [255, 0, 255],
    olive: [128, 128, 0],
    yellow: [255, 255, 0],
    orange: [255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [255, 0, 0],
    pink: [255, 192, 203],
    cyan: [0, 255, 255],
    transparent: [255, 255, 255, 0]
  },
  _hue = function _hue(h, m1, m2) {
    h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
  },
  /**
   * @private Parses a color (like #9F0, #FF9900, rgb(255,51,153) or hsl(108, 50%, 10%)) into an array with 3 elements for red, green, and blue or if "format" parameter is "hsl", it will populate the array with hue, saturation, and lightness values. Or if "format" is "number", it'll return a number like 0xFF0000 instead of an array. If a relative value is found in an hsl() or hsla() string, it will preserve those relative prefixes and all the values in the array will be strings instead of numbers (in all other cases it will be populated with numbers).
   * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
   * @param {(string)} format If "hsl", an hsl() or hsla() value will be returned instead of rgb() or rgba(). Or if "number", then a numeric value will be returned, like 0xFF0000. Default is rgb.
   * @return {(array|number)} An array containing red, green, and blue (and optionally alpha) in that order, or if the format parameter was "hsl", the array will contain hue, saturation and lightness (and optionally alpha) in that order. Or if "format" is defined as "number", it'll return a number like 0xFF0000. Always numbers unless there's a relative prefix found in an hsl() or hsla() string and "format" is "hsl".
   */
  _parseColor = function _parseColor(v, format) {
    var toHSL = format === "hsl",
      a,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;
    if (!v) {
      a = _colorLookup.black;
    } else if (typeof v === "number") {
      a = [v >> 16, v >> 8 & 255, v & 255];
    } else {
      if (v.charAt(v.length - 1) === ",") {
        //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
        v = v.substr(0, v.length - 1);
      }
      if (_colorLookup[v]) {
        a = _colorLookup[v];
      } else if (v.charAt(0) === "#") {
        if (v.length === 4) {
          //for shorthand like #9F0
          r = v.charAt(1);
          g = v.charAt(2);
          b = v.charAt(3);
          v = "#" + r + r + g + g + b + b;
        }
        v = parseInt(v.substr(1), 16);
        a = [v >> 16, v >> 8 & 255, v & 255];
      } else if (v.substr(0, 3) === "hsl") {
        a = wasHSL = v.match(_numExp);
        if (!toHSL) {
          h = Number(a[0]) % 360 / 360;
          s = Number(a[1]) / 100;
          l = Number(a[2]) / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          if (a.length > 3) {
            a[3] = Number(v[3]);
          }
          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (v.indexOf("=") !== -1) {
          //if relative values are found, just return the raw strings with the relative prefixes in place.
          return v.match(_relNumExp);
        }
      } else {
        a = v.match(_numExp) || _colorLookup.transparent;
      }
      a[0] = Number(a[0]);
      a[1] = Number(a[1]);
      a[2] = Number(a[2]);
      if (a.length > 3) {
        a[3] = Number(a[3]);
      }
    }
    if (toHSL && !wasHSL) {
      r = a[0] / 255;
      g = a[1] / 255;
      b = a[2] / 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = h + 0.5 | 0;
      a[1] = s * 100 + 0.5 | 0;
      a[2] = l * 100 + 0.5 | 0;
    }
    return format === "number" ? a[0] << 16 | a[1] << 8 | a[2] : a;
  },
  _formatColors = function _formatColors(s, toHSL) {
    var colors = (s + "").match(_colorExp) || [],
      charIndex = 0,
      parsed = "",
      i,
      color,
      temp;
    if (!colors.length) {
      return s;
    }
    for (i = 0; i < colors.length; i++) {
      color = colors[i];
      temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
      charIndex += temp.length + color.length;
      color = _parseColor(color, toHSL ? "hsl" : "rgb");
      if (color.length === 3) {
        color.push(1);
      }
      parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
    }
    return parsed + s.substr(charIndex);
  },
  _colorStringFilter,
  PixiPlugin_TweenLite = (esm_TweenLite/* _gsScope.GreenSockGlobals */.ML.GreenSockGlobals || esm_TweenLite/* _gsScope */.ML).TweenLite,
  _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
  //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

  _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
  _lumR = 0.212671,
  _lumG = 0.715160,
  _lumB = 0.072169,
  _applyMatrix = function _applyMatrix(m, m2) {
    var temp = [],
      i = 0,
      z = 0,
      y,
      x;
    for (y = 0; y < 4; y++) {
      for (x = 0; x < 5; x++) {
        z = x === 4 ? m[i + 4] : 0;
        temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
      }
      i += 5;
    }
    return temp;
  },
  _setSaturation = function _setSaturation(m, n) {
    var inv = 1 - n,
      r = inv * _lumR,
      g = inv * _lumG,
      b = inv * _lumB;
    return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
  },
  _colorize = function _colorize(m, color, amount) {
    var c = _parseColor(color),
      r = c[0] / 255,
      g = c[1] / 255,
      b = c[2] / 255,
      inv = 1 - amount;
    return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
  },
  _setHue = function _setHue(m, n) {
    n *= Math.PI / 180;
    var c = Math.cos(n),
      s = Math.sin(n);
    return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
  },
  _setContrast = function _setContrast(m, n) {
    return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
  },
  _getFilter = function _getFilter(t, type) {
    var filterClass = esm_TweenLite/* _gsScope.PIXI.filters */.ML.PIXI.filters[type],
      filters = t.filters || [],
      i = filters.length,
      filter;
    if (!filterClass) {
      throw "PixiPlugin error: " + type + " isn't present.";
    }
    while (--i > -1) {
      if (filters[i] instanceof filterClass) {
        return filters[i];
      }
    }
    filter = new filterClass();
    if (type === "BlurFilter") {
      filter.blur = 0;
    }
    filters.push(filter);
    t.filters = filters;
    return filter;
  },
  _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, pg, cache, vars) {
    //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.
    pg._addTween(cache, p, cache[p], vars[p], p);
    pg._overwriteProps.push(p);
  },
  _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {
    var temp = new esm_TweenLite/* _gsScope.PIXI.filters.ColorMatrixFilter */.ML.PIXI.filters.ColorMatrixFilter();
    temp.matrix = matrix;
    temp.brightness(brightness, true);
    return temp.matrix;
  },
  _CMFdefaults = {
    contrast: 1,
    saturation: 1,
    colorizeAmount: 0,
    colorize: "rgb(255,255,255)",
    hue: 0,
    brightness: 1
  },
  _parseColorMatrixFilter = function _parseColorMatrixFilter(t, v, pg) {
    var filter = _getFilter(t, "ColorMatrixFilter"),
      cache = t._gsColorMatrixFilter = t._gsColorMatrixFilter || {
        contrast: 1,
        saturation: 1,
        colorizeAmount: 0,
        colorize: "rgb(255,255,255)",
        hue: 0,
        brightness: 1
      },
      combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),
      i,
      matrix,
      startMatrix;
    startMatrix = filter.matrix;
    if (v.resolution) {
      filter.resolution = v.resolution;
    }
    if (v.matrix && v.matrix.length === startMatrix.length) {
      matrix = v.matrix;
      if (cache.contrast !== 1) {
        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
      }
      if (cache.hue) {
        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
      }
      if (cache.brightness !== 1) {
        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
      }
      if (cache.colorizeAmount) {
        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
      }
      if (cache.saturation !== 1) {
        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
      }
    } else {
      matrix = _idMatrix.slice();
      if (v.contrast != null) {
        matrix = _setContrast(matrix, Number(v.contrast));
        _addColorMatrixFilterCacheTween("contrast", pg, cache, v);
      } else if (cache.contrast !== 1) {
        if (combine) {
          matrix = _setContrast(matrix, cache.contrast);
        } else {
          _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
        }
      }
      if (v.hue != null) {
        matrix = _setHue(matrix, Number(v.hue));
        _addColorMatrixFilterCacheTween("hue", pg, cache, v);
      } else if (cache.hue) {
        if (combine) {
          matrix = _setHue(matrix, cache.hue);
        } else {
          _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
        }
      }
      if (v.brightness != null) {
        matrix = _applyBrightnessToMatrix(Number(v.brightness), matrix);
        _addColorMatrixFilterCacheTween("brightness", pg, cache, v);
      } else if (cache.brightness !== 1) {
        if (combine) {
          matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
        } else {
          _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
        }
      }
      if (v.colorize != null) {
        v.colorizeAmount = "colorizeAmount" in v ? Number(v.colorizeAmount) : 1;
        matrix = _colorize(matrix, v.colorize, v.colorizeAmount);
        _addColorMatrixFilterCacheTween("colorize", pg, cache, v);
        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
      } else if (cache.colorizeAmount) {
        if (combine) {
          matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
        } else {
          _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);
          _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
        }
      }
      if (v.saturation != null) {
        matrix = _setSaturation(matrix, Number(v.saturation));
        _addColorMatrixFilterCacheTween("saturation", pg, cache, v);
      } else if (cache.saturation !== 1) {
        if (combine) {
          matrix = _setSaturation(matrix, cache.saturation);
        } else {
          _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
        }
      }
    }
    i = matrix.length;
    while (--i > -1) {
      if (matrix[i] !== startMatrix[i]) {
        pg._addTween(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");
      }
    }
    pg._overwriteProps.push("colorMatrixFilter");
  },
  _addColorTween = function _addColorTween(target, p, value, colorSetter, plugin) {
    var pt = colorSetter._firstPT = {
      _next: colorSetter._firstPT,
      t: target,
      p: p,
      proxy: {},
      f: typeof target[p] === "function"
    };
    pt.proxy[p] = "rgb(" + _parseColor(!pt.f ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]()).join(",") + ")";
    plugin._addTween(pt.proxy, p, "get", typeof value === "number" ? "rgb(" + _parseColor(value, false).join(",") + ")" : value, p, null, null, _colorStringFilter);
  },
  //to improve performance, when a color is sensed, we hijack the setRatio() method of the plugin instance with a new function that this method spits back. This is a special method that handles parsing color values on-the-fly and turns them into numeric values which PixiJS requires. In other words, instead of "rgb(255, 0, 0)", PixiJS wants 0xFF0000. This also works with hsl() values.
  _buildColorSetter = function _buildColorSetter(tween, plugin) {
    var setRatio = plugin.setRatio,
      //save the original (super) setRatio() function
      func = function func(v) {
        var pt = func._firstPT,
          val;
        setRatio.call(plugin, v);
        while (pt) {
          val = _parseColor(pt.proxy[pt.p], "number");
          if (pt.f) {
            pt.t[pt.p](val);
          } else {
            pt.t[pt.p] = val;
          }
          pt = pt._next;
        }
        if (func.graphics) {
          //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the "dirty" and "clearDirty" values. If we don't do this, the values will be tween properly, but not rendered.
          func.graphics.dirty++;
          func.graphics.clearDirty++;
        }
      };
    plugin.setRatio = func;
    return func;
  },
  _colorProps = {
    tint: 1,
    lineColor: 1,
    fillColor: 1
  },
  _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
  _contexts = {
    x: "position",
    y: "position",
    tileX: "tilePosition",
    tileY: "tilePosition"
  },
  _colorMatrixFilterProps = {
    colorMatrixFilter: 1,
    saturation: 1,
    contrast: 1,
    hue: 1,
    colorize: 1,
    colorizeAmount: 1,
    brightness: 1,
    combineCMF: 1
  },
  _DEG2RAD = Math.PI / 180,
  _degreesToRadians = function _degreesToRadians(value) {
    return typeof value === "string" && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;
  },
  i,
  p;

//context setup...
for (i = 0; i < _xyContexts.length; i++) {
  p = _xyContexts[i];
  _contexts[p + "X"] = p;
  _contexts[p + "Y"] = p;
}

//color parsing setup...
for (p in _colorLookup) {
  _colorExp += "|" + p + "\\b";
}
_colorExp = new RegExp(_colorExp + ")", "gi");
_colorStringFilter = function _colorStringFilter(a) {
  var combined = a[0] + " " + a[1],
    toHSL;
  _colorExp.lastIndex = 0;
  if (_colorExp.test(combined)) {
    toHSL = combined.indexOf("hsl(") !== -1 || combined.indexOf("hsla(") !== -1;
    a[0] = _formatColors(a[0], toHSL);
    a[1] = _formatColors(a[1], toHSL);
  }
};
if (!PixiPlugin_TweenLite.defaultStringFilter) {
  PixiPlugin_TweenLite.defaultStringFilter = _colorStringFilter;
}
var PixiPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
  propName: "pixi",
  priority: 0,
  API: 2,
  global: true,
  version: "0.3.0",
  init: function init(target, values, tween, index) {
    if (!target instanceof esm_TweenLite/* _gsScope.PIXI.DisplayObject */.ML.PIXI.DisplayObject) {
      return false;
    }
    var isV4 = esm_TweenLite/* _gsScope.PIXI.VERSION.charAt */.ML.PIXI.VERSION.charAt(0) === "4",
      context,
      axis,
      value,
      colorMatrix,
      filter,
      p,
      padding,
      colorSetter,
      i,
      data,
      pt;
    for (p in values) {
      context = _contexts[p];
      value = values[p];
      if (typeof value === "function") {
        value = value(index || 0, target);
      }
      if (context) {
        axis = p.charAt(p.length - 1).toLowerCase().indexOf("x") !== -1 ? "x" : "y";
        this._addTween(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value, p);
      } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
        this._addTween(target[p], "x", target[p].x, value, p + "X");
        this._addTween(target[p], "y", target[p].y, value, p + "Y");
      } else if (p === "rotation") {
        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
        this._addTween(target, p, target.rotation, _degreesToRadians(value), p);
      } else if (_colorMatrixFilterProps[p]) {
        if (!colorMatrix) {
          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);
          colorMatrix = true;
        }
      } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
        filter = _getFilter(target, "BlurFilter");
        this._addTween(filter, p, filter[p], value, p);
        if (values.blurPadding !== 0) {
          padding = values.blurPadding || Math.max(filter[p], value) * 2;
          i = target.filters.length;
          while (--i > -1) {
            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
          }
        }
      } else if (_colorProps[p]) {
        if (!colorSetter) {
          colorSetter = _buildColorSetter(tween, this);
        }
        if ((p === "lineColor" || p === "fillColor") && target instanceof esm_TweenLite/* _gsScope.PIXI.Graphics */.ML.PIXI.Graphics) {
          data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5
          i = data.length;
          while (--i > -1) {
            _addColorTween(isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], isV4 ? p : "color", value, colorSetter, this);
          }
          colorSetter.graphics = target.geometry || target;
        } else {
          _addColorTween(target, p, value, colorSetter, this);
        }
      } else if (p === "autoAlpha") {
        this._firstPT = pt = {
          t: {
            setRatio: function setRatio() {
              target.visible = !!target.alpha;
            }
          },
          p: "setRatio",
          s: 0,
          c: 1,
          f: 1,
          pg: 0,
          n: "visible",
          pr: 0,
          m: 0,
          _next: this._firstPT
        };
        if (pt._next) {
          pt._next._prev = pt;
        }
        this._addTween(target, "alpha", target.alpha, value, "alpha");
        this._overwriteProps.push("alpha", "visible");
      } else {
        this._addTween(target, p, target[p], value, p);
      }
      this._overwriteProps.push(p);
    }
    return true;
  }
});
PixiPlugin.colorProps = _colorProps;
PixiPlugin.parseColor = _parseColor;
PixiPlugin.formatColors = _formatColors;
PixiPlugin.colorStringFilter = _colorStringFilter;
PixiPlugin.registerPIXI = function (PIXI) {
  esm_TweenLite/* _gsScope.PIXI */.ML.PIXI = PIXI;
};

;// CONCATENATED MODULE: ./src/components/advanced-slider/js/special.js



/* 
 *************************************
 * <!-- Advanced Slider (Special Effects) -->
 *************************************
 */



var ADVANCED_SLIDER_FILTER = function (module, $, window, document) {
  if (window.ADVANCED_SLIDER_FILTER === null) return false;
  module.ADVANCED_SLIDER_FILTER = module.ADVANCED_SLIDER_FILTER || {};
  module.ADVANCED_SLIDER_FILTER.version = '0.3.6';
  module.ADVANCED_SLIDER_FILTER.pageLoaded = function () {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-advanced-slider-sp');
    var
      //Save different canvas heights as an array
      canvasHeights = [],
      //Basic webGL renderers 
      rendererOuterID = 'uix-advanced-slider-sp__canvas-container',
      rendererCanvasID = 'uix-advanced-slider-sp__canvas',
      renderer,
      //PIXI
      renderer__filter,
      rendererCanvasID__filter = rendererCanvasID,
      stage__filter,
      container__items,
      displacementSprite,
      displacementFilter;
    sliderInit(false);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        sliderInit(true);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */
    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-advanced-slider-sp__item'),
          $first = $items.first(),
          activated = $this.data('activated');
        var nativeItemW, nativeItemH;
        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
            dataControlsArrows = $this.data('controls-arrows'),
            dataDraggable = $this.data('draggable'),
            dataDraggableCursor = $this.data('draggable-cursor'),
            dataCountTotal = $this.data('count-total'),
            dataCountCur = $this.data('count-now'),
            dataSpeed = $this.data('speed'),
            dataFilterTexture = $this.data('filter-texture');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-advanced-slider-sp__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-advanced-slider-sp__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current';
          if ((0,esm_typeof/* default */.Z)(dataFilterTexture) === ( true ? "undefined" : 0) || !dataFilterTexture || dataFilterTexture == '') dataFilterTexture = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

          //Autoplay parameters
          var dataAuto = $this.data('auto'),
            dataTiming = $this.data('timing'),
            dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;

          //Autoplay times
          var playTimes;
          //A function called "timer" once every second (like a digital watch).
          $this[0].animatedSlides;

          //Get the animation speed
          //-------------------------------------	
          if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
            animSpeed = dataSpeed;
          }

          //Display all images
          //-------------------------------------	
          if (!Modernizr.webgl) {
            $this.find('img').css('visibility', 'visible');
          }

          //Initialize the first item container
          //-------------------------------------		
          $items.addClass('next');
          $first.addClass('is-active');
          TweenMax.set($items, {
            alpha: 0,
            onComplete: function onComplete() {
              TweenMax.to($first, animSpeed / 1000, {
                alpha: 1,
                delay: animSpeed / 1000
              });
            }
          });
          if ($first.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($first.find('video').attr('id'));
            var videoURL = $first.find('source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $first.attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) != ( true ? "undefined" : 0)) {
              video.addEventListener('loadedmetadata', function (e) {
                $this.css('height', this.videoHeight * ($this.width() / this.videoWidth) + 'px');
                nativeItemW = this.videoWidth;
                nativeItemH = this.videoHeight;

                //Initialize all the items to the stage
                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              }, false);
              video.src = videoURL;
            }
          } else {
            var imgURL = $first.find('img').attr('src');
            if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
              var img = new Image();
              img.onload = function () {
                $this.css('height', $this.width() * (this.height / this.width) + 'px');
                nativeItemW = this.width;
                nativeItemH = this.height;

                //Initialize all the items to the stage
                addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, dataFilterTexture);
              };
              img.src = imgURL;
            }
          }

          //Autoplay Slider
          //-------------------------------------		
          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };
              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              };

              // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid
              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave);

              // To determine if it is a touch screen.
              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          }

          //Prevents front-end javascripts that are activated with AJAX to repeat loading.
          $this.data('activated', 1);
        } //endif activated
      });
    }

    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
    * @param  {String} countTotalID           - Total number ID or class of counter.
    * @param  {String} countCurID             - Current number ID or class of counter.
    * @param  {String} paginationID           - Navigation ID for paging control of each slide.
    * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */
    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-advanced-slider-sp__item'),
        total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;
        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;

          //Prevent problems with styles when switching in positive order
          if (playTimes == 0) {
            sliderUpdates(playTimes, slider, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
          } else {
            sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
          }
        }
      }, timing);
    }

    /*
     * Initialize all the items to the stage
     *
     * @param  {Element} slider                 - Current selector of each slider.
     * @param  {Number} nativeItemW            - Returns the intrinsic width of the image/video.
     * @param  {Number} nativeItemH            - Returns the intrinsic height of the image/video.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
           * @param  {Boolean} draggable             - Allow drag and drop on the slider.
           * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} filterTexture          - The texture used for the displacement map.
     * @return {Void}
     */
    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, filterTexture) {
      var $this = slider,
        $items = $this.find('.uix-advanced-slider-sp__item'),
        $first = $items.first(),
        itemsTotal = $items.length;

      //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.
      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-advanced-slider-sp__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-advanced-slider-sp__arrows--prev"></a><a href="#" class="uix-advanced-slider-sp__arrows--next"></a></div>');
      }

      //Add identifiers for the first and last items
      $items.last().addClass('last');
      $items.first().addClass('first');

      //Prevent bubbling
      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      }
      if (Modernizr.webgl) {
        //Load slides to canvas
        //-------------------------------------	
        if ($('#' + rendererCanvasID).length == 0) {
          $this.prepend('<div id="' + rendererOuterID + '" class="uix-advanced-slider-sp__canvas-container"><canvas id="' + rendererCanvasID + '"></canvas></div>');
        }

        //Save different canvas heights as an array
        //-------------------------------------	
        $this.find('.uix-advanced-slider-sp__item').each(function (index) {
          var $thisItem = $(this);
          if ($thisItem.find('video').length > 0) {
            //Returns the dimensions (intrinsic height and width ) of the video
            var video = document.getElementById($thisItem.find('video').attr('id'));
            var videoURL = $thisItem.find('video source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
            video.addEventListener('loadedmetadata', function (e) {
              var curW = this.videoWidth,
                curH = this.videoHeight,
                newW = curW,
                newH = curH;
              newW = $this.width();

              //Scaled/Proportional Content 
              newH = curH * (newW / curW);

              //Save different canvas heights as an array
              if (canvasHeights.length < itemsTotal) {
                canvasHeights.push(newH);
              }
            }, false);
            video.src = videoURL;
          } else {
            var imgURL = $thisItem.find('img').attr('src'),
              imgCur = new Image();
            imgCur.onload = function () {
              var curW_img = this.width,
                curH_img = this.height,
                newW_img = curW_img,
                newH_img = curH_img;
              newW_img = $this.width();

              //Scaled/Proportional Content 
              newH_img = curH_img * (newW_img / curW_img);

              //Save different canvas heights as an array
              if (canvasHeights.length < itemsTotal) {
                canvasHeights.push(newH_img);
              }
            };
            imgCur.src = imgURL;
          }
        }); //$this.find( '.uix-advanced-slider-sp__item' ).each

        //Basic webGL renderers 
        //-------------------------------------
        renderer = new PIXI.Application({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          antialias: true,
          autoResize: true,
          view: document.getElementById(rendererCanvasID)
        });
        renderer__filter = new PIXI.autoDetectRenderer({
          width: $this.width(),
          height: $this.height(),
          transparent: true,
          view: document.getElementById(rendererCanvasID__filter)
        });

        //
        //
        stage__filter = new PIXI.Container();
        container__items = new PIXI.Container();
        displacementSprite = /^.*\.(avi|AVI|wmv|WMV|flv|FLV|mpg|MPG|mp4|MP4)/.test(filterTexture) ? new PIXI.Sprite(PIXI.Texture.from(filterTexture)) : new PIXI.Sprite.from(filterTexture);
        displacementFilter = new PIXI.filters.DisplacementFilter(displacementSprite);

        //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: renderer.stage.children[index]
        if ($this.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this);

            //Load sprite from each slider to canvas
            //-------------------------------------
            var curSprite;
            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture);

              // pause the video
              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true;

              //Returns the dimensions (intrinsic height and width ) of the video
              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);
              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };
              imgCur.src = imgURL;
            }

            // center the sprite's anchor point
            curSprite.anchor.set(0);

            // sprite size
            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height;

            //Avoid error texture rendering errors ***!Important***
            TweenMax.set(curSprite, {
              alpha: 0
            });

            //Render updated scene
            //-------------------------------------   
            renderer.stage.addChild(curSprite);
          });

          //Initialize the default height of canvas
          //-------------------------------------	
          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]
        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this);

            //Load sprite from each slider to canvas
            //-------------------------------------
            var curSprite,
              canvasRatio = $this.width() / nativeItemW;
            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture);

              // pause the video
              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true;

              //Returns the dimensions (intrinsic height and width ) of the video
              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);
              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };
              imgCur.src = imgURL;
            }

            // center the sprite's anchor point
            curSprite.anchor.set(0);

            // sprite size
            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height;

            //Need to scale according to the screen
            curSprite.scale.set(canvasRatio);

            //Render updated scene
            //-------------------------------------   
            container__items.addChild(curSprite);

            //Add child container to the main container 
            //-------------------------------------
            stage__filter.addChild(container__items);
            // Enable Interactions
            stage__filter.interactive = true;

            //Set the filter to stage and set some default values for the animation
            //-------------------------------------

            //A texture stores the information that represents an image
            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter];

            //Add filter container to the main container
            //-------------------------------------				
            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2;
            displacementSprite.scale.x = 1;
            displacementSprite.scale.y = 1;

            // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass
            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite);

            //Animation Effects
            //-------------------------------------
            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          });

          //Initialize the default height of canvas
          //-------------------------------------	
          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]
        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this);

            //Load sprite from each slider to canvas
            //-------------------------------------
            var curSprite,
              canvasRatio = $this.width() / nativeItemW;
            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture);

              // pause the video
              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true;

              //Returns the dimensions (intrinsic height and width ) of the video
              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);
              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };
              imgCur.src = imgURL;
            }

            // center the sprite's anchor point
            curSprite.anchor.set(0);

            // sprite size
            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height;

            //Need to scale according to the screen
            curSprite.scale.set(canvasRatio);

            //Avoid error texture rendering errors ***!Important***
            TweenMax.set(curSprite, {
              alpha: 0
            });

            //Render updated scene
            //-------------------------------------   
            container__items.addChild(curSprite);

            //Add child container to the main container 
            //-------------------------------------
            stage__filter.addChild(container__items);
            // Enable Interactions
            stage__filter.interactive = true;

            //Set the filter to stage and set some default values for the animation
            //-------------------------------------

            //A texture stores the information that represents an image
            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP;
            stage__filter.filters = [displacementFilter];

            //Add filter container to the main container
            //-------------------------------------				
            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2;

            // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass
            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite);

            //Animation Effects
            //-------------------------------------
            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          });

          //Initialize the default height of canvas
          //-------------------------------------	
          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]
        if ($this.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this);

            //Load sprite from each slider to canvas
            //-------------------------------------
            var curSprite,
              canvasRatio = $this.width() / nativeItemW;
            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture);

              // pause the video
              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true;

              //Returns the dimensions (intrinsic height and width ) of the video
              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);
              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };
              imgCur.src = imgURL;
            }

            // center the sprite's anchor point
            curSprite.anchor.set(0);

            // sprite size
            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height;

            //Need to scale according to the screen
            curSprite.scale.set(canvasRatio);

            //Avoid error texture rendering errors ***!Important***
            TweenMax.set(curSprite, {
              alpha: 0
            });

            //Render updated scene
            //-------------------------------------   
            container__items.addChild(curSprite);

            //Add child container to the main container 
            //-------------------------------------
            stage__filter.addChild(container__items);
            // Enable Interactions
            stage__filter.interactive = true;

            //Set the filter to stage and set some default values for the animation
            //-------------------------------------

            //A texture stores the information that represents an image
            displacementSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
            stage__filter.filters = [displacementFilter];

            //Add filter container to the main container
            //-------------------------------------				
            displacementSprite.anchor.set(0.5);
            displacementSprite.x = renderer__filter.width / 2;
            displacementSprite.y = renderer__filter.height / 2;

            // PIXI tries to fit the filter bounding box to the renderer so we optionally bypass
            displacementFilter.autoFit = false;
            stage__filter.addChild(displacementSprite);

            //Animation Effects
            //-------------------------------------
            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              //Need the displacementSprite.texture.baseTexture.wrapMode is "PIXI.WRAP_MODES.REPEAT"
              displacementSprite.x += 1 * delta;
              displacementSprite.y += 0.3;

              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          });

          //Initialize the default height of canvas
          //-------------------------------------	
          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -------------------------------
        //----------------------------------------------------------------------------------
        //Usage of returning sprite object: container__items.children[index]
        if ($this.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          $this.find('.uix-advanced-slider-sp__item').each(function (index) {
            var $thisItem = $(this);

            //Load sprite from each slider to canvas
            //-------------------------------------
            var curSprite,
              canvasRatio = $this.width() / nativeItemW;
            if ($thisItem.find('video').length > 0) {
              // create a video texture from a path
              var videoURL = $thisItem.find('source:first').attr('src');
              if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = $thisItem.attr('src');
              var texture = PIXI.Texture.from(videoURL);
              curSprite = new PIXI.Sprite(texture);

              // pause the video
              var videoSource = texture.baseTexture.resource.source;
              videoSource.autoplay = false;
              videoSource.pause();
              videoSource.currentTime = 0;
              videoSource.muted = true;

              //Returns the dimensions (intrinsic height and width ) of the video
              var video = document.getElementById($thisItem.find('video').attr('id'));
              video.addEventListener('loadedmetadata', function (e) {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              }, false);
              video.src = videoURL;
            } else {
              var imgURL = $thisItem.find('img').attr('src'),
                imgCur = new Image();
              curSprite = new PIXI.Sprite.from(imgURL);
              imgCur.onload = function () {
                //At the same time change the height of the canvas
                renderer.view.style.width = $this.width() + 'px';
                renderer.view.style.height = canvasHeights[index] + 'px';
              };
              imgCur.src = imgURL;
            }

            // center the sprite's anchor point
            curSprite.anchor.set(0);

            // sprite size
            curSprite.width = renderer.view.width;
            curSprite.height = renderer.view.height;

            //Need to scale according to the screen
            curSprite.scale.set(canvasRatio);

            //Avoid error texture rendering errors ***!Important***
            TweenMax.set(curSprite, {
              alpha: 0
            });

            //Render updated scene
            //-------------------------------------   
            container__items.addChild(curSprite);

            //Add child container to the main container 
            //-------------------------------------
            stage__filter.addChild(container__items);
            // Enable Interactions
            stage__filter.interactive = true;

            // Create mask
            //-------------------------------------
            //current mask
            var curSpriteMask = new PIXI.Graphics();
            curSpriteMask.lineStyle(0);
            curSpriteMask.beginFill(0xFFFFFF);
            curSpriteMask.moveTo(0, 0);
            curSpriteMask.lineTo(renderer.view.width, 0);
            curSpriteMask.lineTo(renderer.view.width, renderer.view.height);
            curSpriteMask.lineTo(0, renderer.view.height);
            curSpriteMask.endFill();
            curSpriteMask.position.x = 0;
            curSpriteMask.position.y = 0;
            curSprite.mask = curSpriteMask;
            stage__filter.addChild(curSpriteMask); //Do not add to the container

            //Animation Effects
            //-------------------------------------
            var ticker = new PIXI.Ticker();
            ticker.autoStart = true;
            ticker.add(function (delta) {
              // Render updated scene
              renderer__filter.render(stage__filter);
            });
          });

          //Initialize the default height of canvas
          //-------------------------------------	
          setTimeout(function () {
            canvasDefaultInit($this, $first);
          }, animSpeed);
        } // end effect

        //Canvas Interactions
        //-------------------------------------
        transitionInteractions(0, itemsTotal - 1, $this, 'in', 'next');
      }

      // Fires local videos asynchronously with slider switch.
      //-------------------------------------
      if (!Modernizr.webgl) normalSliderVideoInit($items, false);

      //Pagination dots 
      //-------------------------------------	
      var _dot = '',
        _dotActive = '';
      _dot += '<ul>';
      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }
      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault();

        //Prevent buttons' events from firing multiple times
        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animSpeed).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        });

        //
        if (!$(this).hasClass('is-active')) {
          //Determine the direction
          var curDir = 'prev';
          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }

          //Canvas Interactions
          transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', curDir);

          //Update the current and previous/next items
          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop);

          //Pause the auto play event
          clearInterval($this[0].animatedSlides);
        }
      });

      //Next/Prev buttons
      //-------------------------------------		
      var _prev = $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev'),
        _next = $(arrowsID).find('.uix-advanced-slider-sp__arrows--next');
      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');
      if (!loop) {
        _prev.addClass('is-disabled');
      }
      _prev.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        prevMove();
      });
      _next.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        nextMove();
      });
      function prevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;
        _prev.attr('aria-disabled', 'true');
        _prev.delay(animSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_prev.hasClass('is-disabled')) return false;

        //Canvas Interactions
        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'prev');

        //Update the current and previous items
        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }
      function nextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;
        _next.attr('aria-disabled', 'true');
        _next.delay(animSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_next.hasClass('is-disabled')) return false;

        //Canvas Interactions
        transitionInteractions($items.filter('.is-active').index(), $items.filter('.leave').index(), $this, 'out', 'next');

        //Update the current and next items
        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      //Added touch method to mobile device and desktop
      //-------------------------------------	
      var $dragTrigger = $this.find('.uix-advanced-slider-sp__inner');
      var mouseX, mouseY;
      var isMoving = false;

      //Avoid images causing mouseup to fail
      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      });

      //Make the cursor a move icon when a user hovers over an item
      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor);

      //draggable for touch devices
      if (Modernizr.touchevents) draggable = true;
      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd);

        //
        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }
      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;
        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }
      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;
        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        }

        //--- left
        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        }

        //--- right
        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        }

        //--- up
        if (offsetY >= 50) {}

        //--- down
        if (offsetY <= -50) {}
      }
      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess);

        //restore move action status
        setTimeout(function () {
          isMoving = false;
        }, animSpeed);
      }
    }

    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */
    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-advanced-slider-sp__item'),
        total = $items.length;

      //Prevent bubbling
      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      }

      //Transition Interception
      //-------------------------------------
      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
      }

      // To determine if it is a touch screen.
      //-------------------------------------
      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0;

        //Prevent bubbling
        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--prev').addClass('is-disabled');
          }

          //last item
          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-advanced-slider-sp__arrows--next').addClass('is-disabled');
          }
        }
      }

      // call the current item
      //-------------------------------------
      var $current = $items.eq(elementIndex);

      //Determine the direction and add class to switching direction indicator.
      //-------------------------------------
      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next';

      //Add transition class to Controls Pagination
      //-------------------------------------
      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave');

      //Add transition class to each item
      //-------------------------------------	
      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-advanced-slider-sp__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave');

      //Display counter
      //-------------------------------------
      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1);

      // Fires local videos asynchronously with slider switch.
      //-------------------------------------
      if (!Modernizr.webgl) {
        normalSliderVideoInit($items, false);
        normalSliderVideoInit($current, true);
      }

      //Reset the default height of canvas
      //-------------------------------------	
      setTimeout(function () {
        canvasDefaultInit(slider, $current);
      }, animSpeed);

      //Canvas Interactions
      //-------------------------------------

      //-- Brightness Effect
      if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {}

      //-- Liquid Distortion Effect
      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {}

      //-- Liquid Distortion Effect 2
      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {}

      //-- Liquid Distortion Effect 3
      if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {}

      //-- Parallax Effect 
      if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
        if (loop) {
          if (elementIndex == 0) dir = 'prev';
        }
      }
      transitionInteractions(elementIndex, $items.filter('.leave').index(), slider, 'in', dir);
    }

    /*
     * Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
     *
     * @param  {Number} w                - The width that the canvas will be set.
     * @param  {Number} h                - The height that the canvas will be set.
     * @return {Void}
     */
    function fixCanvasTagSize(w, h) {
      TweenMax.to(['#' + rendererCanvasID, '.uix-advanced-slider-sp__wrapper', '.uix-advanced-slider-sp__inner', '.uix-advanced-slider-sp__canvas-container'], animSpeed / 1000, {
        width: w,
        height: h
      });
    }

    /*
     * Initialize the default height of canvas
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */
    function canvasDefaultInit(slider, currentLlement) {
      if (currentLlement.find('video').length > 0) {
        //Returns the dimensions (intrinsic height and width ) of the video
        var video = document.getElementById(currentLlement.find('video').attr('id'));
        var videoURL = currentLlement.find('source:first').attr('src');
        if ((0,esm_typeof/* default */.Z)(videoURL) === ( true ? "undefined" : 0)) videoURL = currentLlement.attr('src');
        video.addEventListener('loadedmetadata', function (e) {
          //At the same time change the height of the canvas and slider container
          var h = this.videoHeight * (currentLlement.closest('.uix-advanced-slider__outline').width() / this.videoWidth);
          if (Modernizr.webgl) {
            renderer.view.style.height = h + 'px';
          }

          //---
          slider.css('height', h + 'px');
        }, false);
        video.src = videoURL;
      } else {
        var imgURL = currentLlement.find('img').attr('src');
        if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
          var img = new Image();
          img.onload = function () {
            if (Modernizr.webgl) {
              renderer.view.style.height = currentLlement.find('img').height() + 'px';
            }
            //---
            slider.css('height', currentLlement.closest('.uix-advanced-slider__outline').width() * (this.height / this.width) + 'px');
          };
          img.src = imgURL;
        }
      }
    }

    /*
     * Canvas Transition Interactions
     * @http://pixijs.download/dev/docs/index.html
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Number} prevElementIndex       - Index of previous slider.
     * @param  {Element} slider                 - Selector of the slider.
     * @param  {String} goType                 - The type of entry and exit between two items.  
                                                 Optional values: in, out
     * @param  {String} dir                    - Switching direction indicator.	 
     * @return {Void}
     */
    function transitionInteractions(elementIndex, prevElementIndex, slider, goType, dir) {
      if (Modernizr.webgl) {
        var $myRenderer = $('#' + rendererOuterID),
          $current = slider.find('.uix-advanced-slider-sp__item').eq(elementIndex),
          $allItems = slider.find('.uix-advanced-slider-sp__item'),
          imgSel = $current.find('img'),
          curImgURL = imgSel.attr('src'),
          stageW = slider.width(),
          stageH = slider.height(),
          spTotal = slider.find('.uix-advanced-slider-sp__item').length;
        elementIndex = parseFloat(elementIndex);
        prevElementIndex = parseFloat(prevElementIndex);

        //----------------------------------------------------------------------------------
        //--------------------------------- Brightness Effect -------------------------------	
        //----------------------------------------------------------------------------------
        if (slider.hasClass('uix-advanced-slider-sp--eff-brightness')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });

          //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	
          if (goType == 'out') {
            //Current item leaving action

            TweenMax.to(renderer.stage.children[elementIndex], animSpeed / 1000, {
              pixi: {
                brightness: 5
              },
              alpha: 1
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = renderer.stage.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                });

                //display the current item
                for (var k = 0; k < spTotal; k++) {
                  var obj = renderer.stage.children[k];
                  TweenMax.set(obj, {
                    alpha: 0
                  });

                  //pause all videos
                  if (obj._texture.baseTexture.imageType == null) {
                    var videoSource = obj.texture.baseTexture.resource.source;

                    // play the video
                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                }

                //play current video
                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source;

                  // play the video
                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                }

                //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );
                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);

                //display filters
                TweenMax.set(curSp, {
                  pixi: {
                    brightness: 5
                  },
                  alpha: 1,
                  onComplete: function onComplete() {
                    TweenMax.to(this.target, animSpeed / 1000, {
                      pixi: {
                        brightness: 1
                      }
                    });
                    TweenMax.to($current, animSpeed / 1000, {
                      alpha: 1
                    });
                  }
                });
              }
            });
          }
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect -----------------------
        //----------------------------------------------------------------------------------
        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });
          var curSp = container__items.children[elementIndex],
            prevSp = container__items.children[prevElementIndex];

          //Display the current item
          //-------------------------------------
          if (!slider.hasClass('js-init-ok')) {
            for (var k = 0; k < spTotal; k++) {
              var obj = container__items.children[k];
              TweenMax.set(obj, {
                alpha: 0
              });
            }

            //Avoid repeated initialization
            slider.addClass('js-init-ok');
          }

          //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	
          if (goType == 'out') {
            //Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _k = 0; _k < spTotal; _k++) {
                var _obj = container__items.children[_k];

                //pause all videos
                if (_obj._texture.baseTexture.imageType == null) {
                  var videoSource = _obj.texture.baseTexture.resource.source;

                  // play the video
                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              }

              //play current video
              if (curSp._texture.baseTexture.imageType == null) {
                var videoSource2 = curSp.texture.baseTexture.resource.source;

                // play the video
                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              }

              //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );
              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100);

            //Current item entry action
            var baseTimeline = new TimelineMax({
              onComplete: function onComplete() {
                displacementSprite.scale.set(1);
              },
              onUpdate: function onUpdate() {
                displacementSprite.rotation += baseTimeline.progress() * 0.02;
                displacementSprite.scale.set(baseTimeline.progress() * 3);
              }
            });
            baseTimeline.clear();
            if (baseTimeline.isActive()) {
              return;
            }
            baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
              x: 300,
              y: 300,
              ease: Power1.easeOut
            }).to(prevSp, animSpeed / 2 / 1000, {
              alpha: 0,
              ease: Power2.easeOut
            }, animSpeed / 3 / 1000).to(curSp, animSpeed / 2 / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
              x: 0,
              y: 0,
              ease: Power2.easeOut
            }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
              alpha: 1,
              ease: Power2.easeOut
            }, 'final');

            //Add new ripple each time mouse
            //-------------------------------------
            slider[0].addEventListener("mousedown", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: "+=" + Math.sin(e.pageX) * 100 + "",
                y: "+=" + Math.cos(e.pageY) * 100 + ""
              });
              rotateSpite();
            });
            slider[0].addEventListener("mouseup", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: 0,
                y: 0
              });
            });
            var rotateSpite = function rotateSpite() {
              displacementFilter.rotation += 0.001;
            };
          }
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 2 -----------------------
        //----------------------------------------------------------------------------------
        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid2')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });

          //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	
          if (goType == 'out') {
            //Current item leaving action

            TweenMax.to(displacementSprite.scale, 1, {
              x: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                });

                //display the current item
                for (var _k2 = 0; _k2 < spTotal; _k2++) {
                  var _obj2 = container__items.children[_k2];
                  TweenMax.set(_obj2, {
                    alpha: 0
                  });

                  //pause all videos
                  if (_obj2._texture.baseTexture.imageType == null) {
                    var videoSource = _obj2.texture.baseTexture.resource.source;

                    // play the video
                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                }

                //play current video
                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source;

                  // play the video
                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                }

                //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );
                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);

                //display filters

                //sprite
                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {
                    TweenMax.to(displacementSprite.scale, 1, {
                      x: 1,
                      y: 1
                    });
                    TweenMax.to(displacementSprite, 1, {
                      rotation: 0
                    });
                  },
                  onUpdate: function onUpdate() {
                    displacementSprite.scale.set(baseTimeline.progress() * 13);
                    displacementSprite.rotation += baseTimeline.progress() * 0.02;
                  }
                });
                baseTimeline.clear();

                //filter
                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 200 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            });

            //Add new ripple each time mouse is clicked/mousemoved
            //-------------------------------------
            document.addEventListener("mousemove", function (e) {
              TweenMax.to(displacementFilter.scale, 1, {
                x: e.pageX / 2 + ""
              });
            });
          }
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Liquid Distortion Effect 3 -----------------------
        //----------------------------------------------------------------------------------
        if (slider.hasClass('uix-advanced-slider-sp--eff-liquid3')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });

          //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	
          if (goType == 'out') {
            //Current item leaving action

            TweenMax.to(displacementSprite, 1, {
              x: 23,
              y: 10
            });
          } else {
            //Current item entry action
            TweenMax.to($myRenderer, animSpeed / 1000, {
              alpha: 0,
              onComplete: function onComplete() {
                var curSp = container__items.children[elementIndex];
                TweenMax.to(this.target, animSpeed / 1000, {
                  alpha: 1
                });

                //display the current item
                for (var _k3 = 0; _k3 < spTotal; _k3++) {
                  var _obj3 = container__items.children[_k3];
                  TweenMax.set(_obj3, {
                    alpha: 0
                  });

                  //pause all videos
                  if (_obj3._texture.baseTexture.imageType == null) {
                    var videoSource = _obj3.texture.baseTexture.resource.source;

                    // play the video
                    videoSource.currentTime = 0;
                    videoSource.autoplay = false;
                    if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                    videoSource.muted = true;
                  }
                }

                //play current video
                if (curSp._texture.baseTexture.imageType == null) {
                  var videoSource2 = curSp.texture.baseTexture.resource.source;

                  // play the video
                  videoSource2.currentTime = 0;
                  videoSource2.autoplay = true;
                  if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                  videoSource2.muted = false;
                }

                //Reset the height of the canvas when each item is switched
                //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
                //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );
                fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);

                //display filters

                //sprite
                var baseTimeline = new TimelineMax({
                  delay: 0,
                  paused: false,
                  repeat: 0,
                  onRepeat: function onRepeat() {},
                  onComplete: function onComplete() {},
                  onUpdate: function onUpdate() {}
                });
                baseTimeline.clear();

                //filter
                baseTimeline.to(displacementFilter.scale, animSpeed / 1000, {
                  y: "+=" + 50 + "",
                  ease: Power3.easeOut
                }).to(curSp, animSpeed / 2 / 1000, {
                  alpha: 1,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to(displacementFilter.scale, animSpeed / 1000, {
                  y: 0,
                  ease: Power3.easeOut
                }, animSpeed / 2 / 1000).to($current, animSpeed / 1000, {
                  alpha: 1,
                  ease: Power2.easeOut
                }, 'final');
              }
            });
          }
        } // end effect

        //----------------------------------------------------------------------------------
        //--------------------------------- Parallax Effect -----------------------------
        //----------------------------------------------------------------------------------
        if (slider.hasClass('uix-advanced-slider-sp--eff-parallax')) {
          //Hide description container of item
          //-------------------------------------
          TweenMax.to($allItems, animSpeed / 1000, {
            alpha: 0
          });

          //Prevent text overlap when switching quickly
          $allItems.attr('data-text-eff-enable', 0);
          $current.attr('data-text-eff-enable', 1);
          var curSpParallax = container__items.children[elementIndex],
            prevSpParallax = container__items.children[prevElementIndex];

          //Display the current item
          //-------------------------------------
          if (!slider.hasClass('js-init-ok')) {
            for (var m = 0; m < spTotal; m++) {
              var objParallax = container__items.children[m];
              TweenMax.set(objParallax.mask, {
                x: renderer.view.width
              });
            }

            //Avoid repeated initialization
            slider.addClass('js-init-ok');
          }

          //Display wrapper of canvas (transitions between slides)
          //-------------------------------------	
          if (goType == 'out') {
            //Current item leaving action
          } else {
            //Video sprite initialization
            //Need to ensure that the video tag exists
            setTimeout(function () {
              for (var _m = 0; _m < spTotal; _m++) {
                var _obj4 = container__items.children[_m];

                //pause all videos
                if (_obj4._texture.baseTexture.imageType == null) {
                  var videoSource = _obj4.texture.baseTexture.resource.source;

                  // play the video
                  videoSource.currentTime = 0;
                  videoSource.autoplay = false;
                  if (Object.prototype.toString.call(videoSource.pause) == '[object Function]') videoSource.pause();
                  videoSource.muted = true;
                }
              }

              //play current video
              if (curSpParallax._texture.baseTexture.imageType == null) {
                var videoSource2 = curSpParallax.texture.baseTexture.resource.source;

                // play the video
                videoSource2.currentTime = 0;
                videoSource2.autoplay = true;
                if (Object.prototype.toString.call(videoSource2.play) == '[object Function]') videoSource2.play();
                videoSource2.muted = false;
              }

              //Reset the height of the canvas when each item is switched
              //Fixed image width adaptation problem for Advanced Slider (on HTML tag <canvas>)
              //console.log( 'width: ' + windowWidth + ' | height: ' + canvasHeights[ elementIndex ] + ' | index: ' + elementIndex );
              fixCanvasTagSize(windowWidth, canvasHeights[elementIndex]);
            }, 100);

            //Current item entry action
            var restoreX,
              offsetX = renderer.view.width / 6,
              parallaxSpeed = animSpeed / 1000,
              restoreItems = function restoreItems() {
                //restore other items besides the current item
                for (var n = 0; n < spTotal; n++) {
                  var _objParallax = container__items.children[n];
                  if (elementIndex != n) _objParallax.mask.x = restoreX;
                }
              },
              goNextItem = function goNextItem() {
                // Paralax effect on current slide
                TweenMax.set(curSpParallax, {
                  alpha: 1,
                  //Avoid error texture rendering errors ***!Important***
                  onComplete: function onComplete() {
                    TweenMax.to(this.target, parallaxSpeed, {
                      x: 0,
                      ease: Power2.easeInOut
                    });
                  }
                });

                // Current Mask animation
                TweenMax.to(curSpParallax.mask, parallaxSpeed, {
                  x: 0,
                  ease: Power4.easeInOut,
                  onComplete: function onComplete() {
                    restoreItems();
                  }
                });
                setTimeout(function () {
                  //text effect
                  if ($.isFunction($.fn.UixTextEff)) {
                    $current.find('[data-text-eff]').each(function (index) {
                      $(document).UixTextEff({
                        selectors: '[data-text-eff="' + $(this).data('text-eff') + '"]',
                        scrollSpy: false
                      });
                    });
                  }

                  //Prevent text overlap when switching quickly
                  $allItems.each(function () {
                    if ($(this).attr('data-text-eff-enable') == 1) {
                      TweenMax.to($(this), parallaxSpeed, {
                        alpha: 1,
                        delay: parallaxSpeed / 2
                      });
                    } else {
                      TweenMax.to($(this), parallaxSpeed, {
                        alpha: 0,
                        delay: parallaxSpeed / 2
                      });
                    }
                  });
                }, parallaxSpeed * 1000 / 2);
              };

            // Direction handler
            if (dir == 'next') {
              curSpParallax.x = offsetX;
              curSpParallax.mask.x = renderer.view.width;
              restoreX = renderer.view.width;

              // Paralax effect on current slide
              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: -offsetX,
                ease: Power2.easeInOut
              });
            } else {
              curSpParallax.x = -offsetX;
              curSpParallax.mask.x = -(renderer.view.width + curSpParallax.x);
              restoreX = -renderer.view.width;

              // Paralax effect on previous slide
              TweenMax.to(prevSpParallax, parallaxSpeed, {
                x: offsetX,
                ease: Power2.easeInOut
              });

              // Previous Mask animation
              TweenMax.to(prevSpParallax.mask, parallaxSpeed, {
                x: renderer.view.width,
                ease: Power4.easeInOut
              });
            }
            goNextItem();
          }
        } // end effect		
      } else {
        slider.find('.uix-advanced-slider-sp__item canvas').hide();
      }
    }

    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */
    function normalSliderVideoInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('.uix-advanced-slider__outline').width(),
          curVideoID = $this.find('video').attr('id') + '-slider-videopush',
          coverPlayBtnID = 'videocover-' + curVideoID,
          $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
          dataAuto = $this.data('embed-video-autoplay'),
          dataLoop = $this.data('embed-video-loop'),
          dataW = $this.data('embed-video-width'),
          dataH = $this.data('embed-video-height');

        //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play
        $this.find('.video-js').attr('id', curVideoID);
        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }
        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }
        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        }

        //Display cover and play buttons when some mobile device browsers cannot automatically play video
        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        }

        //Add replay button to video 
        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        }

        //HTML5 video autoplay on mobile revisited
        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }
        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH;
            newW = videoWrapperW;

            //Scaled/Proportional Content 
            newH = curH * (newW / curW);
            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            }

            //Show this video wrapper
            $this.css('visibility', 'visible');

            //Hide loading effect
            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };

          /* ---------  Video initialize */
          this.on('loadedmetadata', function () {
            initVideo(this);
          });

          /* ---------  Display the play button  */
          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });

          /* ---------  Set, tell the player it's in fullscreen  */
          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            this.muted(true);

            //Prevent autoplay error: Uncaught (in promise) DOMException
            var promise = this.play();
            if (promise !== undefined) {
              promise.then(function () {
                // Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }

          /* ---------  Disable control bar play button click */
          if (!dataControls) {
            this.controls(false);
          }

          /* ---------  Determine if the video is auto played from mobile devices  */
          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();
            if (duration > 0) {
              autoPlayOK = true;
              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate');

                //Hide cover and play buttons when the video automatically played
                $('#' + coverPlayBtnID).hide();
              }
            }
          });

          /* ---------  Pause the video when it is not current slider  */
          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            //Unmute, because there is interaction, you can turn on the audio.
            this.muted(false);
            if (dataAuto) {
              this.currentTime(0);

              //Prevent autoplay error: Uncaught (in promise) DOMException
              var _promise = this.play();
              if (_promise !== undefined) {
                _promise.then(function () {
                  // Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              }

              //Hidden replay button
              $replayBtn.hide();

              //Should the video go to the beginning when it ends
              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }
  };
  module.components.pageLoaded.push(module.ADVANCED_SLIDER_FILTER.pageLoaded);
  return /*#__PURE__*/_createClass(function ADVANCED_SLIDER_FILTER() {
    _classCallCheck(this, ADVANCED_SLIDER_FILTER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/AJAX-push/js/index.js



/* 
 *************************************
 * <!-- Ajax Push Content  -->
 *************************************
 */


var AJAX_PUSH_CONTENT = function (module, $, window, document) {
  if (window.AJAX_PUSH_CONTENT === null) return false;
  module.AJAX_PUSH_CONTENT = module.AJAX_PUSH_CONTENT || {};
  module.AJAX_PUSH_CONTENT.version = '0.1.9';
  module.AJAX_PUSH_CONTENT.documentReady = function ($) {
    // trigger of AJAX request
    var AJAXPageLinks = '[data-ajax-push-content]';

    //all images from pages
    var sources = [];

    //Added timer to prevent page loading errors for a long time
    var timeClockInit;

    /* Need to set it as a global variable for history */
    var ajaxConfig = {
        "container": "#my-ajax-demo-push-container",
        "target": "#my-ajax-demo-target-container",
        "loading": "<div class=\"my-loader\"><span><i class=\"fa fa-spinner fa-spin\"></i> loading <em id=\"app-loading\" data-txt=\"{progress}%\"></em>...</span></div>",
        "method": "POST"
      },
      thisPageTitle = document.title;

    // The progress of each page load, using global variables to accurately determine
    var loadedProgress = 0;

    //loading animation
    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    };

    //Click event
    $(document).off('click.AJAX_PUSH_CONTENT').on('click.AJAX_PUSH_CONTENT', AJAXPageLinks, function (event) {
      event.preventDefault();

      // The progress of each page load
      loadedProgress = 0;

      //
      var $this = $(this);
      var curURL = $this.attr('href'),
        config = $this.data('ajax-push-content');
      if ((0,esm_typeof/* default */.Z)(config) == ( true ? "undefined" : 0)) {
        config = ajaxConfig;
      }

      //The currently URL of link
      if ((0,esm_typeof/* default */.Z)(curURL) === ( true ? "undefined" : 0)) {
        curURL = $this.closest('a').attr('href');
      }

      //Prevent multiple request on click
      if ($this.data('request-running')) {
        return;
      }
      $this.data('request-running', true);

      // Modify the URL without reloading the page
      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      }

      //Click on this link element using an AJAX request
      pushAction($(config.container), config.target, config.loading, curURL, config.method, $this);
      return false;
    });

    //Detect URL change & Fire click event
    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
        goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )
        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      });

      //Empty content that does not exist
      if (eleTarget == null) {
        $(AJAXPageLinks).each(function () {
          var curConfig = $(this).data('ajax-push-content');
          if ((0,esm_typeof/* default */.Z)(curConfig) != ( true ? "undefined" : 0)) {
            $(curConfig.container).html('');
          }
        });
      }

      //Push new content to target container
      var backConfig = $(eleTarget).data('ajax-push-content');
      if ((0,esm_typeof/* default */.Z)(backConfig) != ( true ? "undefined" : 0)) {
        pushAction($(backConfig.container), backConfig.target, backConfig.loading, goURL, backConfig.method, $(eleTarget));
      }

      // Output history button
      //console.log(  $( eleTarget ).data( 'ajax-push-content' ) );
    });

    /*
     * Move Animation
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String|Boolean} target  - The instance ID or class name returned from the callback data. If it is "false", the push content is empty.
     * @param  {String} loading         - Content of loading area.
     * @param  {String} url             - The target URL via AJAX. 
     * @param  {String} method          - The HTTP method to use for the request (e.g. "POST", "GET", "PUT")
     * @param  {?Element|Boolean} btn     - Current trigger button. Avoid button events if "false".
     * @return {Void}
     */
    function pushAction(container, target, loading, url, method, btn) {
      if (container.length == 0) return false;
      if ((0,esm_typeof/* default */.Z)(method) === ( true ? "undefined" : 0) || method == '') {
        method = 'POST';
      }

      // Add a request or response interceptor
      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent

        //Display loader
        showLoader(container, loading);

        //
        return config;
      }, function (error) {
        return Promise.reject(error);
      });

      // To send data in the application/x-www-form-urlencoded format instead
      var formData = new FormData();
      var defaultPostData = {
        action: 'load_singlepages_ajax_content'
      };
      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      }

      // Create a request event
      axios({
        timeout: 15000,
        method: method,
        url: url,
        data: formData,
        responseType: 'text'
      }).then(function (response) {
        var htmlCode = response.data;

        //A function to be called if the request succeeds
        var pushContent = !target ? '' : $(htmlCode).find(target).html();

        //Display loading image when AJAX call is in progress

        //Remove existing images
        sources = [];

        //Push all images from page
        $(htmlCode).find('img').each(function () {
          sources.push({
            "url": this.src,
            "id": 'img-' + UixGUID.create(),
            "type": 'img'
          });
        });

        //Push all videos from page
        $(htmlCode).find('.uix-video__slider > video').each(function () {
          var _src = $(this).find('source:first').attr('src');
          if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = $(this).attr('src');
          sources.push({
            "url": _src,
            "id": 'video-' + UixGUID.create(),
            "type": 'video'
          });
        });

        //Execute after all images have loaded
        var per;
        var perInit = 1;
        if (sources.length == 0) {
          per = 100;

          //loading animation
          loadingAnim(per);

          //Remove loader
          hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
        }
        var loadImages = function loadImages() {
          var promises = [];
          var _loop = function _loop(i) {
            if (sources[i].type == 'img') {
              ///////////
              // IMAGE //
              ///////////   

              promises.push(new Promise(function (resolve, reject) {
                var img = document.createElement("img");
                img.src = sources[i].url;
                img.onload = function (image) {
                  //Compatible with safari and firefox
                  if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                    return resolve(image.target.currentSrc);
                  } else {
                    return resolve(image.path[0].currentSrc);
                  }
                };
              }).then(textureLoaded));
            } else {
              ///////////
              // VIDEO //
              ///////////    

              promises.push(new Promise(function (resolve, reject) {
                $('#' + sources[i].id).one('loadedmetadata', resolve);
                return resolve(sources[i].url);
              }).then(textureLoaded));
            }
          };
          for (var i = 0; i < sources.length; i++) {
            _loop(i);
          }
          return Promise.all(promises);
        };
        var textureLoaded = function textureLoaded(url) {
          //loading
          per = parseInt(100 * (perInit / sources.length));
          console.log('progress: ' + per + '%');
          if (isNaN(per)) per = 100;

          // The progress of each page load
          loadedProgress = per;

          //loading animation
          loadingAnim(per);
          var texture = null;
          perInit++;
          return per;
        };
        var func = function func() {
          ajaxSucceeds(container, pushContent, $(htmlCode).filter('title').text(), btn);
        };

        //images loaded
        //Must be placed behind the loadImages()
        loadImages().then(function (images) {
          clearInterval(timeClockInit);
          func();
        });

        //Calculating page load time
        var timeLimit = 10,
          timeStart = new Date().getTime();

        //Prevent duplicate runs when returning to this page
        if (timeClockInit) {
          clearInterval(timeClockInit);
        }
        timeClockInit = setInterval(function () {
          //Converting milliseconds to minutes and seconds
          var _time = (new Date().getTime() - timeStart) / 1000;
          if (_time >= timeLimit) {
            console.log('Page load timeout!');

            //Remove loader
            if (htmlCode.indexOf('<body') >= 0) {
              window.location.href = location.href;
            } else {
              hideLoader(container, $(htmlCode).filter('title').text(), btn, htmlCode);
            }

            // clear loader event
            clearInterval(timeClockInit);
            func();
          }
        }, 500);
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
          if (status == 404 || status == 405) window.location.href = url;
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request);

          //
          window.location.href = url;
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      });

      // Remove an interceptor later
      axios.interceptors.request.eject(axiosInterceptor);
    }

    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} container    - The target container to which the content will be added.
     * @param  {String} content      - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @param  {?Element} btn          - Current trigger button.
     * @return {Void}
     */
    function ajaxSucceeds(container, content, title, btn) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false;

      //Remove loader
      hideLoader(container, title, btn, content);
    }

    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title      - The title of a requested page.
     * @param  {?Element} btn      - Current trigger button.
           * @param  {String} content    - The data returned from the server
     * @return {Void}
     */
    function hideLoader(container, title, btn, content) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          });

          //The data returned from the server
          container.html(content).promise().done(function () {
            // Apply some asynchronism scripts
            $(document).UixApplyAsyncScripts();

            //Change the page title
            if (title) {
              document.title = title;
            }

            //Prevent multiple request on click
            if (btn) {
              btn.data('request-running', false);
            }
          });
        },
        //Determine the direction of a jQuery scroll event
        //Fix an issue for mousewheel event is too fast.
        delay: 0.5
      });
    }

    /*
     * Display loader
     *
     * @param  {Element} container       - The target container to which the content will be added.
     * @param  {String} loading         - Content of loading area.
     * @return {Void}
     */
    function showLoader(container, loading) {
      TweenMax.to(container.find('.ajax-content-loader'), 0.3, {
        css: {
          opacity: 1
        },
        ease: Power2.easeOut
      });
      container.html('<div class="ajax-content-loader">' + loading + '</div>').promise().done(function () {
        //loading animation
        loadingAnim(0);

        //loader effect from AJAX request
        TweenMax.set(container.find('.ajax-content-loader'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      });
    }
  };
  module.components.documentReady.push(module.AJAX_PUSH_CONTENT.documentReady);
  return /*#__PURE__*/_createClass(function AJAX_PUSH_CONTENT() {
    _classCallCheck(this, AJAX_PUSH_CONTENT);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/AJAX/js/index.js



/* 
 *************************************
 * <!-- Ajax Page Loader (Loading A Page via Ajax Into Div)  -->
 *************************************
 */



var AJAX_PAGE_LOADER = function (module, $, window, document) {
  if (window.AJAX_PAGE_LOADER === null) return false;
  module.AJAX_PAGE_LOADER = module.AJAX_PAGE_LOADER || {};
  module.AJAX_PAGE_LOADER.version = '0.2.1';
  module.AJAX_PAGE_LOADER.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //all images from pages
    var sources = [];

    //Added timer to prevent page loading errors for a long time
    var timeClockInit;

    //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.
    var quietPeriod = 500,
      //Do not change it
      animationTime = 1000,
      //According to page transition animation changes
      loaderRemoveDelay = 500,
      AJAXPageLinks = '[data-ajax-page]',
      $navs = $(AJAXPageLinks).parent().parent().find('li'),
      total = $navs.length,
      $sectionsContainer = $('.uix-ajax-load__fullpage-container'),
      ajaxContainer = '.ajax-container',
      curAjaxPageID = $(ajaxContainer).data('ajax-page-id');
    var lastAnimation = 0;

    // The progress of each page load, using global variables to accurately determine
    var loadedProgress = 0;

    //loading animation
    var loadingAnim = function loadingAnim(per) {
      $('#app-loading').text($('#app-loading').data('txt').replace(/\{progress\}/g, per));
    };

    //Prevent this module from loading in other pages
    if ($sectionsContainer.length == 0) return false;

    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */

    //Activate the first item
    if ($('.js-uix-ajax-load__container').length == 0) {
      moveTo($(ajaxContainer), false, 'down', 0, false);
    } else {
      //Activate navigation from AJAX request
      if ((0,esm_typeof/* default */.Z)(curAjaxPageID) != ( true ? "undefined" : 0)) $navs.eq(curAjaxPageID).addClass('is-active');
    }

    /* 
     ====================================================
     *  AJAX Interaction
     ====================================================
     */
    /*
     * Initialize the clickable ajax links
     *
     * @return {Void}
     */
    function ajaxInit() {
      if (windowWidth <= 768) {
        $(AJAXPageLinks).data('mobile-running', true);
      } else {
        $(AJAXPageLinks).data('mobile-running', false);
      }
    }
    ajaxInit();
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        ajaxInit();
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Call AJAX on click event for "single pages links"
     *
     */
    $(document).off('click.AJAX_PAGE_LOADER').on('click.AJAX_PAGE_LOADER', AJAXPageLinks, function (e) {
      //Prevents third-party plug-ins from triggering
      if ($(this).data('mobile-running')) {
        return;
      }
      e.preventDefault();

      // The progress of each page load
      loadedProgress = 0;

      //
      var $this = $(this);
      var curIndex = $this.attr('data-index');
      var curURL = $this.attr('href');

      //The currently URL of link
      if ((0,esm_typeof/* default */.Z)(curURL) === ( true ? "undefined" : 0)) {
        curURL = $this.closest('a').attr('href');
      }

      //Prevent multiple request on click
      if ($(AJAXPageLinks).data('request-running')) {
        return;
      }
      $(AJAXPageLinks).data('request-running', true);

      // Modify the URL without reloading the page
      if (history.pushState) {
        history.pushState(null, null, curURL);
      } else {
        location.hash = curURL;
      }

      //Click on this link element using an AJAX request
      var dir = $navs.filter('.is-active').find('> a').attr('data-index') > curIndex ? 'up' : 'down';
      moveTo($(ajaxContainer), curURL, dir, curIndex, false);
      return false;
    });

    //Detect URL change & Fire click event
    window.addEventListener('popstate', function (e) {
      var eleTarget = null,
        goURL = location.href;
      $(AJAXPageLinks).each(function () {
        //don't use $( this ).attr( 'href' )

        if (this.href === location.href) {
          eleTarget = this;
          goURL = this.href;
        }
      });

      //Empty content that does not exist
      if (eleTarget == null) {
        moveTo($(ajaxContainer), false, 'down', 0, false);
      }

      //Push new content to target container
      var pageIndex = $(eleTarget).data('index');

      //Push new content to target container
      if ((0,esm_typeof/* default */.Z)(pageIndex) != ( true ? "undefined" : 0)) {
        moveTo($(ajaxContainer), goURL, 'down', pageIndex, false);
      }

      // Output history button
      //console.log(  $( eleTarget ).data( 'index' ) );
    });

    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */
    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime();
      // Cancel scroll if currently animating or within quiet period
      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }
      if (dir == 'down') {
        //scroll down
        moveTo($(ajaxContainer), false, 'down', false, true);
      } else {
        //scroll up
        moveTo($(ajaxContainer), false, 'up', false, true);
      }
      lastAnimation = timeNow;
    }

    /*
     * Move Animation
     *
     * @param  {Element} container    - The instance returned from the request succeeds 
     * @param  {String} url          - The target URL via AJAX.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} customIndex  - User-specified index value, located on the corresponding AJAX hyperlink.
     * @param  {Boolean} wheel       - Whether to enable mouse wheel control.
     * @return {Void}
     */
    function moveTo(container, url, dir, customIndex, wheel) {
      var index = parseFloat($navs.filter('.is-active').find('> a').attr('data-index'));
      var isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null;

      //If there is a custom index, it is enabled first
      if (isNumeric.test(customIndex)) {
        nextIndex = customIndex;
      } else {
        if (dir == 'down' || dir === false) {
          nextIndex = index + 1;
        } else {
          nextIndex = index - 1;
        }
      }
      if (nextIndex <= parseFloat(total - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(total - 1)) nextIndex = parseFloat(total - 1);
        if (nextIndex < 0) nextIndex = 0;

        //Prevents third-party plug-ins from triggering
        if ($navs.eq(nextIndex).find('> a').data('mobile-running')) {
          return;
        }

        //Activate navigation from AJAX request
        $navs.removeClass('is-active');
        $navs.eq(nextIndex).addClass('is-active');

        //Use automatic indexing when no URLs come in.
        if (!url || (0,esm_typeof/* default */.Z)(url) === ( true ? "undefined" : 0)) {
          url = $navs.eq(nextIndex).find('> a').attr('href');
        }

        // Modify the URL without reloading the page when mouse wheel
        if (wheel) {
          var turl = $navs.eq(nextIndex).find('> a').attr('href');
          if (history.pushState) {
            history.pushState(null, null, url);
          } else {
            location.hash = turl;
          }
        }

        //Click on this link element using an AJAX request
        // Add a request or response interceptor
        var axiosInterceptor = axios.interceptors.request.use(function (config) {
          // Do something before request is sent

          //Display loader
          showLoader();

          //
          return config;
        }, function (error) {
          return Promise.reject(error);
        });

        // To send data in the application/x-www-form-urlencoded format instead
        var formData = new FormData();
        var defaultPostData = {
          action: 'load_singlepages_ajax_content'
        };
        for (var k in defaultPostData) {
          formData.append(k, defaultPostData[k]);
        }

        /*
        // For multiple form fields data acquisition
        const formData = new FormData();
        const oldFormData = $this.serializeArray();
        oldFormData.forEach(function(item){
            formData.append(item.name, item.value);
        });
        formData.append('action', 'load_singlepages_ajax_content');
        */

        // Create a request event
        axios({
          timeout: 15000,
          method: (0,esm_typeof/* default */.Z)(container.data('ajax-method')) === ( true ? "undefined" : 0) ? 'POST' : container.data('ajax-method'),
          url: url,
          data: formData,
          responseType: 'text'
        }).then(function (response) {
          var htmlCode = response.data;

          //A function to be called if the request succeeds
          //Display loading image when AJAX call is in progress

          //Remove existing images
          sources = [];

          //Push all images from page
          $(htmlCode).find('img').each(function () {
            sources.push({
              "url": this.src,
              "id": 'img-' + UixGUID.create(),
              "type": 'img'
            });
          });

          //Push all videos from page
          $(htmlCode).find('.uix-video__slider > video').each(function () {
            var _src = $(this).find('source:first').attr('src');
            if ((0,esm_typeof/* default */.Z)(_src) === ( true ? "undefined" : 0)) _src = $(this).attr('src');
            sources.push({
              "url": _src,
              "id": 'video-' + UixGUID.create(),
              "type": 'video'
            });
          });

          //Execute after all images have loaded
          var per;
          var perInit = 1;
          if (sources.length == 0) {
            per = 100;

            //loading animation
            loadingAnim(per);

            //Remove loader
            var oldContent = container.html();
            hideLoader(container, $(htmlCode).filter('title').text(), dir, oldContent, htmlCode);
          }
          var loadImages = function loadImages() {
            var promises = [];
            var _loop = function _loop(i) {
              if (sources[i].type == 'img') {
                ///////////
                // IMAGE //
                ///////////   

                promises.push(new Promise(function (resolve, reject) {
                  var img = document.createElement("img");
                  img.src = sources[i].url;
                  img.onload = function (image) {
                    //Compatible with safari and firefox
                    if ((0,esm_typeof/* default */.Z)(image.path) === ( true ? "undefined" : 0)) {
                      return resolve(image.target.currentSrc);
                    } else {
                      return resolve(image.path[0].currentSrc);
                    }
                  };
                }).then(textureLoaded));
              } else {
                ///////////
                // VIDEO //
                ///////////    

                promises.push(new Promise(function (resolve, reject) {
                  $('#' + sources[i].id).one('loadedmetadata', resolve);
                  return resolve(sources[i].url);
                }).then(textureLoaded));
              }
            };
            for (var i = 0; i < sources.length; i++) {
              _loop(i);
            }
            return Promise.all(promises);
          };
          var textureLoaded = function textureLoaded(url) {
            //loading
            per = parseInt(100 * (perInit / sources.length));
            console.log('progress: ' + per + '%');
            if (isNaN(per)) per = 100;

            // The progress of each page load
            loadedProgress = per;

            //loading animation
            loadingAnim(per);
            var texture = null;
            perInit++;
            return per;
          };
          var func = function func() {
            ajaxSucceeds(dir, container, $(htmlCode).find('.js-uix-ajax-load__container').html(), $(htmlCode).filter('title').text());
          };

          //images loaded
          //Must be placed behind the loadImages()
          loadImages().then(function (images) {
            clearInterval(timeClockInit);
            func();
          });

          //Calculating page load time
          var timeLimit = 10,
            timeStart = new Date().getTime();

          //Prevent duplicate runs when returning to this page
          if (timeClockInit) {
            clearInterval(timeClockInit);
          }
          timeClockInit = setInterval(function () {
            //Converting milliseconds to minutes and seconds
            var _time = (new Date().getTime() - timeStart) / 1000;
            if (_time >= timeLimit) {
              console.log('Page load timeout!');

              //Remove loader
              if (htmlCode.indexOf('<body') >= 0) {
                window.location.href = location.href;
              } else {
                var _oldContent = container.html();
                hideLoader(container, $(htmlCode).filter('title').text(), dir, _oldContent, htmlCode);
              }

              // clear loader event
              clearInterval(timeClockInit);
              func();
            }
          }, 500);
        })["catch"](function (error) {
          if (error.response) {
            // The request was made and the server responded with a status code
            // that falls out of the range of 2xx
            var status = error.response.status;
            console.log(status);
            if (status == 404 || status == 405) window.location.href = url;
          } else if (error.request) {
            // The request was made but no response was received
            // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
            // http.ClientRequest in node.js
            console.log(error.request);

            //
            window.location.href = url;
          } else {
            // If there was a problem, we need to
            // dispatch the error condition
            console.log(error.message);
          }
        });

        // Remove an interceptor later
        axios.interceptors.request.eject(axiosInterceptor);
      }
    }

    /*
     * A function to be called if the request succeeds
     *
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {Element} container - The instance returned from the request succeeds
     * @param  {String} content   - The data returned from the server
     * @param  {String} title        - The title of a requested page.
     * @return {Void}
     */
    function ajaxSucceeds(dir, container, content, title) {
      //If the page resource is not loaded, then the following code is not executed
      if (loadedProgress < 100) return false;

      //Remove loader
      var oldContent = container.html();
      hideLoader(container, title, dir, oldContent, content);
    }

    /*
     * Remove loader
     *
           * @param  {Element} container - The instance returned from the request succeeds
           * @param  {String} title     - The title of a requested page.
     * @param  {String} dir       - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent   - The old data returned from the server
           * @param  {String} content   - The data returned from the server
     * @return {Void}
     */
    function hideLoader(container, title, dir, oldContent, content) {
      TweenMax.to('.uix-ajax-load__loader', 0.5, {
        alpha: 0,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            css: {
              'display': 'none'
            }
          });

          //The data returned from the server
          container.html(content).promise().done(function () {
            //Transition effect between two elements.
            eleTransitionEff(dir, oldContent, content);

            //Change the page title
            if (title) {
              document.title = title;
            }

            //Prevent multiple request on click
            $(AJAXPageLinks).data('request-running', false);
          });
        },
        delay: loaderRemoveDelay / 1000
      });
    }

    /*
     * Display loader
     *
     * @return {Void}
     */
    function showLoader() {
      //loading animation
      loadingAnim(0);

      //loader effect from AJAX request
      TweenMax.set('.uix-ajax-load__loader', {
        css: {
          'display': 'block'
        },
        onComplete: function onComplete() {
          TweenMax.to(this.target, 0.5, {
            alpha: 1
          });
        }
      });
    }

    /*
     * Transition effect between two elements.
     *
     * @param  {String} dir            - Gets a value that indicates the amount that the mouse wheel has changed.
     * @param  {String} oldContent     - A string of HTML to set as the content of matched old element.
     * @param  {String} newContent     - A string of HTML to set as the content of matched new element.
     * @return {Void}
     */
    function eleTransitionEff(dir, oldContent, newContent) {
      var $originalItem = $sectionsContainer.find('> section'),
        $cloneItem = $originalItem.clone();

      //Reset the original element
      $originalItem.css({
        'z-index': 1
      });

      //Clone the last element to the first position
      $cloneItem.prependTo($sectionsContainer).css({
        'z-index': 2,
        'transform': 'translateY(' + (dir == 'down' || dir === false ? windowHeight : -windowHeight) + 'px)'
      })
      //Add the latest content to the new container
      .find(ajaxContainer).html(newContent);
      $originalItem.first().find(ajaxContainer).html(oldContent).promise().done(function () {
        TweenMax.to($originalItem.first(), animationTime / 1000, {
          y: dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2,
          ease: Power2.easeOut
        });
        TweenMax.to($cloneItem, animationTime / 1000, {
          y: 0,
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Remove duplicate elements
            $originalItem.first().remove();

            // Apply some asynchronism scripts
            $(document).UixApplyAsyncScripts();
          }
        });
      });
    }

    /* 
     ====================================================
     *  Mouse Wheel Method
     ====================================================
     */
    var startY = 0;
    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;
      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };
    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
        delta,
        mobileDeltaY = null;
      var touches = e.touches;
      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }
      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }
        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }
      scrollMoveInit(e, dir);
    };
    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
  };
  module.components.documentReady.push(module.AJAX_PAGE_LOADER.documentReady);
  return /*#__PURE__*/_createClass(function AJAX_PAGE_LOADER() {
    _classCallCheck(this, AJAX_PAGE_LOADER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/ScrollToPlugin.js

/*!
 * VERSION: 1.9.2
 * DATE: 2019-02-07
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/
/* eslint-disable */


var _doc = (esm_TweenLite/* _gsScope.document */.ML.document || {}).documentElement,
  _window = esm_TweenLite/* _gsScope */.ML,
  _max = function _max(element, axis) {
    var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim,
      body = document.body;
    return element === _window || element === _doc || element === body ? Math.max(_doc[scroll], body[scroll]) - (_window["inner" + dim] || _doc[client] || body[client]) : element[scroll] - element["offset" + dim];
  },
  _unwrapElement = function _unwrapElement(value) {
    if (typeof value === "string") {
      value = TweenLite.selector(value);
    }
    if (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {
      value = value[0];
    }
    return value === _window || value.nodeType && value.style ? value : null;
  },
  _buildGetter = function _buildGetter(e, axis) {
    //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
    var p = "scroll" + (axis === "x" ? "Left" : "Top");
    if (e === _window) {
      if (e.pageXOffset != null) {
        p = "page" + axis.toUpperCase() + "Offset";
      } else if (_doc[p] != null) {
        e = _doc;
      } else {
        e = document.body;
      }
    }
    return function () {
      return e[p];
    };
  },
  _getOffset = function _getOffset(element, container) {
    var rect = _unwrapElement(element).getBoundingClientRect(),
      b = document.body,
      isRoot = !container || container === _window || container === b,
      cRect = isRoot ? {
        top: _doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0),
        left: _doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)
      } : container.getBoundingClientRect(),
      offsets = {
        x: rect.left - cRect.left,
        y: rect.top - cRect.top
      };
    if (!isRoot && container) {
      //only add the current scroll position if it's not the window/body.
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }
    return offsets;
    /*	PREVIOUS
    var rect = _unwrapElement(element).getBoundingClientRect(),
    	isRoot = (!container || container === _window || container === document.body),
    	cRect = (isRoot ? _doc : container).getBoundingClientRect(),
    	offsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};
    if (!isRoot && container) { //only add the current scroll position if it's not the window/body.
    	offsets.x += _buildGetter(container, "x")();
    	offsets.y += _buildGetter(container, "y")();
    }
    return offsets;
    */
  },
  _parseVal = function _parseVal(value, target, axis, currentVal) {
    var type = (0,esm_typeof/* default */.Z)(value);
    return !isNaN(value) ? parseFloat(value) : type === "string" && value.charAt(1) === "=" ? parseInt(value.charAt(0) + "1", 10) * parseFloat(value.substr(2)) + currentVal : value === "max" ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);
  },
  ScrollToPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
    propName: "scrollTo",
    API: 2,
    global: true,
    version: "1.9.2",
    //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
    init: function init(target, value, tween) {
      this._wdw = target === _window;
      this._target = target;
      this._tween = tween;
      if ((0,esm_typeof/* default */.Z)(value) !== "object") {
        value = {
          y: value
        }; //if we don't receive an object as the parameter, assume the user intends "y".
        if (typeof value.y === "string" && value.y !== "max" && value.y.charAt(1) !== "=") {
          value.x = value.y;
        }
      } else if (value.nodeType) {
        value = {
          y: value,
          x: value
        };
      }
      this.vars = value;
      this._autoKill = value.autoKill !== false;
      this.getX = _buildGetter(target, "x");
      this.getY = _buildGetter(target, "y");
      this.x = this.xPrev = this.getX();
      this.y = this.yPrev = this.getY();
      if (value.x != null) {
        this._addTween(this, "x", this.x, _parseVal(value.x, target, "x", this.x) - (value.offsetX || 0), "scrollTo_x", true);
        this._overwriteProps.push("scrollTo_x");
      } else {
        this.skipX = true;
      }
      if (value.y != null) {
        this._addTween(this, "y", this.y, _parseVal(value.y, target, "y", this.y) - (value.offsetY || 0), "scrollTo_y", true);
        this._overwriteProps.push("scrollTo_y");
      } else {
        this.skipY = true;
      }
      return true;
    },
    //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
    set: function set(v) {
      this._super.setRatio.call(this, v);
      var x = this._wdw || !this.skipX ? this.getX() : this.xPrev,
        y = this._wdw || !this.skipY ? this.getY() : this.yPrev,
        yDif = y - this.yPrev,
        xDif = x - this.xPrev,
        threshold = ScrollToPlugin.autoKillThreshold;
      if (this.x < 0) {
        //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
        this.x = 0;
      }
      if (this.y < 0) {
        this.y = 0;
      }
      if (this._autoKill) {
        //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
        if (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, "x")) {
          this.skipX = true; //if the user scrolls separately, we should stop tweening!
        }

        if (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, "y")) {
          this.skipY = true; //if the user scrolls separately, we should stop tweening!
        }

        if (this.skipX && this.skipY) {
          this._tween.kill();
          if (this.vars.onAutoKill) {
            this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);
          }
        }
      }
      if (this._wdw) {
        _window.scrollTo(!this.skipX ? this.x : x, !this.skipY ? this.y : y);
      } else {
        if (!this.skipY) {
          this._target.scrollTop = this.y;
        }
        if (!this.skipX) {
          this._target.scrollLeft = this.x;
        }
      }
      this.xPrev = this.x;
      this.yPrev = this.y;
    }
  }),
  ScrollToPlugin_p = ScrollToPlugin.prototype;
ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;
ScrollToPlugin.autoKillThreshold = 7;
ScrollToPlugin_p._kill = function (lookup) {
  if (lookup.scrollTo_x) {
    this.skipX = true;
  }
  if (lookup.scrollTo_y) {
    this.skipY = true;
  }
  return this._super._kill.call(this, lookup);
};

;// CONCATENATED MODULE: ./src/components/back-to-top/js/index.js


/* 
 *************************************
 * <!-- Back to Top -->
 *************************************
 */



var BACK_TO_TOP = function (module, $, window, document) {
  if (window.BACK_TO_TOP === null) return false;
  module.BACK_TO_TOP = module.BACK_TO_TOP || {};
  module.BACK_TO_TOP.version = '0.1.0';
  module.BACK_TO_TOP.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    $('<a href="#" id="uix-to-top"><i class="fa fa-arrow-up" aria-hidden="true"></i></a>').appendTo('body');
    $.when($('#uix-to-top').length > 0).then(function () {
      //-------- Sticky button of back to top 
      var $el = $('#uix-to-top');
      function scrollUpdate() {
        var scrolled = $(window).scrollTop(),
          spyTop = windowHeight / 2;
        if (scrolled >= spyTop) {
          $el.addClass('is-active');
        } else {
          $el.removeClass('is-active');
        }
      }

      // Add function to the element that should be used as the scrollable area.
      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();

      //-------- Click event of back button
      $el.off('click').on('click', function (e) {
        e.preventDefault();
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: 0,
            //y: "max" --> vertical scroll to bottom
            autoKill: false
          },
          ease: Power2.easeOut
        });
        return false;
      });
    });
  };
  module.components.documentReady.push(module.BACK_TO_TOP.documentReady);
  return /*#__PURE__*/_createClass(function BACK_TO_TOP() {
    _classCallCheck(this, BACK_TO_TOP);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/circle-layout/js/index.js



/* 
 *************************************
 * <!-- Circle Layout -->
 *************************************
 */


var CIRCLE_LAYOUT = function (module, $, window, document) {
  if (window.CIRCLE_LAYOUT === null) return false;
  module.CIRCLE_LAYOUT = module.CIRCLE_LAYOUT || {};
  module.CIRCLE_LAYOUT.version = '0.0.1';
  module.CIRCLE_LAYOUT.documentReady = function ($) {
    $('.js-uix-circle-layout').each(function (id) {
      var $this = $(this);
      var $ul = $this.find('> ul'),
        $li = $ul.find('> li'),
        liWidth = $li.first().outerWidth(),
        liHeight = $li.first().outerHeight();
      var display = $this.data('circle-layout-display'),
        radius = $this.data('circle-layout-radius'),
        radius2 = $this.data('circle-layout-radius-c'),
        rotation = $this.data('circle-layout-rotation');
      if ((0,esm_typeof/* default */.Z)(display) === ( true ? "undefined" : 0)) {
        display = 5;
      }
      if ((0,esm_typeof/* default */.Z)(radius) === ( true ? "undefined" : 0)) {
        radius = 180;
      }
      if ((0,esm_typeof/* default */.Z)(radius2) === ( true ? "undefined" : 0)) {
        radius2 = 110;
      }
      if ((0,esm_typeof/* default */.Z)(rotation) === ( true ? "undefined" : 0)) {
        rotation = 0;
      }
      $this.css({
        'width': radius * 2 + 'px'
      });
      $ul.css({
        'width': radius * 2 + 'px',
        'height': radius * 2 + 'px',
        'transform': 'rotate(' + parseFloat(rotation) + 'deg)'
      });
      $ul.next('div').css({
        'width': radius2 * 2 + 'px',
        'height': radius2 * 2 + 'px'
      });

      //Layout components in a circle layout
      var step = 2 * Math.PI / display,
        pad = $ul.width();
      var angle = 0,
        transitionDelay = 0;
      $li.each(function () {
        //Can'nt use arrow function here!!!
        // 'this' works differently with arrow fucntions
        var el = $(this),
          x = radius * Math.cos(angle) - liWidth / 2,
          y = radius * Math.sin(angle) - liHeight / 2;
        el.css({
          'transform': 'translate(' + parseFloat(x + liWidth / 2) + 'px,' + parseFloat(pad / 2 + y + liHeight / 2) + 'px)',
          'transition-delay': transitionDelay + "s"
        }).find('> a').css({
          'transform': 'rotate(' + parseFloat(-rotation) + 'deg)'
        });
        angle += step;
        transitionDelay += 0.15;
      });
    });
  };
  module.components.documentReady.push(module.CIRCLE_LAYOUT.documentReady);
  return /*#__PURE__*/_createClass(function CIRCLE_LAYOUT() {
    _classCallCheck(this, CIRCLE_LAYOUT);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/counter/js/fn/count-to.js
var count_to = __webpack_require__(798);
;// CONCATENATED MODULE: ./src/components/counter/js/index.js



/* 
 *************************************
 * <!-- Counter -->
 *************************************
 */


var COUNTER = function (module, $, window, document) {
  if (window.COUNTER === null) return false;
  module.COUNTER = module.COUNTER || {};
  module.COUNTER.version = '0.0.6';
  module.COUNTER.documentReady = function ($) {
    var $scrollElements = $('[data-counter-number]');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this);

      //
      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top;

        //Prevent asynchronous loading of repeated calls
        var actived = $el.data('activated');
        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            $el.UixCountTo();

            //Prevents front-end javascripts that are activated in the background to repeat loading.
            $el.data('activated', 1);
          } //endif actived
        }
      };

      // Add function to the element that should be used as the scrollable area.
      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
    }); //end each        
  };

  module.components.documentReady.push(module.COUNTER.documentReady);
  return /*#__PURE__*/_createClass(function COUNTER() {
    _classCallCheck(this, COUNTER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/dropdown-menu/js/index.js



/* 
 *************************************
 * <!-- Dropdown Menu -->
 *************************************
 */


var DROPDOWN_MENU = function (module, $, window, document) {
  if (window.DROPDOWN_MENU === null) return false;
  module.DROPDOWN_MENU = module.DROPDOWN_MENU || {};
  module.DROPDOWN_MENU.version = '0.0.7';
  module.DROPDOWN_MENU.documentReady = function ($) {
    //Initialize option status
    $('.uix-dropdown-menu').each(function () {
      var v = $(this).find('input[type="hidden"]').val(),
        selectedIndex = $(this).find('ul > li > a[data-value="' + v + '"]').parent().index(),
        $li = $(this).find('ul > li');
      $li.removeClass('is-active');
      $li.eq(selectedIndex).addClass('is-active');
      $(this).find('> summary > span').html($li.eq(selectedIndex).find('> a').data('display-text'));
    });

    //Create a trigger of Dropdown Menu on Click
    //Use $( document ) to support other click events for ajax
    $(document).off('click.DROPDOWN_MENU').on('click.DROPDOWN_MENU', '.uix-dropdown-menu > summary', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).parent('.uix-dropdown-menu');
      $this.toggleClass('is-opened');
    });
    $(document).off('click.DROPDOWN_MENU_LINK').on('click.DROPDOWN_MENU_LINK', '.uix-dropdown-menu li a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var $this = $(this).closest('.uix-dropdown-menu');
      if ($this.hasClass('is-opened')) {
        $this.removeAttr('open').removeClass('is-opened');
      }
      if ((0,esm_typeof/* default */.Z)($(this).attr('data-value')) != ( true ? "undefined" : 0) && $(this).attr('data-value') != '') {
        $this.find('input[type="hidden"]').val($(this).attr('data-value'));
      }
      if ((0,esm_typeof/* default */.Z)($(this).data('display-text')) != ( true ? "undefined" : 0) && $(this).data('display-text') != '') {
        $this.find('> summary > span').html($(this).data('display-text'));
      }

      // update active status
      $this.find('li').removeClass('is-active');
      $(this).parent().addClass('is-active');
    });

    //Close the target
    //Do not add off() to this
    $(document.body).on('click', function (e) {
      //Apply click method to outer div but not inner div
      if (!$(e.target.offsetParent).hasClass('uix-dropdown-menu')) {
        $('.uix-dropdown-menu').removeAttr('open').removeClass('is-opened');
      }
    });
  };
  module.components.documentReady.push(module.DROPDOWN_MENU.documentReady);
  return /*#__PURE__*/_createClass(function DROPDOWN_MENU() {
    _classCallCheck(this, DROPDOWN_MENU);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/dropdown-menu2/js/index.js


/* 
 *************************************
 * <!-- Dropdown Menu 2 (Multi-level drop-down navigation) -->
 *************************************
 */


var DROPDOWN_MENU2 = function (module, $, window, document) {
  if (window.DROPDOWN_MENU2 === null) return false;
  module.DROPDOWN_MENU2 = module.DROPDOWN_MENU2 || {};
  module.DROPDOWN_MENU2.version = '0.0.5';
  module.DROPDOWN_MENU2.documentReady = function ($) {
    var $verticalMenuLi = $('.uix-vertical-menu li');
    $verticalMenuLi.find('> a').off('click').on('click', function (e) {
      var $sub = $(this).next('ul');
      if ($sub.length > 0) {
        e.preventDefault();

        //Its value is not a boolean but a string
        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;
        if (expanded) {
          //Hide other all sibling <ul> of the selected element
          var $e = $(this).parent('li').siblings().find('> a');
          $e.removeClass('is-active').attr('aria-expanded', false);
          $(this).addClass('is-active').attr('aria-expanded', true);
          TweenMax.to($e.next('ul'), 0.5, {
            height: 0
          });

          //to open
          // - temporarilty set height:auto
          // - tween from height:0
          TweenMax.set($sub, {
            height: 'auto'
          });
          TweenMax.from($sub, 0.5, {
            height: 0
          });
        } else {
          $(this).removeClass('is-active').attr('aria-expanded', false);

          //to close
          TweenMax.to($sub, 0.5, {
            height: 0
          });
        }
        return false;
      }
    });

    //Add multilevel indicator arrow
    if ($verticalMenuLi.find('> a .uix-vertical-menu__arrow').length == 0) {
      $verticalMenuLi.find('> a').append('<span class="uix-vertical-menu__arrow"></span>');
    }
    $verticalMenuLi.each(function () {
      var len = $(this).find('ul').length;
      if (len == 0) {
        $(this).children('a').children('.uix-vertical-menu__arrow').hide();
      }
    });
  };
  module.components.documentReady.push(module.DROPDOWN_MENU2.documentReady);
  return /*#__PURE__*/_createClass(function DROPDOWN_MENU2() {
    _classCallCheck(this, DROPDOWN_MENU2);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/cascading-dropdown-list/js/index.js



/* 
 *************************************
 * <!-- Cascading DropDown List -->
 *************************************
 */


var CASCADING_DD_LIST = function (module, $, window, document) {
  if (window.CASCADING_DD_LIST === null) return false;
  module.CASCADING_DD_LIST = module.CASCADING_DD_LIST || {};
  module.CASCADING_DD_LIST.version = '0.2.1';
  module.CASCADING_DD_LIST.documentReady = function ($) {
    var curControls = '.uix-cascading-dropdown-list';
    var wrapperDepth = $(curControls).length === 0 ? 1 : $(curControls).length + 1;
    $(curControls).each(function () {
      wrapperDepth--;
      var cid = UixGUID.create();
      var $control = $(this);
      var actived = $control.data('activated');
      $control.attr('id', 'app-' + cid);

      //
      var ajaxURL = $control.data('cascading-dd-json'),
        ajaxMethod = $control.data('cascading-dd-method'),
        loadingTmpl = $control.data('cascading-dd-loading-tmpl');
      if ((0,esm_typeof/* default */.Z)(ajaxURL) === ( true ? "undefined" : 0)) ajaxURL = '';
      if ((0,esm_typeof/* default */.Z)(ajaxMethod) === ( true ? "undefined" : 0)) ajaxMethod = 'POST';
      if ((0,esm_typeof/* default */.Z)(loadingTmpl) === ( true ? "undefined" : 0)) loadingTmpl = '<div>loading...</div>';
      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        // Methods
        //------------------------------------------
        var loadingAnim = function loadingAnim() {
          var $loadingWrapper = $control.find('.uix-cascading-dropdown-list__loading__wrapper');
          if ($control.data('loading')) {
            $loadingWrapper.html(loadingTmpl);
          } else {
            $loadingWrapper.html('');
          }
        }; //
        var handleInitControl = function handleInitControl() {
          var firstLevelItems = [];
          $control.data('ajaxOptions').forEach(function (item) {
            firstLevelItems.push({
              "id": item.id,
              "name": item.name
            });
          });

          //
          $control.data({
            'data': [$control.data('ajaxOptions')],
            'firstLevelItems': [firstLevelItems]
          });

          // update result to input
          $resInput.val('');
        }; //
        var queryResultOfJSON = function queryResultOfJSON(data, targetVal, returnType) {
          var callbackValueNested = [];
          var lastFirstLevelName = '';
          var loop = true;
          var resDepth = 0;
          var getIndexOf = function getIndexOf(arr, val) {
            for (var i = 0; i < arr.length; i++) {
              if (arr[i].id.toString() === val.toString()) {
                return i;
              }
            }
            return -1;
          };
          var searchJsonStr = function searchJsonStr(list, depth) {
            // `depth` is very important, it is used to accurately judge the final result
            if (typeof depth === 'undefined') {
              depth = 0;
            } else {
              depth++;
            }

            //    
            for (var i = 0; i < list.length; i++) {
              var row = list[i];
              var callbackValue = returnType === 'key' ? row.id.toString() : row.name.toString();
              if (loop) {
                // get first-level item
                if (getIndexOf(data, row.id) !== -1) {
                  callbackValueNested.push(callbackValue);
                  lastFirstLevelName = callbackValue;
                }

                // get child-level item
                if (row.children) {
                  callbackValueNested.push(callbackValue);
                }
              }

              //check the value
              if (row.id.toString() === targetVal.toString()) {
                callbackValueNested.push(callbackValue);
                loop = false;
                resDepth = depth;
                break;
              }

              // Note: Recursion must be placed here
              if (loop) {
                if (row.children) {
                  searchJsonStr(row.children, depth);
                }
              }
            }
          };
          searchJsonStr(data);

          // (1) Remove duplicate values
          //------------------------------------------
          callbackValueNested = callbackValueNested.filter(function (item, index, arr) {
            return arr.indexOf(item, 0) === index;
          });

          // (2) Delete needless first-level
          //------------------------------------------
          var resAll = callbackValueNested.slice(callbackValueNested.indexOf(lastFirstLevelName), callbackValueNested.length);

          // (3) Returns result
          //------------------------------------------
          if (resAll.length > 1) {
            // Get first-level item
            resAll.splice(1);

            // Get child-level item
            var resChild = callbackValueNested.slice(-resDepth); // Get the last elements in reverse

            // Combine
            resAll = resAll.concat(resChild);
          }
          return resAll;
        }; //
        var setValue = function setValue(arr, targetVal) {
          // update result to input
          $resInput.val(targetVal);

          //search JSON key that contains specific string
          $control.data({
            'selectedData': {
              labels: queryResultOfJSON(arr, targetVal, 'value'),
              values: queryResultOfJSON(arr, targetVal, 'key')
            }
          });
        }; //
        var handleClickItem = function handleClickItem(resValue, index, level) {
          console.log('resValue: ', resValue, ' | index: ', index, ' | level: ', level);

          // update value
          setValue($control.data('ajaxOptions'), resValue.id);

          // active the selected item
          var markCurrent = function markCurrent(arr, index) {
            for (var i = 0; i < arr.length; i++) {
              if (i === index) {
                arr[i].current = true;
              } else {
                arr[i].current = false;
              }
            }
          };

          // deactivate all items
          var markAllItems = function markAllItems(arr) {
            for (var i = 0; i < arr.length; i++) {
              arr[i].current = false;
            }
          };

          //
          var newData = $control.data('data'); // such as: [Array(6), Array(3)]
          //console.log( 'newData: ', newData );

          // All the elements from start(array.length - start) to the end of the array will be deleted.
          newData.splice(level + 1);
          if (resValue.children) {
            var childList = resValue.children;
            markAllItems(childList);
            newData[level + 1] = childList;
          }

          //
          $control.data({
            'data': newData
          });
          markCurrent(newData[level], index);
        }; //
        var handleDisplayOptions = function handleDisplayOptions(e) {
          e.preventDefault();
          $control.data({
            'isShow': !$control.data('isShow')
          });
        }; // If clicked on outside of element
        var handleClickOutside = function handleClickOutside(event) {
          if (event.target.className != '' && event.target.className.indexOf('uix-cascading-dropdown-list__trigger') < 0 && event.target.className.indexOf('uix-cascading-dropdown-list__items') < 0 && event.target.className.indexOf('uix-cascading-dropdown-list__opt') < 0) {
            $control.data({
              'isShow': false
            });
          }
        }; // Rendering component
        var render = function render() {
          var isShow = $control.data('isShow');
          var data = $control.data('data');

          //for wrapper
          if (isShow) {
            var items = '';
            data.map(function (item, level) {
              var options = '';
              item.map(function (option, optionIndex) {
                options += '<div class="' + (option.current ? 'uix-cascading-dropdown-list__opt is-active' : 'uix-cascading-dropdown-list__opt') + '" data-level="' + level + '" data-value=\'' + JSON.stringify(option) + '\' data-index="' + optionIndex + '">' + option.name + '</div>';
              });
              items += '<li>' + options + '</li>';
            });
            $listWrapper.html("\n                        <div class=\"uix-cascading-dropdown-list__items\">\n                            <ul>\n                                " + items + "\n                            </ul>\n            \n                        </div>\n                        ");
          } else {
            $listWrapper.html('');
          }

          //for options
          var selectedData = $control.data('selectedData');
          var displayInfo = '';
          if (selectedData.labels) {
            selectedData.labels.map(function (item, i, arr) {
              var _input = '<input name="' + fieldName + '-node[]" type="hidden" value="' + selectedData.values[i] + '"/>';
              if (arr.length - 1 === i) {
                displayInfo += '<span>' + item + '' + _input + '</span>';
              } else {
                displayInfo += '<span>' + item + '' + _input + '</span><svg viewBox="0 0 22 22" width="8"><path d="m345.44 248.29l-194.29 194.28c-12.359 12.365-32.397 12.365-44.75 0-12.354-12.354-12.354-32.391 0-44.744l171.91-171.91-171.91-171.9c-12.354-12.359-12.354-32.394 0-44.748 12.354-12.359 32.391-12.359 44.75 0l194.29 194.28c6.177 6.18 9.262 14.271 9.262 22.366 0 8.099-3.091 16.196-9.267 22.373" transform="matrix(.03541-.00013.00013.03541 2.98 3.02)" fill="#a5a5a5"/></svg>';
              }
            });
          }
          $eachResWrapper.html(displayInfo);
        }; // Initialize status
        //------------------------------------------
        //Initialize HTML structure
        $control.append("\n                    <em class=\"uix-cascading-dropdown-list__result\"></em>\n                    <span class=\"uix-cascading-dropdown-list__items__wrapper\"></span>\n                    <span class=\"uix-cascading-dropdown-list__loading__wrapper\"></span>    \n                ");

        //
        var $listWrapper = $control.find('.uix-cascading-dropdown-list__items__wrapper');
        var $resInput = $control.find('input.uix-cascading-dropdown-list__res');
        var $eachResWrapper = $control.find('.uix-cascading-dropdown-list__result');
        var fieldName = typeof $resInput.attr('name') === 'undefined' ? 'auto-name-' + cid : $resInput.attr('name');
        var defaultVal = $resInput.val(); //the default value is STRING

        /*
        // If the final result is a comma separated string, like this: `value1,value2`
        if (defaultVal) {
            defaultVal.trim().replace(/^\,|\,$/g, '').split(',').forEach((item, index) => {
                 // do something
            });
        }
        */

        //init data
        $control.data({
          'ajaxOptions': [],
          'firstLevelItems': [],
          'loading': true,
          //for variable field
          'data': [],
          'selectedData': {
            labels: [],
            values: []
          },
          'isShow': false
        });

        //loading
        loadingAnim();

        //Initialize input
        $resInput.attr({
          'type': 'hidden',
          'name': fieldName
        });

        //Initialize wrapper depth
        $control.css('z-index', wrapperDepth);

        // Get data of asynchronous request
        //------------------------------------------
        var req = ajaxMethod.toLowerCase() === 'get' ? axios.get(ajaxURL) : axios.post(ajaxURL);
        var allData = null;
        req.then(function (res) {
          allData = res.data;
          $control.data({
            'loading': false
          });

          //loading
          loadingAnim();
          if (allData !== undefined) {
            $control.data({
              'ajaxOptions': allData
            });

            //Initialize options 
            handleInitControl();

            //Set a default value
            if (defaultVal) setValue(allData, defaultVal);

            //Rendering component
            render();
          }
        });

        // Mouse Events
        //------------------------------------------
        //Trigger event 
        $(document).off('click.CASCADING_DROPDOWNLIST_TRIGGER' + cid).on('click.CASCADING_DROPDOWNLIST_TRIGGER' + cid, "#".concat('app-' + cid, " .uix-cascading-dropdown-list__trigger"), function (e) {
          handleDisplayOptions(e);

          //Rendering component
          render();
        });

        //Options event
        $(document).off('click.CASCADING_DROPDOWNLIST_OPTIONS_OPEN' + cid).on('click.CASCADING_DROPDOWNLIST_OPTIONS_OPEN' + cid, "#".concat('app-' + cid, " .uix-cascading-dropdown-list__opt"), function (e) {
          var _level = $(this).data('level');
          var _value = $(this).data('value');
          var _index = $(this).data('index');
          handleClickItem(_value, _index, _level);

          //Rendering component
          render();
        });

        //Hide options event
        //Do not add off() to this
        $(document).on('click.CASCADING_DROPDOWNLIST_CLOSE', function (e) {
          handleClickOutside(e);

          //Rendering component
          render();
        });

        //------------------------------------------

        //Prevents front-end javascripts that are activated in the background to repeat loading.
        $control.data('activated', 1);
      } //endif actived			
    });
  };

  module.components.documentReady.push(module.CASCADING_DD_LIST.documentReady);
  return /*#__PURE__*/_createClass(function CASCADING_DD_LIST() {
    _classCallCheck(this, CASCADING_DD_LIST);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/flexslider/js/third-party/jquery.flexslider.js

/*
 * jQuery FlexSlider v2.7.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
(function ($) {
  var focused = true;

  //FlexSlider: Object Instance
  $.flexslider = function (el, options) {
    var slider = $(el);

    // making variables public

    //if rtl value was not passed and html is in rtl..enable it by default.
    if (typeof options.rtl == 'undefined' && $('html').attr('dir') == 'rtl') {
      options.rtl = true;
    }
    slider.vars = $.extend({}, $.flexslider.defaults, options);
    var namespace = slider.vars.namespace,
      msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
      touch = ("ontouchstart" in window || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
      // deprecating this idea, as devices are being released with both of these events
      eventType = "click touchend MSPointerUp keyup",
      watchedEvent = "",
      watchedEventClearTimer,
      vertical = slider.vars.direction === "vertical",
      reverse = slider.vars.reverse,
      carousel = slider.vars.itemWidth > 0,
      fade = slider.vars.animation === "fade",
      asNav = slider.vars.asNavFor !== "",
      methods = {};

    // Store a reference to the slider object
    $.data(el, "flexslider", slider);

    // Private slider methods
    methods = {
      init: function init() {
        slider.animating = false;
        // Get current slide and make sure it is a number
        slider.currentSlide = parseInt(slider.vars.startAt ? slider.vars.startAt : 0, 10);
        if (isNaN(slider.currentSlide)) {
          slider.currentSlide = 0;
        }
        slider.animatingTo = slider.currentSlide;
        slider.atEnd = slider.currentSlide === 0 || slider.currentSlide === slider.last;
        slider.containerSelector = slider.vars.selector.substr(0, slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length;
        // SYNC:
        slider.syncExists = $(slider.vars.sync).length > 0;
        // SLIDE:
        if (slider.vars.animation === "slide") {
          slider.vars.animation = "swing";
        }
        slider.prop = vertical ? "top" : slider.vars.rtl ? "marginRight" : "marginLeft";
        slider.args = {};
        // SLIDESHOW:
        slider.manualPause = false;
        slider.stopped = false;
        //PAUSE WHEN INVISIBLE
        slider.started = false;
        slider.startTimeout = null;
        // TOUCH/USECSS:
        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && function () {
          var obj = document.createElement('div'),
            props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
          for (var i in props) {
            if (obj.style[props[i]] !== undefined) {
              slider.pfx = props[i].replace('Perspective', '').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }
          return false;
        }();
        slider.ensureAnimationEnd = '';
        // CONTROLSCONTAINER:
        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
        // MANUAL:
        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);

        // CUSTOM DIRECTION NAV:
        if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav);

        // RANDOMIZE:
        if (slider.vars.randomize) {
          slider.slides.sort(function () {
            return Math.round(Math.random()) - 0.5;
          });
          slider.container.empty().append(slider.slides);
        }
        slider.doMath();

        // INIT
        slider.setup("init");

        // CONTROLNAV:
        if (slider.vars.controlNav) {
          methods.controlNav.setup();
        }

        // DIRECTIONNAV:
        if (slider.vars.directionNav) {
          methods.directionNav.setup();
        }

        // KEYBOARD:
        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function (event) {
            var keycode = event.keyCode;
            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = slider.vars.rtl ? keycode === 37 ? slider.getTarget('next') : keycode === 39 ? slider.getTarget('prev') : false : keycode === 39 ? slider.getTarget('next') : keycode === 37 ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        }
        // MOUSEWHEEL:
        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function (event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = delta < 0 ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        }

        // PAUSEPLAY
        if (slider.vars.pausePlay) {
          methods.pausePlay.setup();
        }

        //PAUSE WHEN INVISIBLE
        if (slider.vars.slideshow && slider.vars.pauseInvisible) {
          methods.pauseInvisible.init();
        }

        // SLIDSESHOW
        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function () {
              if (!slider.manualPlay && !slider.manualPause) {
                slider.pause();
              }
            }, function () {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) {
                slider.play();
              }
            });
          }
          // initialize animation
          //If we're visible, or we don't use PageVisibility API
          if (!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            slider.vars.initDelay > 0 ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        }

        // ASNAV:
        if (asNav) {
          methods.asNav.setup();
        }

        // TOUCH
        if (touch && slider.vars.touch) {
          methods.touch();
        }

        // FADE&&SMOOTHHEIGHT || SLIDE:
        if (!fade || fade && slider.vars.smoothHeight) {
          $(window).bind("resize orientationchange focus", methods.resize);
        }
        slider.find("img").attr("draggable", "false");

        // API: start() Callback
        setTimeout(function () {
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function setup() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide / slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
          if (!msGesture) {
            slider.slides.on(eventType, function (e) {
              e.preventDefault();
              var $slide = $(this),
                target = $slide.index();
              var posFromX;
              if (slider.vars.rtl) {
                posFromX = -1 * ($slide.offset().right - $(slider).scrollLeft()); // Find position of slide relative to right of slider container
              } else {
                posFromX = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
              }

              if (posFromX <= 0 && $slide.hasClass(namespace + 'active-slide')) {
                slider.flexAnimate(slider.getTarget("prev"), true);
              } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                slider.direction = slider.currentItem < target ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
              }
            });
          } else {
            el._slider = slider;
            slider.slides.each(function () {
              var that = this;
              that._gesture = new MSGesture();
              that._gesture.target = that;
              that.addEventListener("MSPointerDown", function (e) {
                e.preventDefault();
                if (e.currentTarget._gesture) {
                  e.currentTarget._gesture.addPointer(e.pointerId);
                }
              }, false);
              that.addEventListener("MSGestureTap", function (e) {
                e.preventDefault();
                var $slide = $(this),
                  target = $slide.index();
                if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                  slider.direction = slider.currentItem < target ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
            });
          }
        }
      },
      controlNav: {
        setup: function setup() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else {
            // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function setupPaging() {
          var type = slider.vars.controlNav === "thumbnails" ? 'control-thumbs' : 'control-paging',
            j = 1,
            item,
            slide;
          slider.controlNavScaffold = $('<ol class="' + namespace + 'control-nav ' + namespace + type + '"></ol>');
          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);
              if (undefined === slide.attr('data-thumb-alt')) {
                slide.attr('data-thumb-alt', '');
              }
              var altText = '' !== slide.attr('data-thumb-alt') ? altText = ' alt="' + slide.attr('data-thumb-alt') + '"' : '';
              item = slider.vars.controlNav === "thumbnails" ? '<img src="' + slide.attr('data-thumb') + '"' + altText + '/>' : '<a href="#">' + j + '</a>';
              if ('thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions) {
                var captn = slide.attr('data-thumbcaption');
                if ('' !== captn && undefined !== captn) {
                  item += '<span class="' + namespace + 'caption">' + captn + '</span>';
                }
              }
              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          }

          // CONTROLSCONTAINER:
          slider.controlsContainer ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();
          methods.controlNav.active();
          slider.controlNavScaffold.delegate('a, img', eventType, function (event) {
            event.preventDefault();
            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                target = slider.controlNav.index($this);
              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = target > slider.currentSlide ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        setupManual: function setupManual() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();
          slider.controlNav.bind(eventType, function (event) {
            event.preventDefault();
            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                target = slider.controlNav.index($this);
              if (!$this.hasClass(namespace + 'active')) {
                target > slider.currentSlide ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        set: function set() {
          var selector = slider.vars.controlNav === "thumbnails" ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, slider.controlsContainer ? slider.controlsContainer : slider);
        },
        active: function active() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function update(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a href="#">' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }
          methods.controlNav.set();
          slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function setup() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>');

          // CUSTOM DIRECTION NAV:
          if (slider.customDirectionNav) {
            slider.directionNav = slider.customDirectionNav;
            // CONTROLSCONTAINER:
          } else if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }
          methods.directionNav.update();
          slider.directionNav.bind(eventType, function (event) {
            event.preventDefault();
            var target;
            if (watchedEvent === "" || watchedEvent === event.type) {
              target = $(this).hasClass(namespace + 'next') ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function update() {
          var disabledClass = namespace + 'disabled';
          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function setup() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a href="#"></a></div>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }
          methods.pausePlay.update(slider.vars.slideshow ? namespace + 'pause' : namespace + 'play');
          slider.pausePlay.bind(eventType, function (event) {
            event.preventDefault();
            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function update(state) {
          state === "play" ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function touch() {
        var startX,
          startY,
          offset,
          cwidth,
          dx,
          startT,
          onTouchStart,
          onTouchMove,
          _onTouchEnd,
          scrolling = false,
          localX = 0,
          localY = 0,
          accDx = 0;
        if (!msGesture) {
          onTouchStart = function onTouchStart(e) {
            if (slider.animating) {
              e.preventDefault();
            } else if (window.navigator.msPointerEnabled || e.touches.length === 1) {
              slider.pause();
              // CAROUSEL:
              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date());
              // CAROUSEL:

              // Local vars for X and Y points.
              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;
              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
              startX = vertical ? localY : localX;
              startY = vertical ? localX : localY;
              el.addEventListener('touchmove', onTouchMove, false);
              el.addEventListener('touchend', _onTouchEnd, false);
            }
          };
          onTouchMove = function onTouchMove(e) {
            // Local vars for X and Y points.

            localX = e.touches[0].pageX;
            localY = e.touches[0].pageY;
            dx = vertical ? startX - localY : (slider.vars.rtl ? -1 : 1) * (startX - localX);
            scrolling = vertical ? Math.abs(dx) < Math.abs(localX - startY) : Math.abs(dx) < Math.abs(localY - startY);
            var fxms = 500;
            if (!scrolling || Number(new Date()) - startT > fxms) {
              e.preventDefault();
              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = dx / (slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0 ? Math.abs(dx) / cwidth + 2 : 1);
                }
                slider.setProps(offset + dx, "setTouch");
              }
            }
          };
          _onTouchEnd = function onTouchEnd(e) {
            // finish the touch by undoing the touch session
            el.removeEventListener('touchmove', onTouchMove, false);
            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');
              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }
            el.removeEventListener('touchend', _onTouchEnd, false);
            startX = null;
            startY = null;
            dx = null;
            offset = null;
          };
          el.addEventListener('touchstart', onTouchStart, false);
        } else {
          var onMSPointerDown = function onMSPointerDown(e) {
            e.stopPropagation();
            if (slider.animating) {
              e.preventDefault();
            } else {
              slider.pause();
              el._gesture.addPointer(e.pointerId);
              accDx = 0;
              cwidth = vertical ? slider.h : slider.w;
              startT = Number(new Date());
              // CAROUSEL:

              offset = carousel && reverse && slider.animatingTo === slider.last ? 0 : carousel && reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : carousel && slider.currentSlide === slider.last ? slider.limit : carousel ? (slider.itemW + slider.vars.itemMargin) * slider.move * slider.currentSlide : reverse ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
            }
          };
          var onMSGestureChange = function onMSGestureChange(e) {
            e.stopPropagation();
            var slider = e.target._slider;
            if (!slider) {
              return;
            }
            var transX = -e.translationX,
              transY = -e.translationY;

            //Accumulate translations.
            accDx = accDx + (vertical ? transY : transX);
            dx = (slider.vars.rtl ? -1 : 1) * accDx;
            scrolling = vertical ? Math.abs(accDx) < Math.abs(-transX) : Math.abs(accDx) < Math.abs(-transY);
            if (e.detail === e.MSGESTURE_FLAG_INERTIA) {
              setImmediate(function () {
                el._gesture.stop();
              });
              return;
            }
            if (!scrolling || Number(new Date()) - startT > 500) {
              e.preventDefault();
              if (!fade && slider.transitions) {
                if (!slider.vars.animationLoop) {
                  dx = accDx / (slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0 ? Math.abs(accDx) / cwidth + 2 : 1);
                }
                slider.setProps(offset + dx, "setTouch");
              }
            }
          };
          var onMSGestureEnd = function onMSGestureEnd(e) {
            e.stopPropagation();
            var slider = e.target._slider;
            if (!slider) {
              return;
            }
            if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
              var updateDx = reverse ? -dx : dx,
                target = updateDx > 0 ? slider.getTarget('next') : slider.getTarget('prev');
              if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth / 2)) {
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              } else {
                if (!fade) {
                  slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true);
                }
              }
            }
            startX = null;
            startY = null;
            dx = null;
            offset = null;
            accDx = 0;
          };
          el.style.msTouchAction = "none";
          el._gesture = new MSGesture();
          el._gesture.target = el;
          el.addEventListener("MSPointerDown", onMSPointerDown, false);
          el._slider = slider;
          el.addEventListener("MSGestureChange", onMSGestureChange, false);
          el.addEventListener("MSGestureEnd", onMSGestureEnd, false);
        }
      },
      resize: function resize() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) {
            slider.doMath();
          }
          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) {
            //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          } else if (vertical) {
            //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }
            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function smoothHeight(dur) {
        if (!vertical || fade) {
          var $obj = fade ? slider : slider.viewport;
          dur ? $obj.animate({
            "height": slider.slides.eq(slider.animatingTo).innerHeight()
          }, dur) : $obj.innerHeight(slider.slides.eq(slider.animatingTo).innerHeight());
        }
      },
      sync: function sync(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
          target = slider.animatingTo;
        switch (action) {
          case "animate":
            $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true);
            break;
          case "play":
            if (!$obj.playing && !$obj.asNav) {
              $obj.play();
            }
            break;
          case "pause":
            $obj.pause();
            break;
        }
      },
      uniqueID: function uniqueID($clone) {
        // Append _clone to current level and children elements with id attributes
        $clone.filter('[id]').add($clone.find('[id]')).each(function () {
          var $this = $(this);
          $this.attr('id', $this.attr('id') + '_clone');
        });
        return $clone;
      },
      pauseInvisible: {
        visProp: null,
        init: function init() {
          var visProp = methods.pauseInvisible.getHiddenProp();
          if (visProp) {
            var evtname = visProp.replace(/[H|h]idden/, '') + 'visibilitychange';
            document.addEventListener(evtname, function () {
              if (methods.pauseInvisible.isHidden()) {
                if (slider.startTimeout) {
                  clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                } else {
                  slider.pause(); //Or just pause
                }
              } else {
                if (slider.started) {
                  slider.play(); //Initiated before, just play
                } else {
                  if (slider.vars.initDelay > 0) {
                    setTimeout(slider.play, slider.vars.initDelay);
                  } else {
                    slider.play(); //Didn't init before: simply init or wait for it
                  }
                }
              }
            });
          }
        },

        isHidden: function isHidden() {
          var prop = methods.pauseInvisible.getHiddenProp();
          if (!prop) {
            return false;
          }
          return document[prop];
        },
        getHiddenProp: function getHiddenProp() {
          var prefixes = ['webkit', 'moz', 'ms', 'o'];
          // if 'hidden' is natively supported just return it
          if ('hidden' in document) {
            return 'hidden';
          }
          // otherwise loop over all the known prefixes until we find one
          for (var i = 0; i < prefixes.length; i++) {
            if (prefixes[i] + 'Hidden' in document) {
              return prefixes[i] + 'Hidden';
            }
          }
          // otherwise it's not supported
          return null;
        }
      },
      setToClearWatchedEvent: function setToClearWatchedEvent() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function () {
          watchedEvent = "";
        }, 3000);
      }
    };

    // public methods
    slider.flexAnimate = function (target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = target > slider.currentSlide ? "next" : "prev";
      }
      if (asNav && slider.pagingCount === 1) slider.direction = slider.currentItem < target ? "next" : "prev";
      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = slider.currentItem < target ? "next" : "prev";
          master.direction = slider.direction;
          if (Math.ceil((target + 1) / slider.visible) - 1 !== slider.currentSlide && target !== 0) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target / slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }
        slider.animating = true;
        slider.animatingTo = target;

        // SLIDESHOW:
        if (pause) {
          slider.pause();
        }

        // API: before() animation Callback
        slider.vars.before(slider);

        // SYNC:
        if (slider.syncExists && !fromNav) {
          methods.sync("animate");
        }

        // CONTROLNAV
        if (slider.vars.controlNav) {
          methods.controlNav.active();
        }

        // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)
        if (!carousel) {
          slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide');
        }

        // INFINITE LOOP:
        // CANDIDATE: atEnd
        slider.atEnd = target === 0 || target === slider.last;

        // DIRECTIONNAV:
        if (slider.vars.directionNav) {
          methods.directionNav.update();
        }
        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider);
          // SLIDESHOW && !INFINITE LOOP:
          if (!slider.vars.animationLoop) {
            slider.pause();
          }
        }

        // SLIDE:
        if (!fade) {
          var dimension = vertical ? slider.slides.filter(':first').height() : slider.computedW,
            margin,
            slideString,
            calcNext;

          // INFINITE LOOP / REVERSE:
          if (carousel) {
            margin = slider.vars.itemMargin;
            calcNext = (slider.itemW + margin) * slider.move * slider.animatingTo;
            slideString = calcNext > slider.limit && slider.visible !== 1 ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = reverse ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = reverse ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = reverse ? (slider.count - 1 - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }
          slider.setProps(slideString, "", slider.vars.animationSpeed);
          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            }

            // Unbind previous transitionEnd events and re-bind new transitionEnd event
            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function () {
              clearTimeout(slider.ensureAnimationEnd);
              slider.wrapup(dimension);
            });

            // Insurance for the ever-so-fickle transitionEnd event
            clearTimeout(slider.ensureAnimationEnd);
            slider.ensureAnimationEnd = setTimeout(function () {
              slider.wrapup(dimension);
            }, slider.vars.animationSpeed + 100);
          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function () {
              slider.wrapup(dimension);
            });
          }
        } else {
          // FADE:
          if (!touch) {
            slider.slides.eq(slider.currentSlide).css({
              "zIndex": 1
            }).animate({
              "opacity": 0
            }, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({
              "zIndex": 2
            }).animate({
              "opacity": 1
            }, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);
          } else {
            slider.slides.eq(slider.currentSlide).css({
              "opacity": 0,
              "zIndex": 1
            });
            slider.slides.eq(target).css({
              "opacity": 1,
              "zIndex": 2
            });
            slider.wrapup(dimension);
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) {
          methods.smoothHeight(slider.vars.animationSpeed);
        }
      }
    };
    slider.wrapup = function (dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }
      slider.animating = false;
      slider.currentSlide = slider.animatingTo;
      // API: after() animation Callback
      slider.vars.after(slider);
    };

    // SLIDESHOW:
    slider.animateSlides = function () {
      if (!slider.animating && focused) {
        slider.flexAnimate(slider.getTarget("next"));
      }
    };
    // SLIDESHOW:
    slider.pause = function () {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) {
        methods.pausePlay.update("play");
      }
      // SYNC:
      if (slider.syncExists) {
        methods.sync("pause");
      }
    };
    // SLIDESHOW:
    slider.play = function () {
      if (slider.playing) {
        clearInterval(slider.animatedSlides);
      }
      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) {
        methods.pausePlay.update("pause");
      }
      // SYNC:
      if (slider.syncExists) {
        methods.sync("play");
      }
    };
    // STOP:
    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    };
    slider.canAdvance = function (target, fromNav) {
      // ASNAV:
      var last = asNav ? slider.pagingCount - 1 : slider.last;
      return fromNav ? true : asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev" ? true : asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next" ? false : target === slider.currentSlide && !asNav ? false : slider.vars.animationLoop ? true : slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next" ? false : slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next" ? false : true;
    };
    slider.getTarget = function (dir) {
      slider.direction = dir;
      if (dir === "next") {
        return slider.currentSlide === slider.last ? 0 : slider.currentSlide + 1;
      } else {
        return slider.currentSlide === 0 ? slider.last : slider.currentSlide - 1;
      }
    };

    // SLIDE:
    slider.setProps = function (pos, special, dur) {
      var target = function () {
        var posCheck = pos ? pos : (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo,
          posCalc = function () {
            if (carousel) {
              return special === "setTouch" ? pos : reverse && slider.animatingTo === slider.last ? 0 : reverse ? slider.limit - (slider.itemW + slider.vars.itemMargin) * slider.move * slider.animatingTo : slider.animatingTo === slider.last ? slider.limit : posCheck;
            } else {
              switch (special) {
                case "setTotal":
                  return reverse ? (slider.count - 1 - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                case "setTouch":
                  return reverse ? pos : pos;
                case "jumpEnd":
                  return reverse ? pos : slider.count * pos;
                case "jumpStart":
                  return reverse ? slider.count * pos : pos;
                default:
                  return pos;
              }
            }
          }();
        return posCalc * (slider.vars.rtl ? 1 : -1) + "px";
      }();
      if (slider.transitions) {
        target = vertical ? "translate3d(0," + target + ",0)" : "translate3d(" + ((slider.vars.rtl ? -1 : 1) * parseInt(target) + 'px') + ",0,0)";
        dur = dur !== undefined ? dur / 1000 + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
        slider.container.css("transition-duration", dur);
      }
      slider.args[slider.prop] = target;
      if (slider.transitions || dur === undefined) {
        slider.container.css(slider.args);
      }
      slider.container.css('transform', target);
    };
    slider.setup = function (type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;
        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({
            "overflow": "hidden",
            "position": "relative"
          }).appendTo(slider).append(slider.container);
          // INFINITE LOOP:
          slider.cloneCount = 0;
          slider.cloneOffset = 0;
          // REVERSE:
          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        }
        // INFINITE LOOP && !CAROUSEL:
        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1;
          // clear out old clones
          if (type !== "init") {
            slider.container.find('.clone').remove();
          }
          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true')).prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
        }
        slider.newSlides = $(slider.vars.selector, slider);
        sliderOffset = reverse ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
        // VERTICAL:
        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function () {
            slider.newSlides.css({
              "display": "block"
            });
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, type === "init" ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function () {
            slider.doMath();
            if (slider.vars.rtl) {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            } else {
              slider.newSlides.css({
                "width": slider.computedW,
                "marginRight": slider.computedM,
                "float": "left",
                "display": "block"
              });
            }
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) {
              methods.smoothHeight();
            }
          }, type === "init" ? 100 : 0);
        }
      } else {
        // FADE:
        if (slider.vars.rtl) {
          slider.slides.css({
            "width": "100%",
            "float": 'right',
            "marginLeft": "-100%",
            "position": "relative"
          });
        } else {
          slider.slides.css({
            "width": "100%",
            "float": 'left',
            "marginRight": "-100%",
            "position": "relative"
          });
        }
        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            if (slider.vars.fadeFirstSlide == false) {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).css({
                "opacity": 1
              });
            } else {
              slider.slides.css({
                "opacity": 0,
                "display": "block",
                "zIndex": 1
              }).eq(slider.currentSlide).css({
                "zIndex": 2
              }).animate({
                "opacity": 1
              }, slider.vars.animationSpeed, slider.vars.easing);
            }
          } else {
            slider.slides.css({
              "opacity": 0,
              "display": "block",
              "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease",
              "zIndex": 1
            }).eq(slider.currentSlide).css({
              "opacity": 1,
              "zIndex": 2
            });
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) {
          methods.smoothHeight();
        }
      }
      // !CAROUSEL:
      // CANDIDATE: active slide
      if (!carousel) {
        slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide");
      }

      //FlexSlider: init() Callback
      slider.vars.init(slider);
    };
    slider.doMath = function () {
      var slide = slider.slides.first(),
        slideMargin = slider.vars.itemMargin,
        minItems = slider.vars.minItems,
        maxItems = slider.vars.maxItems;
      slider.w = slider.viewport === undefined ? slider.width() : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width();

      // CAROUSEL:
      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.itemM = slideMargin;
        slider.minW = minItems ? minItems * slider.itemT : slider.w;
        slider.maxW = maxItems ? maxItems * slider.itemT - slideMargin : slider.w;
        slider.itemW = slider.minW > slider.w ? (slider.w - slideMargin * (minItems - 1)) / minItems : slider.maxW < slider.w ? (slider.w - slideMargin * (maxItems - 1)) / maxItems : slider.vars.itemWidth > slider.w ? slider.w : slider.vars.itemWidth;
        slider.visible = Math.floor(slider.w / slider.itemW);
        slider.move = slider.vars.move > 0 && slider.vars.move < slider.visible ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil((slider.count - slider.visible) / slider.move + 1);
        slider.last = slider.pagingCount - 1;
        slider.limit = slider.pagingCount === 1 ? 0 : slider.vars.itemWidth > slider.w ? slider.itemW * (slider.count - 1) + slideMargin * (slider.count - 1) : (slider.itemW + slideMargin) * slider.count - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.itemM = slideMargin;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }
      slider.computedW = slider.itemW - slider.boxPadding;
      slider.computedM = slider.itemM;
    };
    slider.update = function (pos, action) {
      slider.doMath();

      // update currentSlide and slider.animatingTo if necessary
      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }
        slider.animatingTo = slider.currentSlide;
      }

      // update controlNav
      if (slider.vars.controlNav && !slider.manualControls) {
        if (action === "add" && !carousel || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if (action === "remove" && !carousel || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }
          methods.controlNav.update("remove", slider.last);
        }
      }
      // update directionNav
      if (slider.vars.directionNav) {
        methods.directionNav.update();
      }
    };
    slider.addSlide = function (obj, pos) {
      var $obj = $(obj);
      slider.count += 1;
      slider.last = slider.count - 1;

      // append new slide
      if (vertical && reverse) {
        pos !== undefined ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        pos !== undefined ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.update(pos, "add");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      //FlexSlider: added() Callback
      slider.vars.added(slider);
    };
    slider.removeSlide = function (obj) {
      var pos = isNaN(obj) ? slider.slides.index($(obj)) : obj;

      // update count
      slider.count -= 1;
      slider.last = slider.count - 1;

      // remove slide
      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        vertical && reverse ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.doMath();
      slider.update(pos, "remove");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      // FlexSlider: removed() Callback
      slider.vars.removed(slider);
    };

    //FlexSlider: Initialize
    methods.init();
  };

  // Ensure the slider isn't focussed if the window loses focus.
  $(window).blur(function (e) {
    focused = false;
  }).focus(function (e) {
    focused = true;
  });

  //FlexSlider: Default Settings
  $.flexslider.defaults = {
    namespace: "flex-",
    //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",
    //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",
    //String: Select your animation type, "fade" or "slide"
    easing: "swing",
    //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",
    //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,
    //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,
    //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,
    //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,
    //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,
    //Boolean: Animate slider automatically
    slideshowSpeed: 7000,
    //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,
    //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,
    //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,
    //Boolean: Randomize slide order
    fadeFirstSlide: true,
    //Boolean: Fade in the first slide when animation type is "fade"
    thumbCaptions: false,
    //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.

    // Usability features
    pauseOnAction: true,
    //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,
    //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,
    //{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,
    //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,
    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,
    //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches

    // Primary Controls
    controlNav: true,
    //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
    directionNav: true,
    //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",
    //String: Set the text for the "previous" directionNav item
    nextText: "Next",
    //String: Set the text for the "next" directionNav item

    // Secondary Navigation
    keyboard: true,
    //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,
    //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,
    //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,
    //Boolean: Create pause/play dynamic element
    pauseText: "Pause",
    //String: Set the text for the "pause" pausePlay item
    playText: "Play",
    //String: Set the text for the "play" pausePlay item

    // Special properties
    controlsContainer: "",
    //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",
    //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    customDirectionNav: "",
    //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
    sync: "",
    //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",
    //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider

    // Carousel Options
    itemWidth: 0,
    //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,
    //{NEW} Integer: Margin between carousel items.
    minItems: 1,
    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,
    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,
    //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,
    //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide

    // Callback API
    start: function start() {},
    //Callback: function(slider) - Fires when the slider loads the first slide
    before: function before() {},
    //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function after() {},
    //Callback: function(slider) - Fires after each slider animation completes
    end: function end() {},
    //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function added() {},
    //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function removed() {},
    //{NEW} Callback: function(slider) - Fires after a slide is removed
    init: function init() {},
    //{NEW} Callback: function(slider) - Fires after the slider is initially setup
    rtl: false //{NEW} Boolean: Whether or not to enable RTL mode
  };

  //FlexSlider: Plugin Function
  $.fn.flexslider = function (options) {
    if (options === undefined) {
      options = {};
    }
    if ((0,esm_typeof/* default */.Z)(options) === "object") {
      return this.each(function () {
        var $this = $(this),
          selector = options.selector ? options.selector : ".slides > li",
          $slides = $this.find(selector);
        if ($slides.length === 1 && options.allowOneSlide === false || $slides.length === 0) {
          $slides.fadeIn(400);
          if (options.start) {
            options.start($this);
          }
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');
      switch (options) {
        case "play":
          $slider.play();
          break;
        case "pause":
          $slider.pause();
          break;
        case "stop":
          $slider.stop();
          break;
        case "next":
          $slider.flexAnimate($slider.getTarget("next"), true);
          break;
        case "prev":
        case "previous":
          $slider.flexAnimate($slider.getTarget("prev"), true);
          break;
        default:
          if (typeof options === "number") {
            $slider.flexAnimate(options, true);
          }
      }
    }
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/flexslider/js/index.js



/* 
 *************************************
 * <!-- Flexslider (Third-party plugin) -->
 *************************************
 */



var FLEXSLIDER = function (module, $, window, document) {
  if (window.FLEXSLIDER === null) return false;
  module.FLEXSLIDER = module.FLEXSLIDER || {};
  module.FLEXSLIDER.version = '0.2.1';
  module.FLEXSLIDER.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var flexslider = {
      vars: {}
    };
    var pluginNamespace = 'uix-flexslider__';

    /*
     * Tiny helper function to add breakpoints.
     *
     * @param  {Number} number           - Number of carousel items that should be visible.
     * @return {Void}
     */
    function getGridSize(number) {
      return window.innerWidth <= 768 ? 1 : number;
    }

    /*
     * Return an event from callback function to each slider.
     *
     * @param  {Element} thisSlider             - The current slider.
     * @param  {Element} sliderWrapper          - The current slider wrapper.
     * @param  {String} fireState              - State of fire asynchronously.
     * @return {Number}                        - Index of current slider .
     */
    function initslides(sliderWrapper, thisSlider, fireState) {
      if (thisSlider.find('.' + pluginNamespace + 'item').length == 0) return false;
      var curIndex = thisSlider.currentSlide,
        count = thisSlider.count,
        activeClass = pluginNamespace + 'item--active',
        prevClass = activeClass + '-prev',
        nextClass = activeClass + '-next',
        $items = thisSlider.find('.' + pluginNamespace + 'item'),
        $current = thisSlider.slides.eq(curIndex),
        $prev = thisSlider.slides.eq(curIndex - 1),
        $next = thisSlider.slides.eq(thisSlider.animatingTo),
        $first = thisSlider.slides.eq(0),
        curHeight = $current.height(),
        dataNhumbs = thisSlider.data('my-nav-thumbs'),
        dataPNThumbs = thisSlider.data('my-prev-next-thumbs'),
        dataTimeline = thisSlider.data('my-nav-timeline'),
        dataCountTotal = thisSlider.data('my-count-total'),
        dataCountCur = thisSlider.data('my-count-now'),
        dataShowItems = thisSlider.data('my-multiple-items'),
        dataShowItemsMove = thisSlider.data('my-multiple-items-move'),
        dataParallax = thisSlider.data('my-parallax'),
        dataCustomConID = thisSlider.data('my-controls');
      if ((0,esm_typeof/* default */.Z)(dataPNThumbs) === ( true ? "undefined" : 0)) dataPNThumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataTimeline) === ( true ? "undefined" : 0)) dataTimeline = false;
      if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = false;
      if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = false;
      if ((0,esm_typeof/* default */.Z)(dataParallax) === ( true ? "undefined" : 0)) dataParallax = false;
      if ((0,esm_typeof/* default */.Z)(dataShowItemsMove) === ( true ? "undefined" : 0)) dataShowItemsMove = 1;

      //Add disabled class to custom navigation 
      if ((0,esm_typeof/* default */.Z)(dataCustomConID) != ( true ? "undefined" : 0) && dataCustomConID != '' && dataCustomConID != false) {
        var myCustomDirectionNav = $('.uix-flexslider__mycontrols' + dataCustomConID + ' a');
        var disabledClass = pluginNamespace + 'disabled';
        if (thisSlider.pagingCount === 1) {
          myCustomDirectionNav.addClass(disabledClass).attr('tabindex', '-1');
        } else if (!thisSlider.vars.animationLoop) {
          if (thisSlider.animatingTo === 0) {
            myCustomDirectionNav.removeClass(disabledClass);
            myCustomDirectionNav.first().addClass(disabledClass).attr('tabindex', '-1');
          } else if (thisSlider.animatingTo === thisSlider.last) {
            myCustomDirectionNav.removeClass(disabledClass);
            myCustomDirectionNav.last().addClass(disabledClass).attr('tabindex', '-1');
          } else {
            myCustomDirectionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        } else {
          myCustomDirectionNav.removeClass(disabledClass).removeAttr('tabindex');
        }
      }

      //Total counter selector
      //Current counter selector.
      var countTotalSelector = dataCountTotal ? $(dataCountTotal) : $('.uix-flexslider__mycontrols__count em.count'),
        countCurSelector = dataCountCur ? $(dataCountCur) : $('.uix-flexslider__mycontrols__count em.current');

      // Fires when the slider loads the first slide.
      // Fires after each slider animation completes.
      if (fireState == 'start' || fireState == 'after') {
        //Remove the slider loading
        //-------------------------------------
        thisSlider.removeClass(pluginNamespace + '-flexslider-loading');

        //With Timeline
        //-------------------------------------	
        if (dataTimeline && dataTimeline != '') {
          var curPerMinWidth = curIndex / count * 100 + '%',
            curPerMaxWidth = (curIndex + 1) / count * 100 + '%',
            curTotalWidth = $(dataTimeline).width();

          //Fires animation effect of an element width.
          $(dataTimeline).find('> span').css({
            'width': curTotalWidth,
            'transition': 'all ' + parseFloat(thisSlider.vars.slideshowSpeed - thisSlider.vars.animationSpeed) + 'ms linear'
          });
        }

        //Display Next/Prev image thumbnail in navigation
        //-------------------------------------		
        if (dataPNThumbs && dataPNThumbs != '') {
          var prevIndex = curIndex - 1,
            nextIndex = thisSlider.animatingTo + 1,
            pimg = '',
            nimg = '',
            $plink = $(dataPNThumbs + '> a'),
            $plinkPrev = $plink.filter('.uix-flexslider__mycontrols--thumb__prev'),
            $plinkNext = $plink.filter('.uix-flexslider__mycontrols--thumb__next');
          $plinkPrev.removeClass('is-disabled');
          $plinkNext.removeClass('is-disabled');
          if (!thisSlider.vars.animationLoop) {
            if (prevIndex === -1) $plinkPrev.addClass('is-disabled');
            if (nextIndex === thisSlider.last + 1) $plinkNext.addClass('is-disabled');
          } else {
            if (prevIndex === -1) prevIndex = thisSlider.last;
            if (nextIndex === thisSlider.last + 1) nextIndex = 0;
          }

          //Get images URL
          pimg = thisSlider.slides.eq(prevIndex).find('img').attr('src');
          nimg = thisSlider.slides.eq(nextIndex).find('img').attr('src');
          if ($(dataPNThumbs).length > 0) {
            $plink.attr('href', 'javascript:void(0);');
            if ((0,esm_typeof/* default */.Z)(pimg) != ( true ? "undefined" : 0)) $plinkPrev.attr('data-goto', prevIndex).find('> span').html('<img src="' + pimg + '" alt="">');
            if ((0,esm_typeof/* default */.Z)(nimg) != ( true ? "undefined" : 0)) $plinkNext.attr('data-goto', nextIndex).find('> span').html('<img src="' + nimg + '" alt="">');
            $plink.off('click').on('click', function (e) {
              e.preventDefault();
              thisSlider.flexslider(parseInt($(this).attr('data-goto')));
            });
          }
        }

        // Fires local videos asynchronously with slider switch.
        //-------------------------------------
        videoEmbedInit($items, false);
        videoEmbedInit($current, true);

        //Auto-restart player if paused after action
        //-------------------------------------
        if (thisSlider.vars.slideshow) {
          if (!thisSlider.playing) {
            thisSlider.play();
          }
        }

        //Prevent to <a> of page transitions
        //-------------------------------------
        $('a').each(function () {
          var attr = $(this).attr('href');
          if ((0,esm_typeof/* default */.Z)(attr) === ( true ? "undefined" : 0)) {
            $(this).attr('href', '#');
          }
        });

        //Thumbnail ControlNav Pattern
        //-------------------------------------
        if (dataNhumbs && dataNhumbs != '') {
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').removeClass('is-active');
          $('.uix-flexslider__thumbs' + dataNhumbs + ' > ul > li').eq(curIndex).addClass('is-active');
        }

        //Initialize items background of the slider
        //-------------------------------------
        thisSlider.find('[data-slider-bg]').each(function () {
          $(this).css('background-image', 'url(' + $(this).data('slider-bg') + ')');
        });

        //Enable "prettyPhoto" plugin
        //-------------------------------------
        if ($.isFunction($.fn.lightbox)) {
          thisSlider.slides.find("a[rel^='theme-slider-prettyPhoto']").lightbox();
        }

        //Return an event from callback function to each slider 
        //with dynamic min/max ranges.
        //-------------------------------------

        if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
          if (dataShowItemsMove == 1) {
            $items.removeClass(activeClass);
            $items.removeClass(prevClass);
            $items.removeClass(nextClass);
            if (windowWidth <= 768) {
              //Focus slider
              $items.eq(parseFloat(curIndex)).addClass(activeClass);
            } else {
              //Focus slider
              $items.eq(parseFloat(curIndex + 1)).addClass(activeClass);

              //Previous slider
              $items.eq(parseFloat(curIndex)).addClass(prevClass);

              //Next slider
              $items.eq(parseFloat(curIndex + 2)).addClass(nextClass);
            }
          } else {
            $items.addClass(activeClass);
          }
        }

        //Display counter
        //-------------------------------------
        if (sliderWrapper.find('.uix-flexslider__mycontrols__count').length == 0) {
          if (sliderWrapper.closest('section').find('.uix-flexslider__mycontrols__count').length > 0) {
            var showCountTotal = count,
              showCountCur = curIndex + 1;
            if (showCountTotal < 10) showCountTotal = '0' + showCountTotal;
            if (showCountCur < 10) showCountCur = '0' + showCountCur;
            countTotalSelector.text(showCountTotal);
            countCurSelector.text(showCountCur);
          }
        }
      }

      // Fires asynchronously with each slider animation.
      if (fireState == 'before') {
        //Common images style
        //-------------------------------------	
        $next.find('img').addClass('is-active');
        $current.find('img').removeClass('is-active');
        $prev.find('img').removeClass('is-active');
        $first.find('img').removeClass('is-active');

        //With Timeline
        //-------------------------------------	
        if (dataTimeline && dataTimeline != '') {
          //Fires animation effect of an element width.
          $(dataTimeline).find('> span').css({
            'width': 0,
            'transition': 'all 100ms linear'
          });
        }
      }

      // Fires when the slider reaches the last slide (asynchronous).
      if (fireState == 'end') {
        //Common images style
        //-------------------------------------	
        $first.find('img').addClass('is-active');
      }

      // Fires asynchronously with each slider animation.
      // Fires when the slider loads the first slide.
      if (fireState == 'before' || fireState == 'start') {
        //Return an event from callback function to each slider to make parallax effect.
        //-------------------------------------
        if (dataParallax) {
          var dir = 'uix-flexslider__item--left';
          $.each(thisSlider.slides, function (i, item) {
            var el = $(item);
            el.removeClass('uix-flexslider__item--right uix-flexslider__item--left');
            if (i >= thisSlider.animatingTo && dir !== 'uix-flexslider__item--right') {
              dir = 'uix-flexslider__item--right';
            } else {
              el.addClass(dir);
            }
          });
        }
      }
      return curIndex;
    }

    /*
     * Initialize embedded local video.
     *
     * @param  {Element} wrapper          - The outermost video container, which can contain multiple videos
     * @param  {Boolean} play            - Forced to trigger pause or play events.
     * @return {Void}
     */
    function videoEmbedInit(wrapper, play) {
      wrapper.find('.uix-video__slider').each(function () {
        var $this = $(this);
        var videoWrapperW = $this.closest('[data-embed-video-wrapper]').width(),
          curVideoID = $this.find('video').attr('id') + '-slider-videopush',
          coverPlayBtnID = 'videocover-' + curVideoID,
          $replayBtn = $('#' + curVideoID + '-replay-btn');
        var dataControls = $this.data('embed-video-controls'),
          dataAuto = $this.data('embed-video-autoplay'),
          dataLoop = $this.data('embed-video-loop'),
          dataW = $this.data('embed-video-width'),
          dataH = $this.data('embed-video-height');

        //Push a new ID to video
        //Solve the problem that ajax asynchronous loading does not play
        $this.find('.video-js').attr('id', curVideoID);
        if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) {
          dataAuto = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) {
          dataLoop = true;
        }
        if ((0,esm_typeof/* default */.Z)(dataControls) === ( true ? "undefined" : 0)) {
          dataControls = false;
        }
        if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0) || dataW == 'auto') {
          dataW = videoWrapperW;
        }
        if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0) || dataH == 'auto') {
          dataH = videoWrapperW / 1.77777777777778;
        }

        //Display cover and play buttons when some mobile device browsers cannot automatically play video
        if ($('#' + coverPlayBtnID).length == 0) {
          $('<div id="' + coverPlayBtnID + '" class="uix-video__cover"><span class="uix-video__cover__placeholder" style="background-image:url(' + $this.find('video').attr('poster') + ')"></span><span class="uix-video__cover__playbtn"></span></div>').insertBefore($this);
          var btnEv = Modernizr.touchevents ? 'touchstart' : 'click';
          $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').on(btnEv, function (e) {
            e.preventDefault();
            myPlayer.play();
            $('#' + coverPlayBtnID).hide();
          });
        }

        //Add replay button to video 
        if ($replayBtn.length == 0) {
          $this.after('<span class="uix-video__btn-play" id="' + curVideoID + '-replay-btn"></span>');
        }

        //HTML5 video autoplay on mobile revisited
        if (dataAuto && windowWidth <= 768) {
          $this.find('.video-js').attr({
            'autoplay': 'true',
            'muted': 'true',
            'playsinline': 'true'
          });
        }
        var myPlayer = videojs(curVideoID, {
          width: dataW,
          height: dataH,
          loop: dataLoop,
          autoplay: dataAuto
        }, function onPlayerReady() {
          var initVideo = function initVideo(obj) {
            //Get Video Dimensions
            var curW = obj.videoWidth(),
              curH = obj.videoHeight(),
              newW = curW,
              newH = curH;
            newW = videoWrapperW;

            //Scaled/Proportional Content 
            newH = curH * (newW / curW);
            if (!isNaN(newW) && !isNaN(newH)) {
              obj.height(newH);
              obj.width(newW);
              $this.css('height', newH);
            }

            //Show this video wrapper
            $this.css('visibility', 'visible');

            //Hide loading effect
            $this.find('.vjs-loading-spinner, .vjs-big-play-button').hide();
          };

          /* ---------  Video initialize */
          this.on('loadedmetadata', function () {
            initVideo(this);
          });

          /* ---------  Display the play button  */
          if (!dataAuto) $this.find('.vjs-big-play-button').show();
          $this.find('.vjs-big-play-button').off('click').on('click', function () {
            $(this).hide();
          });

          /* ---------  Set, tell the player it's in fullscreen  */
          if (dataAuto) {
            //Fix an error of Video auto play is not working in browser
            //this.muted( true ); 

            //Prevent autoplay error: Uncaught (in promise) DOMException
            var promise = this.play();
            if (promise !== undefined) {
              promise.then(function () {
                // Autoplay started!
              })["catch"](function (error) {
                // Autoplay was prevented.
                $('#' + coverPlayBtnID).show();
                $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                console.log('Autoplay was prevented.');
              });
            }
          }

          /* ---------  Disable control bar play button click */
          if (!dataControls) {
            this.controls(false);
          }

          /* ---------  Determine if the video is auto played from mobile devices  */
          var autoPlayOK = false;
          this.on('timeupdate', function () {
            var duration = this.duration();
            if (duration > 0) {
              autoPlayOK = true;
              if (this.currentTime() > 0) {
                autoPlayOK = true;
                this.off('timeupdate');

                //Hide cover and play buttons when the video automatically played
                $('#' + coverPlayBtnID).hide();
              }
            }
          });

          /* ---------  Pause the video when it is not current slider  */
          if (!play) {
            this.pause();
            this.currentTime(0);
          } else {
            if (dataAuto) {
              this.currentTime(0);

              //Prevent autoplay error: Uncaught (in promise) DOMException
              var _promise = this.play();
              if (_promise !== undefined) {
                _promise.then(function () {
                  // Autoplay started!
                })["catch"](function (error) {
                  // Autoplay was prevented.
                  $('#' + coverPlayBtnID).show();
                  $('#' + coverPlayBtnID + ' .uix-video__cover__playbtn').show();
                  console.log('Autoplay was prevented.');
                });
              }

              //Hidden replay button
              $replayBtn.hide();

              //Should the video go to the beginning when it ends
              this.on('ended', function () {
                if (dataLoop) {
                  this.currentTime(0);
                  this.play();
                } else {
                  //Replay this video
                  this.currentTime(0);
                  $replayBtn.show().off('click').on('click', function (e) {
                    e.preventDefault();
                    this.play();
                    $replayBtn.hide();
                  });
                }
              });
            }
          }
        });
      });
    }

    /*
     * Make slider image draggable 
     *
     * @param  {Element} $obj             - The current FlexSlider setup using custom selector.
     * @return {Void}
     */
    function slidesExDraggable($obj, animDelay) {
      function prevMove() {
        $obj.flexslider('prev');
      }
      function nextMove() {
        $obj.flexslider('next');
      }

      //Added touch method to mobile device and desktop
      //-------------------------------------	
      var $dragTrigger = $obj.find('.uix-flexslider__inner');
      var mouseX, mouseY;
      var isMoving = false;

      //Avoid images causing mouseup to fail
      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      });

      //Make the cursor a move icon when a user hovers over an item
      $dragTrigger.css('cursor', 'move');
      $dragTrigger[0].removeEventListener('mousedown', dragStart);
      document.removeEventListener('mouseup', dragEnd);

      //
      $dragTrigger[0].addEventListener('mousedown', dragStart);
      function dragStart(e) {
        if ($obj.data('flexslider').animating) {
          return;
        }

        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        mouseX = e.clientX;
        mouseY = e.clientY;
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
      }
      function dragProcess(e) {
        var offsetX, offsetY;
        offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        if ('horizontal' === $obj.data('flexslider').vars.direction) {
          //--- left
          if (offsetX >= 50) {
            if (!isMoving) {
              isMoving = true;
              nextMove();
            }
          }

          //--- right
          if (offsetX <= -50) {
            if (!isMoving) {
              isMoving = true;
              prevMove();
            }
          }
        } else {
          //--- up
          if (offsetY >= 50) {
            if (!isMoving) {
              isMoving = true;
              nextMove();
            }
          }

          //--- down
          if (offsetY <= -50) {
            if (!isMoving) {
              isMoving = true;
              prevMove();
            }
          }
        }
      }
      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);

        //restore move action status
        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }

    /*
     *  Scroll The Slider With Mousewheel
     *
     * @param  {Element} $obj            - The current FlexSlider setup using custom selector.
     * @return {Void}
     */
    function slidesExMousewheel($obj) {
      var timer = null,
        wheeling = false;
      $obj[0].addEventListener('wheel', function (e) {
        //Gets a value that indicates the amount that the mouse wheel has changed.
        var delta = Math.max(-1, Math.min(1, -e.deltaY));
        if (timer) {
          clearTimeout(timer);
        }
        if (!wheeling) {
          if (delta < 0) {
            //scroll down
            $obj.flexslider('next');
          } else {
            //scroll up
            $obj.flexslider('prev');
          }
        }
        wheeling = true;
        timer = setTimeout(function () {
          wheeling = false;
        }, 60);
      }, browser.supportsPassive ? {
        passive: true
      } : false);
    }

    /*
     * Slider With Thumbnail ControlNav Pattern
     *
     * @param  {Element} slider           - The current slider.
     * @param  {String} navThumbClass    - Class name of thumbnail controlNav.
     * @return {Void}
     */
    function initslidesWithNavThumb(slider, navThumbClass) {
      $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').off('click').on('click', function () {
        $('.uix-flexslider__thumbs' + navThumbClass + ' > ul > li').removeClass('is-active');
        $(this).addClass('is-active');
        slider.flexslider($(this).index());
      });
    }

    /*
    * Method that updates children slides
    * fortunately, since all the children are not animating,
    * they will only update if the main flexslider updates. 
     *
     * @param  {Number} slideNumber          - The current slider index.
     * @param  {Element} childrenSlidesObj    - Target slider.
     * @param  {Boolean} loop                - Gives the slider a seamless infinite loop.
     * @param  {Number} speed                - Set the speed of animations, in milliseconds.
     * @param  {Number} timing               - Set the speed of the slideshow cycling, in milliseconds.
     * @return {Void}
     */
    function updateChildrenSlides(slideNumber, childrenSlidesObj, loop, speed, timing) {
      /** 
      * Create the children flexsliders. Must be array of jquery objects with the
      * flexslider data. Easiest way is to place selector group in a var.
      */
      var childrenSlides = $(childrenSlidesObj).flexslider({
        slideshow: false,
        // Remove the animations
        controlNav: false,
        // Remove the controls
        animationLoop: loop,
        animationSpeed: speed,
        slideshowSpeed: timing
      });

      // Iterate through the children slides but not past the max
      for (var i = 0; i < childrenSlides.length; i++) {
        // Run the animate method on the child slide
        $(childrenSlides[i]).data('flexslider').flexAnimate(slideNumber);
      }
    }

    /*! 
     ---------------------------
           Initialize slideshow
     ---------------------------
     */
    var $sliderDefault = $('.uix-flexslider');
    $sliderDefault.each(function () {
      var $this = $(this);
      var dataSpeed = $this.data('speed'),
        dataDrag = $this.data('draggable'),
        dataWheel = $this.data('wheel'),
        dataTiming = $this.data('timing'),
        dataLoop = $this.data('loop'),
        dataPrev = $this.data('prev'),
        dataNext = $this.data('next'),
        dataAnim = $this.data('animation'),
        dataPaging = $this.data('paging'),
        dataArrows = $this.data('arrows'),
        dataAuto = $this.data('auto'),
        dataNhumbs = $this.data('my-nav-thumbs'),
        dataPNThumbs = $this.data('my-prev-next-thumbs'),
        dataTimeline = $this.data('my-nav-timeline'),
        dataCountTotal = $this.data('my-count-total'),
        dataCountCur = $this.data('my-count-now'),
        customConID = $this.data('my-controls'),
        dataShowItems = $this.data('my-multiple-items'),
        dataShowItemsMove = $this.data('my-multiple-items-move'),
        dataParallax = $this.data('my-parallax'),
        dataSync = $this.data('my-sync');

      //Fires local videos asynchronously with slider switch.
      videoEmbedInit($this.find('.uix-flexslider__item'), false);

      // Custom Controls
      var myControlsContainer, myCustomDirectionNav;
      if ((0,esm_typeof/* default */.Z)(customConID) === ( true ? "undefined" : 0) || customConID == '' || customConID == false) {
        myControlsContainer = '';
        myCustomDirectionNav = '';
      } else {
        myControlsContainer = $('.uix-flexslider__mycontrols' + customConID + ' .uix-flexslider__mycontrols__control-paging');
        myCustomDirectionNav = $('.uix-flexslider__mycontrols' + customConID + ' a');

        //Change the class naming of the page up and down buttons to support trigger events
        myCustomDirectionNav.first().addClass(pluginNamespace + 'prev');
        myCustomDirectionNav.last().addClass(pluginNamespace + 'next');
      }

      // If there is no data-xxx, save current source to it
      if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) dataSpeed = 600;
      if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = true;
      if ((0,esm_typeof/* default */.Z)(dataPrev) === ( true ? "undefined" : 0)) dataPrev = "<i class='fa fa-chevron-left'></i>";
      if ((0,esm_typeof/* default */.Z)(dataNext) === ( true ? "undefined" : 0)) dataNext = "<i class='fa fa-chevron-right'></i>";
      if ((0,esm_typeof/* default */.Z)(dataAnim) === ( true ? "undefined" : 0)) dataAnim = 'slide';
      if ((0,esm_typeof/* default */.Z)(dataPaging) === ( true ? "undefined" : 0)) dataPaging = true;
      if ((0,esm_typeof/* default */.Z)(dataArrows) === ( true ? "undefined" : 0)) dataArrows = true;
      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = true;
      if ((0,esm_typeof/* default */.Z)(dataDrag) === ( true ? "undefined" : 0)) dataDrag = false;
      if ((0,esm_typeof/* default */.Z)(dataWheel) === ( true ? "undefined" : 0)) dataWheel = false;
      if ((0,esm_typeof/* default */.Z)(dataNhumbs) === ( true ? "undefined" : 0)) dataNhumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataPNThumbs) === ( true ? "undefined" : 0)) dataPNThumbs = false;
      if ((0,esm_typeof/* default */.Z)(dataTimeline) === ( true ? "undefined" : 0)) dataTimeline = false;
      if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = false;
      if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = false;
      if ((0,esm_typeof/* default */.Z)(dataParallax) === ( true ? "undefined" : 0)) dataParallax = false;
      if ((0,esm_typeof/* default */.Z)(dataShowItemsMove) === ( true ? "undefined" : 0)) dataShowItemsMove = 1;

      //Make slider image draggable 
      if (dataDrag) slidesExDraggable($this, dataSpeed);

      //Scroll The Slider With Mousewheel
      if (dataWheel) slidesExMousewheel($this);

      //With Thumbnail ControlNav Pattern
      if (dataNhumbs) {
        initslidesWithNavThumb($this, dataNhumbs);
        //Prevent index error
        dataLoop = false;
      }

      //Show number of items
      var my_itemWidth = 0,
        my_move = dataShowItemsMove,
        my_minItems = 0,
        my_maxItems = 0;
      if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
        my_itemWidth = 1;
        my_minItems = getGridSize(dataShowItems);
        my_maxItems = getGridSize(dataShowItems);
      }

      // Determine if this slider is added with a synchronization event
      $('[data-my-sync]').each(function () {
        var curSync = $(this).data('my-sync');
        var thisSliderID = $this.attr('id');
        if ((0,esm_typeof/* default */.Z)(curSync) != ( true ? "undefined" : 0)) {
          curSync = curSync.toString().replace('#', '').replace('.', '');
        }
        if ((0,esm_typeof/* default */.Z)(thisSliderID) != ( true ? "undefined" : 0) && thisSliderID == curSync) {
          dataAuto = false; //Set it not to scroll automatically
          dataPaging = false;

          // break out of jQuery each Loop
          return false;
        }
      });
      $this.flexslider({
        namespace: pluginNamespace,
        animation: dataAnim,
        selector: '.uix-flexslider__inner > div.uix-flexslider__item',
        controlNav: dataPaging,
        smoothHeight: true,
        prevText: dataPrev,
        nextText: dataNext,
        animationSpeed: dataSpeed,
        slideshowSpeed: dataTiming,
        slideshow: dataAuto,
        animationLoop: dataLoop,
        directionNav: dataArrows,
        itemWidth: my_itemWidth,
        move: my_move,
        // Number of carousel items that should move on animation.
        minItems: my_minItems,
        // use function to pull in initial value
        maxItems: my_maxItems,
        // use function to pull in initial value
        controlsContainer: myControlsContainer,
        customDirectionNav: myCustomDirectionNav,
        //Fires when the slider loads the first slide.
        start: function start(slider) {
          //set slider instance to flexslider variable
          if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
            flexslider = slider;
          }
          initslides($this, slider, 'start');
        },
        //Fires asynchronously with each slider animation.
        before: function before(slider) {
          initslides($this, slider, 'before');

          // Call the updateChildrenSlides which itterates through all children slides 
          if ((0,esm_typeof/* default */.Z)(dataSync) != ( true ? "undefined" : 0) && dataSync != '' && dataSync != 0) {
            updateChildrenSlides(slider.animatingTo, dataSync, dataLoop, dataSpeed, dataTiming);
          }
        },
        //Fires after each slider animation completes.
        after: function after(slider) {
          initslides($this, slider, 'after');
        },
        //Fires when the slider reaches the last slide (asynchronous).
        end: function end(slider) {
          initslides($this, slider, 'end');
        }
      });
    });

    /*! 
     ---------------------------
           Check grid size on resize event
     ---------------------------
     */
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        $sliderDefault.each(function () {
          if ($(this).length > 0) {
            // check grid size on resize event
            var dataShowItems = $(this).data('my-multiple-items');
            if ((0,esm_typeof/* default */.Z)(dataShowItems) != ( true ? "undefined" : 0) && dataShowItems != '' && dataShowItems != 0) {
              var gridSize = getGridSize(dataShowItems);
              flexslider.vars.minItems = gridSize;
              flexslider.vars.maxItems = gridSize;
            }
            $(this).data('flexslider').setup();
          }
        });
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
  };
  module.components.documentReady.push(module.FLEXSLIDER.documentReady);
  return /*#__PURE__*/_createClass(function FLEXSLIDER() {
    _classCallCheck(this, FLEXSLIDER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/floating-side-element/js/index.js


/* 
 *************************************
 * <!-- Floating Side Element -->
 *************************************
 */


var FLOATING_SIDE_EL = function (module, $, window, document) {
  if (window.FLOATING_SIDE_EL === null) return false;
  module.FLOATING_SIDE_EL = module.FLOATING_SIDE_EL || {};
  module.FLOATING_SIDE_EL.version = '0.0.7';
  module.FLOATING_SIDE_EL.documentReady = function ($) {
    var documentHeight = 0,
      $floatingSideEl = $('.uix-floating-side-el'),
      floatingOffset = $floatingSideEl.offset();

    //Prevent this module from loading in other pages
    if ($floatingSideEl.length == 0) return false;
    documentHeight = $(document).height();

    //Init position
    TweenMax.to($floatingSideEl, 0.3, {
      css: {
        marginTop: -floatingOffset.top + ($(window).height() - $floatingSideEl.height()) / 2
      }
    });
    function scrollUpdate() {
      var sideBarHeight = $floatingSideEl.height(),
        scrolled = $(window).scrollTop();
      documentHeight = $(document).height();
      if (scrolled > floatingOffset.top) {
        var newPosition = scrolled - floatingOffset.top,
          maxPosition = documentHeight - sideBarHeight;
        if (newPosition > maxPosition) {
          newPosition = maxPosition;
        }
        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: newPosition + (window.innerHeight - sideBarHeight) / 2
          }
        });
      } else {
        TweenMax.to($floatingSideEl, 0.3, {
          css: {
            marginTop: 0
          }
        });
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };
  module.components.documentReady.push(module.FLOATING_SIDE_EL.documentReady);
  return /*#__PURE__*/_createClass(function FLOATING_SIDE_EL() {
    _classCallCheck(this, FLOATING_SIDE_EL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/form-progress/js/fn/form-progress-to-next.js

/*
 * Shows the next form.
 *
 * @param  {Element} selector        - Each target forms selector.
 * @param  {Element} formTarget      - Wrapper of target forms selector.
 * @param  {String} indicator       - Indicator of timeline.
 * @param  {Number} index           - Default index for initialization.
 * 									  0 => step one, 
 * 									  1 => step two
 * 									  2 => step three
 * 									  3 => step four
 * 									  4 => step five
 * 									  ...
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixFormProgressToNext = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: $('.uix-form-progress__target .uix-form-progress__target__step'),
      formTarget: $('.uix-form-progress__target'),
      indicator: '.uix-form-progress .uix-form-progress__indicator',
      index: 0
    }, options);
    this.each(function () {
      var $this = $(this);
      var transitionEnd = 'webkitTransitionEnd transitionend',
        $sections = settings.selector,
        $formTarget = settings.formTarget,
        $indicator = $(settings.indicator),
        allStep = $indicator.length,
        stepPerValue = 100 / (allStep - 1);
      var value = 0,
        tarIndex,
        curIndex;
      if ($indicator.length == 0) return false;

      //Returns current index
      if (settings.index > allStep - 1) {
        curIndex = allStep - 1;
      } else {
        curIndex = settings.index;
      }
      tarIndex = curIndex - 1;

      // Returns current index
      if (tarIndex > allStep - 2) {
        value = stepPerValue * (allStep - 2);
        curIndex = allStep - 2;
      } else {
        curIndex = tarIndex;
      }

      // Increment value (based on 4 steps 0 - 100)
      value = stepPerValue * curIndex;

      //Get form transition speed
      var dur = $formTarget.data('anime-speed');
      if ((0,esm_typeof/* default */.Z)(dur) === ( true ? "undefined" : 0)) {
        dur = '0.5s';
      }
      var durString = dur.toString().toLowerCase(),
        isMS = durString.indexOf('ms') >= 0,
        numberNum = durString.replace('ms', '').replace('s', ''),
        animeSpeed = isMS ? numberNum : numberNum * 1000;
      var currentFormStep = parseInt($sections.eq(tarIndex).attr('data-step')) || false,
        $nextForm = $formTarget.find('.uix-form-progress__target__step[data-step="' + (currentFormStep + 1) + '"]');
      var currentFormIndex = $nextForm.attr('data-step') - 1;
      if (isNaN(currentFormIndex)) currentFormIndex = 0;

      // Activate other unused modules
      if (currentFormIndex > 0) {
        for (var i = 0; i < curIndex; i++) {
          $sections.eq(i).addClass('leaving');
          $indicator.eq(i).addClass('is-active');
        }
        $indicator.eq(curIndex).addClass('is-active');
      }

      // Hide current form fields
      $sections.eq(tarIndex).addClass('leaving');
      setTimeout(function () {
        $indicator.eq(currentFormIndex).addClass('is-active');
      }, animeSpeed);

      // Show next form fields
      $nextForm.addClass('coming').one(transitionEnd, function () {
        $nextForm.removeClass('coming waiting');
      });

      // Active next form fields
      $sections.removeClass('is-active');
      $sections.eq(currentFormIndex).addClass('is-active');

      // Increment value (based on 4 steps 0 - 100)
      value += stepPerValue;

      //console.log( currentFormIndex );

      //Initialize pointer and form location data
      if (currentFormIndex == 0) {
        //Avoid initialization to always cover other same events
        $('body').addClass('form-progress-initok');

        //so something
        $indicator.removeClass('is-active');
        $indicator.each(function (index) {
          $(this).css('left', index * stepPerValue + '%');
          $formTarget.find('.uix-form-progress__target__step:eq(' + index + ')').attr('data-step', index + 1);
        });
        setTimeout(function () {
          $formTarget.addClass('js-uix-show');
        }, animeSpeed);
        $formTarget.find('.uix-form-progress__target__step').removeClass('left leaving').css({
          'position': 'absolute'
        }).not(':eq(0)').addClass('waiting');
      }

      //Set wrapper height
      var currentContentH = $formTarget.find('.uix-form-progress__target__step:eq(' + currentFormIndex + ') > .uix-form-progress__content').height() + 100;
      $formTarget.css('height', currentContentH + 'px');
      var curText = $('.uix-form-progress .uix-form-progress__indicator:eq(' + currentFormIndex + ') > span').html();
      $('#app-form-progress-text').text(curText);

      //The current indicator class
      $indicator.removeClass('current');
      $indicator.eq(currentFormIndex).addClass('current');

      // Reset if we've reached the end
      if (value >= 100) {
        $formTarget.find('.uix-form-progress__target__step').addClass('leaving').last().removeClass('coming waiting leaving');
      } else {
        $('.uix-form-progress').find('.uix-form-progress__indicator.is-active').next('.uix-form-progress__indicator').addClass('is-active');
      }

      // Set progress bar value
      $('.uix-form-progress .uix-form-progress__line span').css('width', value + '%');
      return false;
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form-progress/js/index.js



/* 
 *************************************
 * <!-- Form Progress -->
 *************************************
 */

/*
    Note:
	
	If you want to initialize the indicator to a location when the page is first run,
	you need to call the following function:
	
	$( 'body' ).waitForImages().done(function() {
		$( document ).UixFormProgressToNext({ 
			'selector'         : $( '.uix-form-progress__target .uix-form-progress__target__step' ),
			'formTarget'       : $( '.uix-form-progress__target' ),
			'indicator'        : '.uix-form-progress .uix-form-progress__indicator',
			'index'            : 0
		});
	});


*/





var FORM_PROGRESS = function (module, $, window, document) {
  if (window.FORM_PROGRESS === null) return false;
  module.FORM_PROGRESS = module.FORM_PROGRESS || {};
  module.FORM_PROGRESS.version = '0.0.5';
  module.FORM_PROGRESS.pageLoaded = function () {
    var $progressBar = $('.uix-form-progress progress'),
      $formTarget = $('.uix-form-progress__target'),
      $indicator = $('.uix-form-progress .uix-form-progress__indicator'),
      formAreaH = $formTarget.height(),
      allStep = $indicator.length,
      stepPerValue = 100 / (allStep - 1),
      value = 0,
      transitionEnd = 'webkitTransitionEnd transitionend';

    //Get form transition speed
    var dur = $formTarget.data('anime-speed');
    if ((0,esm_typeof/* default */.Z)(dur) === ( true ? "undefined" : 0)) {
      dur = '0.5s';
    }
    var durString = dur.toString().toLowerCase(),
      isMS = durString.indexOf('ms') >= 0,
      numberNum = durString.replace('ms', '').replace('s', ''),
      animeSpeed = isMS ? numberNum : numberNum * 1000;

    //Gets the party started.
    formReset();

    //Display the target
    setTimeout(function () {
      $formTarget.addClass('is-active');
    }, parseFloat(dur) * 1000);

    // Show next form on continue click
    $(document).off('click.FORM_PROGRESS').on('click.FORM_PROGRESS', '.uix-form-progress__target .go-step:not(.disable)', function (e) {
      e.preventDefault();
      var $sections = $(this).parents('.uix-form-progress__target__step');
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $formTarget,
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': $sections.index() + 1
      });

      //Scroll Top
      TweenMax.to(window, 0.5, {
        scrollTo: {
          y: 0,
          autoKill: false
        },
        ease: Power2.easeOut
      });
    });

    // Reset form on reset button click
    $(document).off('click.FORM_PROGRESS_RESET').on('click.FORM_PROGRESS_RESET', '.uix-form-progress__target .go-reset', function (e) {
      e.preventDefault();
      formReset();
    });

    /*
     * Resets the form back to the default state.
     *
     * @return {Void}
     */
    function formReset() {
      $(document).UixFormProgressToNext({
        'selector': $('.uix-form-progress__target .uix-form-progress__target__step'),
        'formTarget': $('.uix-form-progress__target'),
        'indicator': '.uix-form-progress .uix-form-progress__indicator',
        'index': 0
      });
    }
  };
  module.components.pageLoaded.push(module.FORM_PROGRESS.pageLoaded);
  return /*#__PURE__*/_createClass(function FORM_PROGRESS() {
    _classCallCheck(this, FORM_PROGRESS);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/form/js/fn/normal-radio.js

/*
 * Render Normal Radio
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderNormalRadio = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__radio'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);

        // Initialize status
        //------------------------------------------
        $this.find('> label').each(function () {
          var targetID = '#' + $(this).parent().attr("data-targetid");
          var switchIDs = '';

          //add switch IDs
          $(this).parent().find('> label').each(function () {
            if ((0,esm_typeof/* default */.Z)($(this).data("switchid")) != ( true ? "undefined" : 0)) {
              switchIDs += $(this).data("switchid") + ',';
            }
          });
          $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, ''));

          //Set actived style from their values
          if ((0,esm_typeof/* default */.Z)($(this).data('value')) != ( true ? "undefined" : 0)) {
            if ($(targetID).val() == $(this).data('value')) {
              $(this).addClass('is-active').find('[type="radio"]').prop('checked', true);
            } else {
              $(this).removeClass('is-active').find('[type="radio"]').prop('checked', false);
            }
          }
        });

        // Mouse events
        //------------------------------------------
        var normalRadioItem = settings.controls + ' > label';

        /*
        * Initialize single switch
        *
        * @param  {Element} obj                 - Radio controls. 
        * @return {Void}
        */
        var hideAllNormalRadioItems = function hideAllNormalRadioItems(obj) {
          obj.each(function (index) {
            var $sel = $(this),
              defaultValue = $('#' + $sel.attr("data-targetid")).val(),
              deffaultSwitchIndex = 0;

            //get default selected switch index
            $sel.find('> label').each(function (index) {
              if (defaultValue == $(this).data('value')) {
                deffaultSwitchIndex = index;
              }
            });
            if ((0,esm_typeof/* default */.Z)($sel.data('switchids')) != ( true ? "undefined" : 0) && $sel.data('switchids') != '') {
              var _switchIDsArr = $sel.data('switchids').split(',');
              _switchIDsArr.forEach(function (element, index) {
                if (deffaultSwitchIndex != index) {
                  $('#' + element).hide();
                } else {
                  $('#' + element).show();
                }
              });
            }
          });
        };
        hideAllNormalRadioItems($(settings.controls));
        $(document).off('click.FORM_NORMAL_RADIO').on('click.FORM_NORMAL_RADIO', normalRadioItem, function (e) {
          var $selector = $(this).parent(),
            $option = $(this),
            targetID = '#' + $selector.data("targetid"),
            switchID = '#' + $option.data("switchid"),
            curVal = $option.data('value');

          //Radio Selector
          $selector.find('> label').removeClass('is-active').find('[type="radio"]').prop('checked', false);
          $(targetID).val(curVal);
          $option.addClass('is-active').find('[type="radio"]').prop('checked', true);

          //Switch some options
          if ((0,esm_typeof/* default */.Z)($option.data("switchid")) != ( true ? "undefined" : 0)) {
            hideAllNormalRadioItems($selector);
            $(switchID).show();
          }

          //Dynamic listening for the latest value
          $(targetID).focus().blur();
        });
      });
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/third-party/jquery.mousewheel.esm.js
var jquery_mousewheel_esm = __webpack_require__(126);
;// CONCATENATED MODULE: ./src/components/form/js/third-party/jquery.datetimepicker.esm.js



/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014 - 2016
 * @version 1.3.4
 *
 * Date formatter utility library that allows formatting date/time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */
var DateFormatter;
!function () {
  "use strict";

  var t, _e, _r, n, a, u, i;
  u = 864e5, i = 3600, t = function t(_t, e) {
    return "string" == typeof _t && "string" == typeof e && _t.toLowerCase() === e.toLowerCase();
  }, _e = function e(t, r, n) {
    var a = n || "0",
      u = t.toString();
    return u.length < r ? _e(a + u, r) : u;
  }, _r = function r(t) {
    var e, n;
    for (t = t || {}, e = 1; e < arguments.length; e++) {
      if (n = arguments[e]) for (var a in n) {
        n.hasOwnProperty(a) && ("object" == (0,esm_typeof/* default */.Z)(n[a]) ? _r(t[a], n[a]) : t[a] = n[a]);
      }
    }
    return t;
  }, n = function n(t, e) {
    for (var r = 0; r < e.length; r++) {
      if (e[r].toLowerCase() === t.toLowerCase()) return r;
    }
    return -1;
  }, a = {
    dateSettings: {
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      daysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      monthsShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      meridiem: ["AM", "PM"],
      ordinal: function ordinal(t) {
        var e = t % 10,
          r = {
            1: "st",
            2: "nd",
            3: "rd"
          };
        return 1 !== Math.floor(t % 100 / 10) && r[e] ? r[e] : "th";
      }
    },
    separators: /[ \-+\/\.T:@]/g,
    validParts: /[dDjlNSwzWFmMntLoYyaABgGhHisueTIOPZcrU]/g,
    intParts: /[djwNzmnyYhHgGis]/g,
    tzParts: /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
    tzClip: /[^-+\dA-Z]/g
  }, DateFormatter = function DateFormatter(t) {
    var e = this,
      n = _r(a, t);
    e.dateSettings = n.dateSettings, e.separators = n.separators, e.validParts = n.validParts, e.intParts = n.intParts, e.tzParts = n.tzParts, e.tzClip = n.tzClip;
  }, DateFormatter.prototype = {
    constructor: DateFormatter,
    getMonth: function getMonth(t) {
      var e,
        r = this;
      return e = n(t, r.dateSettings.monthsShort) + 1, 0 === e && (e = n(t, r.dateSettings.months) + 1), e;
    },
    parseDate: function parseDate(e, r) {
      var n,
        a,
        u,
        i,
        s,
        o,
        c,
        f,
        l,
        h,
        d = this,
        g = !1,
        m = !1,
        p = d.dateSettings,
        y = {
          date: null,
          year: null,
          month: null,
          day: null,
          hour: 0,
          min: 0,
          sec: 0
        };
      if (!e) return null;
      if (e instanceof Date) return e;
      if ("U" === r) return u = parseInt(e), u ? new Date(1e3 * u) : e;
      switch ((0,esm_typeof/* default */.Z)(e)) {
        case "number":
          return new Date(e);
        case "string":
          break;
        default:
          return null;
      }
      if (n = r.match(d.validParts), !n || 0 === n.length) throw new Error("Invalid date format definition.");
      for (a = e.replace(d.separators, "\x00").split("\x00"), u = 0; u < a.length; u++) {
        switch (i = a[u], s = parseInt(i), n[u]) {
          case "y":
          case "Y":
            if (!s) return null;
            l = i.length, y.year = 2 === l ? parseInt((70 > s ? "20" : "19") + i) : s, g = !0;
            break;
          case "m":
          case "n":
          case "M":
          case "F":
            if (isNaN(s)) {
              if (o = d.getMonth(i), !(o > 0)) return null;
              y.month = o;
            } else {
              if (!(s >= 1 && 12 >= s)) return null;
              y.month = s;
            }
            g = !0;
            break;
          case "d":
          case "j":
            if (!(s >= 1 && 31 >= s)) return null;
            y.day = s, g = !0;
            break;
          case "g":
          case "h":
            if (c = n.indexOf("a") > -1 ? n.indexOf("a") : n.indexOf("A") > -1 ? n.indexOf("A") : -1, h = a[c], c > -1) f = t(h, p.meridiem[0]) ? 0 : t(h, p.meridiem[1]) ? 12 : -1, s >= 1 && 12 >= s && f > -1 ? y.hour = s + f - 1 : s >= 0 && 23 >= s && (y.hour = s);else {
              if (!(s >= 0 && 23 >= s)) return null;
              y.hour = s;
            }
            m = !0;
            break;
          case "G":
          case "H":
            if (!(s >= 0 && 23 >= s)) return null;
            y.hour = s, m = !0;
            break;
          case "i":
            if (!(s >= 0 && 59 >= s)) return null;
            y.min = s, m = !0;
            break;
          case "s":
            if (!(s >= 0 && 59 >= s)) return null;
            y.sec = s, m = !0;
        }
      }
      if (g === !0 && y.year && y.month && y.day) y.date = new Date(y.year, y.month - 1, y.day, y.hour, y.min, y.sec, 0);else {
        if (m !== !0) return null;
        y.date = new Date(0, 0, 0, y.hour, y.min, y.sec, 0);
      }
      return y.date;
    },
    guessDate: function guessDate(t, e) {
      if ("string" != typeof t) return t;
      var r,
        n,
        a,
        u,
        i,
        s,
        o = this,
        c = t.replace(o.separators, "\x00").split("\x00"),
        f = /^[djmn]/g,
        l = e.match(o.validParts),
        h = new Date(),
        d = 0;
      if (!f.test(l[0])) return t;
      for (a = 0; a < c.length; a++) {
        if (d = 2, i = c[a], s = parseInt(i.substr(0, 2)), isNaN(s)) return null;
        switch (a) {
          case 0:
            "m" === l[0] || "n" === l[0] ? h.setMonth(s - 1) : h.setDate(s);
            break;
          case 1:
            "m" === l[0] || "n" === l[0] ? h.setDate(s) : h.setMonth(s - 1);
            break;
          case 2:
            if (n = h.getFullYear(), r = i.length, d = 4 > r ? r : 4, n = parseInt(4 > r ? n.toString().substr(0, 4 - r) + i : i.substr(0, 4)), !n) return null;
            h.setFullYear(n);
            break;
          case 3:
            h.setHours(s);
            break;
          case 4:
            h.setMinutes(s);
            break;
          case 5:
            h.setSeconds(s);
        }
        u = i.substr(d), u.length > 0 && c.splice(a + 1, 0, u);
      }
      return h;
    },
    parseFormat: function parseFormat(t, r) {
      var n,
        a = this,
        s = a.dateSettings,
        o = /\\?(.?)/gi,
        _c = function c(t, e) {
          return n[t] ? n[t]() : e;
        };
      return n = {
        d: function d() {
          return _e(n.j(), 2);
        },
        D: function D() {
          return s.daysShort[n.w()];
        },
        j: function j() {
          return r.getDate();
        },
        l: function l() {
          return s.days[n.w()];
        },
        N: function N() {
          return n.w() || 7;
        },
        w: function w() {
          return r.getDay();
        },
        z: function z() {
          var t = new Date(n.Y(), n.n() - 1, n.j()),
            e = new Date(n.Y(), 0, 1);
          return Math.round((t - e) / u);
        },
        W: function W() {
          var t = new Date(n.Y(), n.n() - 1, n.j() - n.N() + 3),
            r = new Date(t.getFullYear(), 0, 4);
          return _e(1 + Math.round((t - r) / u / 7), 2);
        },
        F: function F() {
          return s.months[r.getMonth()];
        },
        m: function m() {
          return _e(n.n(), 2);
        },
        M: function M() {
          return s.monthsShort[r.getMonth()];
        },
        n: function n() {
          return r.getMonth() + 1;
        },
        t: function t() {
          return new Date(n.Y(), n.n(), 0).getDate();
        },
        L: function L() {
          var t = n.Y();
          return t % 4 === 0 && t % 100 !== 0 || t % 400 === 0 ? 1 : 0;
        },
        o: function o() {
          var t = n.n(),
            e = n.W(),
            r = n.Y();
          return r + (12 === t && 9 > e ? 1 : 1 === t && e > 9 ? -1 : 0);
        },
        Y: function Y() {
          return r.getFullYear();
        },
        y: function y() {
          return n.Y().toString().slice(-2);
        },
        a: function a() {
          return n.A().toLowerCase();
        },
        A: function A() {
          var t = n.G() < 12 ? 0 : 1;
          return s.meridiem[t];
        },
        B: function B() {
          var t = r.getUTCHours() * i,
            n = 60 * r.getUTCMinutes(),
            a = r.getUTCSeconds();
          return _e(Math.floor((t + n + a + i) / 86.4) % 1e3, 3);
        },
        g: function g() {
          return n.G() % 12 || 12;
        },
        G: function G() {
          return r.getHours();
        },
        h: function h() {
          return _e(n.g(), 2);
        },
        H: function H() {
          return _e(n.G(), 2);
        },
        i: function i() {
          return _e(r.getMinutes(), 2);
        },
        s: function s() {
          return _e(r.getSeconds(), 2);
        },
        u: function u() {
          return _e(1e3 * r.getMilliseconds(), 6);
        },
        e: function e() {
          var t = /\((.*)\)/.exec(String(r))[1];
          return t || "Coordinated Universal Time";
        },
        I: function I() {
          var t = new Date(n.Y(), 0),
            e = Date.UTC(n.Y(), 0),
            r = new Date(n.Y(), 6),
            a = Date.UTC(n.Y(), 6);
          return t - e !== r - a ? 1 : 0;
        },
        O: function O() {
          var t = r.getTimezoneOffset(),
            n = Math.abs(t);
          return (t > 0 ? "-" : "+") + _e(100 * Math.floor(n / 60) + n % 60, 4);
        },
        P: function P() {
          var t = n.O();
          return t.substr(0, 3) + ":" + t.substr(3, 2);
        },
        T: function T() {
          var t = (String(r).match(a.tzParts) || [""]).pop().replace(a.tzClip, "");
          return t || "UTC";
        },
        Z: function Z() {
          return 60 * -r.getTimezoneOffset();
        },
        c: function c() {
          return "Y-m-d\\TH:i:sP".replace(o, _c);
        },
        r: function r() {
          return "D, d M Y H:i:s O".replace(o, _c);
        },
        U: function U() {
          return r.getTime() / 1e3 || 0;
        }
      }, _c(t, t);
    },
    formatDate: function formatDate(t, e) {
      var r,
        n,
        a,
        u,
        i,
        s = this,
        o = "",
        c = "\\";
      if ("string" == typeof t && (t = s.parseDate(t, e), !t)) return null;
      if (t instanceof Date) {
        for (a = e.length, r = 0; a > r; r++) {
          i = e.charAt(r), "S" !== i && i !== c && (r > 0 && e.charAt(r - 1) === c ? o += i : (u = s.parseFormat(i, t), r !== a - 1 && s.intParts.test(i) && "S" === e.charAt(r + 1) && (n = parseInt(u) || 0, u += s.dateSettings.ordinal(n)), o += u));
        }
        return o;
      }
      return "";
    }
  };
}(); /**
     * @preserve jQuery DateTimePicker
     * @homepage http://xdsoft.net/jqplugins/datetimepicker/
     * @author Chupurnov Valeriy (<chupurnov@gmail.com>)
     */

(function ($) {
  'use strict';

  var default_options = {
    i18n: {
      ar: {
        // Arabic
        months: ["كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"],
        dayOfWeekShort: ["ن", "ث", "ع", "خ", "ج", "س", "ح"],
        dayOfWeek: ["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت", "الأحد"]
      },
      ro: {
        // Romanian
        months: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"],
        dayOfWeekShort: ["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"],
        dayOfWeek: ["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"]
      },
      id: {
        // Indonesian
        months: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
        dayOfWeek: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
      },
      is: {
        // Icelandic
        months: ["Janúar", "Febrúar", "Mars", "Apríl", "Maí", "Júní", "Júlí", "Ágúst", "September", "Október", "Nóvember", "Desember"],
        dayOfWeekShort: ["Sun", "Mán", "Þrið", "Mið", "Fim", "Fös", "Lau"],
        dayOfWeek: ["Sunnudagur", "Mánudagur", "Þriðjudagur", "Miðvikudagur", "Fimmtudagur", "Föstudagur", "Laugardagur"]
      },
      bg: {
        // Bulgarian
        months: ["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"],
        dayOfWeekShort: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"]
      },
      fa: {
        // Persian/Farsi
        months: ['فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'],
        dayOfWeekShort: ['یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'],
        dayOfWeek: ["یک‌شنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنج‌شنبه", "جمعه", "شنبه", "یک‌شنبه"]
      },
      ru: {
        // Russian
        months: ['Январь', 'Февраль', 'Март', 'Апрель', 'Май', 'Июнь', 'Июль', 'Август', 'Сентябрь', 'Октябрь', 'Ноябрь', 'Декабрь'],
        dayOfWeekShort: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
        dayOfWeek: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"]
      },
      uk: {
        // Ukrainian
        months: ['Січень', 'Лютий', 'Березень', 'Квітень', 'Травень', 'Червень', 'Липень', 'Серпень', 'Вересень', 'Жовтень', 'Листопад', 'Грудень'],
        dayOfWeekShort: ["Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"],
        dayOfWeek: ["Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"]
      },
      en: {
        // English
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      el: {
        // Ελληνικά
        months: ["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"],
        dayOfWeekShort: ["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"],
        dayOfWeek: ["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"]
      },
      de: {
        // German
        months: ['Januar', 'Februar', 'März', 'April', 'Mai', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'],
        dayOfWeekShort: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
        dayOfWeek: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
      },
      nl: {
        // Dutch
        months: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"],
        dayOfWeekShort: ["zo", "ma", "di", "wo", "do", "vr", "za"],
        dayOfWeek: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
      },
      tr: {
        // Turkish
        months: ["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"],
        dayOfWeekShort: ["Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"],
        dayOfWeek: ["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"]
      },
      fr: {
        //French
        months: ["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"],
        dayOfWeekShort: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
        dayOfWeek: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"]
      },
      es: {
        // Spanish
        months: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
        dayOfWeek: ["Domingo", "Lunes", "Martes", "Miércoles", "Jueves", "Viernes", "Sábado"]
      },
      th: {
        // Thai
        months: ['มกราคม', 'กุมภาพันธ์', 'มีนาคม', 'เมษายน', 'พฤษภาคม', 'มิถุนายน', 'กรกฎาคม', 'สิงหาคม', 'กันยายน', 'ตุลาคม', 'พฤศจิกายน', 'ธันวาคม'],
        dayOfWeekShort: ['อา.', 'จ.', 'อ.', 'พ.', 'พฤ.', 'ศ.', 'ส.'],
        dayOfWeek: ["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัส", "ศุกร์", "เสาร์", "อาทิตย์"]
      },
      pl: {
        // Polish
        months: ["styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"],
        dayOfWeekShort: ["nd", "pn", "wt", "śr", "cz", "pt", "sb"],
        dayOfWeek: ["niedziela", "poniedziałek", "wtorek", "środa", "czwartek", "piątek", "sobota"]
      },
      pt: {
        // Portuguese
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      ch: {
        // Simplified Chinese
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"]
      },
      se: {
        // Swedish
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"]
      },
      km: {
        // Khmer (ភាសាខ្មែរ)
        months: ["មករា​", "កុម្ភៈ", "មិនា​", "មេសា​", "ឧសភា​", "មិថុនា​", "កក្កដា​", "សីហា​", "កញ្ញា​", "តុលា​", "វិច្ឆិកា", "ធ្នូ​"],
        dayOfWeekShort: ["អាទិ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហ​​", "សុក្រ​", "សៅរ៍"],
        dayOfWeek: ["អាទិត្យ​", "ច័ន្ទ​", "អង្គារ​", "ពុធ​", "ព្រហស្បតិ៍​", "សុក្រ​", "សៅរ៍"]
      },
      kr: {
        // Korean
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      it: {
        // Italian
        months: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
        dayOfWeek: ["Domenica", "Lunedì", "Martedì", "Mercoledì", "Giovedì", "Venerdì", "Sabato"]
      },
      da: {
        // Dansk
        months: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"]
      },
      no: {
        // Norwegian
        months: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"],
        dayOfWeekShort: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
        dayOfWeek: ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag']
      },
      ja: {
        // Japanese
        months: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
        dayOfWeekShort: ["日", "月", "火", "水", "木", "金", "土"],
        dayOfWeek: ["日曜", "月曜", "火曜", "水曜", "木曜", "金曜", "土曜"]
      },
      vi: {
        // Vietnamese
        months: ["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"],
        dayOfWeekShort: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
        dayOfWeek: ["Chủ nhật", "Thứ hai", "Thứ ba", "Thứ tư", "Thứ năm", "Thứ sáu", "Thứ bảy"]
      },
      sl: {
        // Slovenščina
        months: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
        dayOfWeek: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "Četrtek", "Petek", "Sobota"]
      },
      cs: {
        // Čeština
        months: ["Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"],
        dayOfWeekShort: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"]
      },
      hu: {
        // Hungarian
        months: ["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"],
        dayOfWeekShort: ["Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"],
        dayOfWeek: ["vasárnap", "hétfő", "kedd", "szerda", "csütörtök", "péntek", "szombat"]
      },
      az: {
        //Azerbaijanian (Azeri)
        months: ["Yanvar", "Fevral", "Mart", "Aprel", "May", "Iyun", "Iyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"],
        dayOfWeekShort: ["B", "Be", "Ça", "Ç", "Ca", "C", "Ş"],
        dayOfWeek: ["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"]
      },
      bs: {
        //Bosanski
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ca: {
        //Català
        months: ["Gener", "Febrer", "Març", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"],
        dayOfWeekShort: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
        dayOfWeek: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
      },
      'en-GB': {
        //English (British)
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        dayOfWeekShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
      },
      et: {
        //"Eesti"
        months: ["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"],
        dayOfWeekShort: ["P", "E", "T", "K", "N", "R", "L"],
        dayOfWeek: ["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"]
      },
      eu: {
        //Euskara
        months: ["Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"],
        dayOfWeekShort: ["Ig.", "Al.", "Ar.", "Az.", "Og.", "Or.", "La."],
        dayOfWeek: ['Igandea', 'Astelehena', 'Asteartea', 'Asteazkena', 'Osteguna', 'Ostirala', 'Larunbata']
      },
      fi: {
        //Finnish (Suomi)
        months: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kesäkuu", "Heinäkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"],
        dayOfWeekShort: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
        dayOfWeek: ["sunnuntai", "maanantai", "tiistai", "keskiviikko", "torstai", "perjantai", "lauantai"]
      },
      gl: {
        //Galego
        months: ["Xan", "Feb", "Maz", "Abr", "Mai", "Xun", "Xul", "Ago", "Set", "Out", "Nov", "Dec"],
        dayOfWeekShort: ["Dom", "Lun", "Mar", "Mer", "Xov", "Ven", "Sab"],
        dayOfWeek: ["Domingo", "Luns", "Martes", "Mércores", "Xoves", "Venres", "Sábado"]
      },
      hr: {
        //Hrvatski
        months: ["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
        dayOfWeek: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"]
      },
      ko: {
        //Korean (한국어)
        months: ["1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"],
        dayOfWeekShort: ["일", "월", "화", "수", "목", "금", "토"],
        dayOfWeek: ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"]
      },
      lt: {
        //Lithuanian (lietuvių)
        months: ["Sausio", "Vasario", "Kovo", "Balandžio", "Gegužės", "Birželio", "Liepos", "Rugpjūčio", "Rugsėjo", "Spalio", "Lapkričio", "Gruodžio"],
        dayOfWeekShort: ["Sek", "Pir", "Ant", "Tre", "Ket", "Pen", "Šeš"],
        dayOfWeek: ["Sekmadienis", "Pirmadienis", "Antradienis", "Trečiadienis", "Ketvirtadienis", "Penktadienis", "Šeštadienis"]
      },
      lv: {
        //Latvian (Latviešu)
        months: ["Janvāris", "Februāris", "Marts", "Aprīlis ", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"],
        dayOfWeekShort: ["Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "St"],
        dayOfWeek: ["Svētdiena", "Pirmdiena", "Otrdiena", "Trešdiena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
      },
      mk: {
        //Macedonian (Македонски)
        months: ["јануари", "февруари", "март", "април", "мај", "јуни", "јули", "август", "септември", "октомври", "ноември", "декември"],
        dayOfWeekShort: ["нед", "пон", "вто", "сре", "чет", "пет", "саб"],
        dayOfWeek: ["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"]
      },
      mn: {
        //Mongolian (Монгол)
        months: ["1-р сар", "2-р сар", "3-р сар", "4-р сар", "5-р сар", "6-р сар", "7-р сар", "8-р сар", "9-р сар", "10-р сар", "11-р сар", "12-р сар"],
        dayOfWeekShort: ["Дав", "Мяг", "Лха", "Пүр", "Бсн", "Бям", "Ням"],
        dayOfWeek: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
      },
      'pt-BR': {
        //Português(Brasil)
        months: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
        dayOfWeekShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
        dayOfWeek: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"]
      },
      sk: {
        //Slovenčina
        months: ["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"],
        dayOfWeekShort: ["Ne", "Po", "Ut", "St", "Št", "Pi", "So"],
        dayOfWeek: ["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"]
      },
      sq: {
        //Albanian (Shqip)
        months: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"],
        dayOfWeekShort: ["Die", "Hën", "Mar", "Mër", "Enj", "Pre", "Shtu"],
        dayOfWeek: ["E Diel", "E Hënë", "E Martē", "E Mërkurë", "E Enjte", "E Premte", "E Shtunë"]
      },
      'sr-YU': {
        //Serbian (Srpski)
        months: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"],
        dayOfWeekShort: ["Ned", "Pon", "Uto", "Sre", "čet", "Pet", "Sub"],
        dayOfWeek: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"]
      },
      sr: {
        //Serbian Cyrillic (Српски)
        months: ["јануар", "фебруар", "март", "април", "мај", "јун", "јул", "август", "септембар", "октобар", "новембар", "децембар"],
        dayOfWeekShort: ["нед", "пон", "уто", "сре", "чет", "пет", "суб"],
        dayOfWeek: ["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"]
      },
      sv: {
        //Svenska
        months: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"],
        dayOfWeekShort: ["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"],
        dayOfWeek: ["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"]
      },
      'zh-TW': {
        //Traditional Chinese (繁體中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      zh: {
        //Simplified Chinese (简体中文)
        months: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
        dayOfWeekShort: ["日", "一", "二", "三", "四", "五", "六"],
        dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
      },
      ug: {
        // Uyghur(ئۇيغۇرچە)
        months: ["1-ئاي", "2-ئاي", "3-ئاي", "4-ئاي", "5-ئاي", "6-ئاي", "7-ئاي", "8-ئاي", "9-ئاي", "10-ئاي", "11-ئاي", "12-ئاي"],
        dayOfWeek: ["يەكشەنبە", "دۈشەنبە", "سەيشەنبە", "چارشەنبە", "پەيشەنبە", "جۈمە", "شەنبە"]
      },
      he: {
        //Hebrew (עברית)
        months: ['ינואר', 'פברואר', 'מרץ', 'אפריל', 'מאי', 'יוני', 'יולי', 'אוגוסט', 'ספטמבר', 'אוקטובר', 'נובמבר', 'דצמבר'],
        dayOfWeekShort: ['א\'', 'ב\'', 'ג\'', 'ד\'', 'ה\'', 'ו\'', 'שבת'],
        dayOfWeek: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת", "ראשון"]
      },
      hy: {
        // Armenian
        months: ["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"],
        dayOfWeekShort: ["Կի", "Երկ", "Երք", "Չոր", "Հնգ", "Ուրբ", "Շբթ"],
        dayOfWeek: ["Կիրակի", "Երկուշաբթի", "Երեքշաբթի", "Չորեքշաբթի", "Հինգշաբթի", "Ուրբաթ", "Շաբաթ"]
      },
      kg: {
        // Kyrgyz
        months: ['Үчтүн айы', 'Бирдин айы', 'Жалган Куран', 'Чын Куран', 'Бугу', 'Кулжа', 'Теке', 'Баш Оона', 'Аяк Оона', 'Тогуздун айы', 'Жетинин айы', 'Бештин айы'],
        dayOfWeekShort: ["Жек", "Дүй", "Шей", "Шар", "Бей", "Жум", "Ише"],
        dayOfWeek: ["Жекшемб", "Дүйшөмб", "Шейшемб", "Шаршемб", "Бейшемби", "Жума", "Ишенб"]
      },
      rm: {
        // Romansh
        months: ["Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October", "November", "December"],
        dayOfWeekShort: ["Du", "Gli", "Ma", "Me", "Gie", "Ve", "So"],
        dayOfWeek: ["Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"]
      },
      ka: {
        // Georgian
        months: ['იანვარი', 'თებერვალი', 'მარტი', 'აპრილი', 'მაისი', 'ივნისი', 'ივლისი', 'აგვისტო', 'სექტემბერი', 'ოქტომბერი', 'ნოემბერი', 'დეკემბერი'],
        dayOfWeekShort: ["კვ", "ორშ", "სამშ", "ოთხ", "ხუთ", "პარ", "შაბ"],
        dayOfWeek: ["კვირა", "ორშაბათი", "სამშაბათი", "ოთხშაბათი", "ხუთშაბათი", "პარასკევი", "შაბათი"]
      }
    },
    ownerDocument: document,
    contentWindow: window,
    value: '',
    rtl: false,
    format: 'Y/m/d H:i',
    formatTime: 'H:i',
    formatDate: 'Y/m/d',
    startDate: false,
    // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05',
    step: 60,
    monthChangeSpinner: true,
    closeOnDateSelect: false,
    closeOnTimeSelect: true,
    closeOnWithoutClick: true,
    closeOnInputClick: true,
    openOnFocus: true,
    timepicker: true,
    datepicker: true,
    weeks: false,
    defaultTime: false,
    // use formatTime format (ex. '10:00' for formatTime:	'H:i')
    defaultDate: false,
    // use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')

    minDate: false,
    maxDate: false,
    minTime: false,
    maxTime: false,
    minDateTime: false,
    maxDateTime: false,
    allowTimes: [],
    opened: false,
    initTime: true,
    inline: false,
    theme: '',
    touchMovedThreshold: 5,
    onSelectDate: function onSelectDate() {},
    onSelectTime: function onSelectTime() {},
    onChangeMonth: function onChangeMonth() {},
    onGetWeekOfYear: function onGetWeekOfYear() {},
    onChangeYear: function onChangeYear() {},
    onChangeDateTime: function onChangeDateTime() {},
    onShow: function onShow() {},
    onClose: function onClose() {},
    onGenerate: function onGenerate() {},
    withoutCopyright: true,
    inverseButton: false,
    hours12: false,
    next: 'xdsoft_next',
    prev: 'xdsoft_prev',
    dayOfWeekStart: 0,
    parentID: 'body',
    timeHeightInTimePicker: 25,
    timepickerScrollbar: true,
    todayButton: true,
    prevButton: true,
    nextButton: true,
    defaultSelect: true,
    scrollMonth: true,
    scrollTime: true,
    scrollInput: true,
    lazyInit: false,
    mask: false,
    validateOnBlur: true,
    allowBlank: true,
    yearStart: 1950,
    yearEnd: 2050,
    monthStart: 0,
    monthEnd: 11,
    style: '',
    id: '',
    fixed: false,
    roundTime: 'round',
    // ceil, floor
    className: '',
    weekends: [],
    highlightedDates: [],
    highlightedPeriods: [],
    allowDates: [],
    allowDateRe: null,
    disabledDates: [],
    disabledWeekDays: [],
    yearOffset: 0,
    beforeShowDay: null,
    enterLikeTab: true,
    showApplyButton: false,
    insideParent: false
  };
  var dateHelper = null,
    defaultDateHelper = null,
    globalLocaleDefault = 'en',
    globalLocale = 'en';
  var dateFormatterOptionsDefault = {
    meridiem: ['AM', 'PM']
  };
  var initDateFormatter = function initDateFormatter() {
    var locale = default_options.i18n[globalLocale],
      opts = {
        days: locale.dayOfWeek,
        daysShort: locale.dayOfWeekShort,
        months: locale.months,
        monthsShort: $.map(locale.months, function (n) {
          return n.substring(0, 3);
        })
      };
    if (typeof DateFormatter === 'function') {
      dateHelper = defaultDateHelper = new DateFormatter({
        dateSettings: $.extend({}, dateFormatterOptionsDefault, opts)
      });
    }
  };
  var dateFormatters = {
    moment: {
      default_options: {
        format: 'YYYY/MM/DD HH:mm',
        formatDate: 'YYYY/MM/DD',
        formatTime: 'HH:mm'
      },
      formatter: {
        parseDate: function parseDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.parseDate(date, format);
          }
          var d = moment(date, format);
          return d.isValid() ? d.toDate() : false;
        },
        formatDate: function formatDate(date, format) {
          if (isFormatStandard(format)) {
            return defaultDateHelper.formatDate(date, format);
          }
          return moment(date).format(format);
        },
        formatMask: function formatMask(format) {
          return format.replace(/Y{4}/g, '9999').replace(/Y{2}/g, '99').replace(/M{2}/g, '19').replace(/D{2}/g, '39').replace(/H{2}/g, '29').replace(/m{2}/g, '59').replace(/s{2}/g, '59');
        }
      }
    }
  };

  // for locale settings
  $.datetimepicker = {
    setLocale: function setLocale(locale) {
      var newLocale = default_options.i18n[locale] ? locale : globalLocaleDefault;
      if (globalLocale !== newLocale) {
        globalLocale = newLocale;
        // reinit date formatter
        initDateFormatter();
      }
    },
    setDateFormatter: function setDateFormatter(dateFormatter) {
      if (typeof dateFormatter === 'string' && dateFormatters.hasOwnProperty(dateFormatter)) {
        var df = dateFormatters[dateFormatter];
        $.extend(default_options, df.default_options);
        dateHelper = df.formatter;
      } else {
        dateHelper = dateFormatter;
      }
    }
  };
  var standardFormats = {
    RFC_2822: 'D, d M Y H:i:s O',
    ATOM: 'Y-m-d\TH:i:sP',
    ISO_8601: 'Y-m-d\TH:i:sO',
    RFC_822: 'D, d M y H:i:s O',
    RFC_850: 'l, d-M-y H:i:s T',
    RFC_1036: 'D, d M y H:i:s O',
    RFC_1123: 'D, d M Y H:i:s O',
    RSS: 'D, d M Y H:i:s O',
    W3C: 'Y-m-d\TH:i:sP'
  };
  var isFormatStandard = function isFormatStandard(format) {
    return Object.values(standardFormats).indexOf(format) === -1 ? false : true;
  };
  $.extend($.datetimepicker, standardFormats);

  // first init date formatter
  initDateFormatter();

  // fix for ie8
  if (!window.getComputedStyle) {
    window.getComputedStyle = function (el) {
      this.el = el;
      this.getPropertyValue = function (prop) {
        var re = /(-([a-z]))/g;
        if (prop === 'float') {
          prop = 'styleFloat';
        }
        if (re.test(prop)) {
          prop = prop.replace(re, function (a, b, c) {
            return c.toUpperCase();
          });
        }
        return el.currentStyle[prop] || null;
      };
      return this;
    };
  }
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (obj, start) {
      var i, j;
      for (i = start || 0, j = this.length; i < j; i += 1) {
        if (this[i] === obj) {
          return i;
        }
      }
      return -1;
    };
  }
  Date.prototype.countDaysInMonth = function () {
    return new Date(this.getFullYear(), this.getMonth() + 1, 0).getDate();
  };
  $.fn.xdsoftScroller = function (options, percent) {
    return this.each(function () {
      var timeboxparent = $(this),
        pointerEventToXY = function pointerEventToXY(e) {
          var out = {
              x: 0,
              y: 0
            },
            touch;
          if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
            touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
            out.x = touch.clientX;
            out.y = touch.clientY;
          } else if (e.type === 'mousedown' || e.type === 'mouseup' || e.type === 'mousemove' || e.type === 'mouseover' || e.type === 'mouseout' || e.type === 'mouseenter' || e.type === 'mouseleave') {
            out.x = e.clientX;
            out.y = e.clientY;
          }
          return out;
        },
        timebox,
        parentHeight,
        height,
        scrollbar,
        scroller,
        maximumOffset = 100,
        start = false,
        startY = 0,
        startTop = 0,
        h1 = 0,
        touchStart = false,
        startTopScroll = 0,
        calcOffset = function calcOffset() {};
      if (percent === 'hide') {
        timeboxparent.find('.xdsoft_scrollbar').hide();
        return;
      }
      if (!$(this).hasClass('xdsoft_scroller_box')) {
        timebox = timeboxparent.children().eq(0);
        parentHeight = timeboxparent[0].clientHeight;
        height = timebox[0].offsetHeight;
        scrollbar = $('<div class="xdsoft_scrollbar"></div>');
        scroller = $('<div class="xdsoft_scroller"></div>');
        scrollbar.append(scroller);
        timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
        calcOffset = function calcOffset(event) {
          var offset = pointerEventToXY(event).y - startY + startTopScroll;
          if (offset < 0) {
            offset = 0;
          }
          if (offset + scroller[0].offsetHeight > h1) {
            offset = h1 - scroller[0].offsetHeight;
          }
          timeboxparent.trigger('scroll_element.xdsoft_scroller', [maximumOffset ? offset / maximumOffset : 0]);
        };
        scroller.on('touchstart.xdsoft_scroller mousedown.xdsoft_scroller', function (event) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
          }
          startY = pointerEventToXY(event).y;
          startTopScroll = parseInt(scroller.css('margin-top'), 10);
          h1 = scrollbar[0].offsetHeight;
          if (event.type === 'mousedown' || event.type === 'touchstart') {
            if (options.ownerDocument) {
              $(options.ownerDocument.body).addClass('xdsoft_noselect');
            }
            $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft_scroller', function arguments_callee() {
              $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft_scroller', arguments_callee).off('mousemove.xdsoft_scroller', calcOffset).removeClass('xdsoft_noselect');
            });
            $(options.ownerDocument.body).on('mousemove.xdsoft_scroller', calcOffset);
          } else {
            touchStart = true;
            event.stopPropagation();
            event.preventDefault();
          }
        }).on('touchmove', function (event) {
          if (touchStart) {
            event.preventDefault();
            calcOffset(event);
          }
        }).on('touchend touchcancel', function () {
          touchStart = false;
          startTopScroll = 0;
        });
        timeboxparent.on('scroll_element.xdsoft_scroller', function (event, percentage) {
          if (!parentHeight) {
            timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percentage, true]);
          }
          percentage = percentage > 1 ? 1 : percentage < 0 || isNaN(percentage) ? 0 : percentage;
          scroller.css('margin-top', maximumOffset * percentage);
          setTimeout(function () {
            timebox.css('marginTop', -parseInt((timebox[0].offsetHeight - parentHeight) * percentage, 10));
          }, 10);
        }).on('resize_scroll.xdsoft_scroller', function (event, percentage, noTriggerScroll) {
          var percent, sh;
          parentHeight = timeboxparent[0].clientHeight;
          height = timebox[0].offsetHeight;
          percent = parentHeight / height;
          sh = percent * scrollbar[0].offsetHeight;
          if (percent > 1) {
            scroller.hide();
          } else {
            scroller.show();
            scroller.css('height', parseInt(sh > 10 ? sh : 10, 10));
            maximumOffset = scrollbar[0].offsetHeight - scroller[0].offsetHeight;
            if (noTriggerScroll !== true) {
              timeboxparent.trigger('scroll_element.xdsoft_scroller', [percentage || Math.abs(parseInt(timebox.css('marginTop'), 10)) / (height - parentHeight)]);
            }
          }
        });
        timeboxparent.on('mousewheel', function (event) {
          var top = Math.abs(parseInt(timebox.css('marginTop'), 10));
          top = top - event.deltaY * 20;
          if (top < 0) {
            top = 0;
          }
          timeboxparent.trigger('scroll_element.xdsoft_scroller', [top / (height - parentHeight)]);
          event.stopPropagation();
          return false;
        });
        timeboxparent.on('touchstart', function (event) {
          start = pointerEventToXY(event);
          startTop = Math.abs(parseInt(timebox.css('marginTop'), 10));
        });
        timeboxparent.on('touchmove', function (event) {
          if (start) {
            event.preventDefault();
            var coord = pointerEventToXY(event);
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [(startTop - (coord.y - start.y)) / (height - parentHeight)]);
          }
        });
        timeboxparent.on('touchend touchcancel', function () {
          start = false;
          startTop = 0;
        });
      }
      timeboxparent.trigger('resize_scroll.xdsoft_scroller', [percent]);
    });
  };
  $.fn.datetimepicker = function (opt, opt2) {
    var result = this,
      KEY0 = 48,
      KEY9 = 57,
      _KEY0 = 96,
      _KEY9 = 105,
      CTRLKEY = 17,
      CMDKEY = 91,
      DEL = 46,
      ENTER = 13,
      ESC = 27,
      BACKSPACE = 8,
      ARROWLEFT = 37,
      ARROWUP = 38,
      ARROWRIGHT = 39,
      ARROWDOWN = 40,
      TAB = 9,
      F5 = 116,
      AKEY = 65,
      CKEY = 67,
      VKEY = 86,
      ZKEY = 90,
      YKEY = 89,
      ctrlDown = false,
      cmdDown = false,
      options = $.isPlainObject(opt) || !opt ? $.extend(true, {}, default_options, opt) : $.extend(true, {}, default_options),
      lazyInitTimer = 0,
      createDateTimePicker,
      destroyDateTimePicker,
      lazyInit = function lazyInit(input) {
        input.on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function initOnActionCallback() {
          if (input.is(':disabled') || input.data('xdsoft_datetimepicker')) {
            return;
          }
          clearTimeout(lazyInitTimer);
          lazyInitTimer = setTimeout(function () {
            if (!input.data('xdsoft_datetimepicker')) {
              createDateTimePicker(input);
            }
            input.off('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', initOnActionCallback).trigger('open.xdsoft');
          }, 100);
        });
      };
    createDateTimePicker = function createDateTimePicker(input) {
      var datetimepicker = $('<div class="xdsoft_datetimepicker xdsoft_noselect"></div>'),
        xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
        datepicker = $('<div class="xdsoft_datepicker active"></div>'),
        month_picker = $('<div class="xdsoft_monthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button>' + '<div class="xdsoft_label xdsoft_month"><span></span><i></i></div>' + '<div class="xdsoft_label xdsoft_year"><span></span><i></i></div>' + '<button type="button" class="xdsoft_next"></button></div>'),
        calendar = $('<div class="xdsoft_calendar"></div>'),
        timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
        timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
        timebox = $('<div class="xdsoft_time_variant"></div>'),
        applyButton = $('<button type="button" class="xdsoft_save_selected blue-gradient-button">Save Selected</button>'),
        monthselect = $('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
        yearselect = $('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>'),
        triggerAfterOpen = false,
        XDSoft_datetime,
        xchangeTimer,
        timerclick,
        current_time_index,
        setPos,
        timer = 0,
        _xdsoft_datetime,
        forEachAncestorOf;
      if (options.id) {
        datetimepicker.attr('id', options.id);
      }
      if (options.style) {
        datetimepicker.attr('style', options.style);
      }
      if (options.weeks) {
        datetimepicker.addClass('xdsoft_showweeks');
      }
      if (options.rtl) {
        datetimepicker.addClass('xdsoft_rtl');
      }
      datetimepicker.addClass('xdsoft_' + options.theme);
      datetimepicker.addClass(options.className);
      month_picker.find('.xdsoft_month span').after(monthselect);
      month_picker.find('.xdsoft_year span').after(yearselect);
      month_picker.find('.xdsoft_month,.xdsoft_year').on('touchstart mousedown.xdsoft', function (event) {
        var select = $(this).find('.xdsoft_select').eq(0),
          val = 0,
          top = 0,
          visible = select.is(':visible'),
          items,
          i;
        month_picker.find('.xdsoft_select').hide();
        if (_xdsoft_datetime.currentTime) {
          val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month') ? 'getMonth' : 'getFullYear']();
        }
        select[visible ? 'hide' : 'show']();
        for (items = select.find('div.xdsoft_option'), i = 0; i < items.length; i += 1) {
          if (items.eq(i).data('value') === val) {
            break;
          } else {
            top += items[0].offsetHeight;
          }
        }
        select.xdsoftScroller(options, top / (select.children()[0].offsetHeight - select[0].clientHeight));
        event.stopPropagation();
        return false;
      });
      var handleTouchMoved = function handleTouchMoved(event) {
        var evt = event.originalEvent;
        var touchPosition = evt.touches ? evt.touches[0] : evt;
        this.touchStartPosition = this.touchStartPosition || touchPosition;
        var xMovement = Math.abs(this.touchStartPosition.clientX - touchPosition.clientX);
        var yMovement = Math.abs(this.touchStartPosition.clientY - touchPosition.clientY);
        var distance = Math.sqrt(xMovement * xMovement + yMovement * yMovement);
        if (distance > options.touchMovedThreshold) {
          this.touchMoved = true;
        }
      };
      month_picker.find('.xdsoft_select').xdsoftScroller(options).on('touchstart mousedown.xdsoft', function (event) {
        var evt = event.originalEvent;
        this.touchMoved = false;
        this.touchStartPosition = evt.touches ? evt.touches[0] : evt;
        event.stopPropagation();
        event.preventDefault();
      }).on('touchmove', '.xdsoft_option', handleTouchMoved).on('touchend mousedown.xdsoft', '.xdsoft_option', function () {
        if (!this.touchMoved) {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }
          var year = _xdsoft_datetime.currentTime.getFullYear();
          if (_xdsoft_datetime && _xdsoft_datetime.currentTime) {
            _xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect') ? 'setMonth' : 'setFullYear']($(this).data('value'));
          }
          $(this).parent().parent().hide();
          datetimepicker.trigger('xchange.xdsoft');
          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
          if (year !== _xdsoft_datetime.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
        }
      });
      datetimepicker.getValue = function () {
        return _xdsoft_datetime.getCurrentTime();
      };
      datetimepicker.setOptions = function (_options) {
        var highlightedDates = {};
        options = $.extend(true, {}, options, _options);
        if (_options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length) {
          options.allowTimes = $.extend(true, [], _options.allowTimes);
        }
        if (_options.weekends && $.isArray(_options.weekends) && _options.weekends.length) {
          options.weekends = $.extend(true, [], _options.weekends);
        }
        if (_options.allowDates && $.isArray(_options.allowDates) && _options.allowDates.length) {
          options.allowDates = $.extend(true, [], _options.allowDates);
        }
        if (_options.allowDateRe && Object.prototype.toString.call(_options.allowDateRe) === "[object String]") {
          options.allowDateRe = new RegExp(_options.allowDateRe);
        }
        if (_options.highlightedDates && $.isArray(_options.highlightedDates) && _options.highlightedDates.length) {
          $.each(_options.highlightedDates, function (index, value) {
            var splitData = $.map(value.split(','), $.trim),
              exDesc,
              hDate = new HighlightedDate(dateHelper.parseDate(splitData[0], options.formatDate), splitData[1], splitData[2]),
              // date, desc, style
              keyDate = dateHelper.formatDate(hDate.date, options.formatDate);
            if (highlightedDates[keyDate] !== undefined) {
              exDesc = highlightedDates[keyDate].desc;
              if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
              }
            } else {
              highlightedDates[keyDate] = hDate;
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }
        if (_options.highlightedPeriods && $.isArray(_options.highlightedPeriods) && _options.highlightedPeriods.length) {
          highlightedDates = $.extend(true, [], options.highlightedDates);
          $.each(_options.highlightedPeriods, function (index, value) {
            var dateTest,
              // start date
              dateEnd, desc, hDate, keyDate, exDesc, style;
            if ($.isArray(value)) {
              dateTest = value[0];
              dateEnd = value[1];
              desc = value[2];
              style = value[3];
            } else {
              var splitData = $.map(value.split(','), $.trim);
              dateTest = dateHelper.parseDate(splitData[0], options.formatDate);
              dateEnd = dateHelper.parseDate(splitData[1], options.formatDate);
              desc = splitData[2];
              style = splitData[3];
            }
            while (dateTest <= dateEnd) {
              hDate = new HighlightedDate(dateTest, desc, style);
              keyDate = dateHelper.formatDate(dateTest, options.formatDate);
              dateTest.setDate(dateTest.getDate() + 1);
              if (highlightedDates[keyDate] !== undefined) {
                exDesc = highlightedDates[keyDate].desc;
                if (exDesc && exDesc.length && hDate.desc && hDate.desc.length) {
                  highlightedDates[keyDate].desc = exDesc + "\n" + hDate.desc;
                }
              } else {
                highlightedDates[keyDate] = hDate;
              }
            }
          });
          options.highlightedDates = $.extend(true, [], highlightedDates);
        }
        if (_options.disabledDates && $.isArray(_options.disabledDates) && _options.disabledDates.length) {
          options.disabledDates = $.extend(true, [], _options.disabledDates);
        }
        if (_options.disabledWeekDays && $.isArray(_options.disabledWeekDays) && _options.disabledWeekDays.length) {
          options.disabledWeekDays = $.extend(true, [], _options.disabledWeekDays);
        }
        if ((options.open || options.opened) && !options.inline) {
          input.trigger('open.xdsoft');
        }
        if (options.inline) {
          triggerAfterOpen = true;
          datetimepicker.addClass('xdsoft_inline');
          input.after(datetimepicker).hide();
        }
        if (options.inverseButton) {
          options.next = 'xdsoft_prev';
          options.prev = 'xdsoft_next';
        }
        if (options.datepicker) {
          datepicker.addClass('active');
        } else {
          datepicker.removeClass('active');
        }
        if (options.timepicker) {
          timepicker.addClass('active');
        } else {
          timepicker.removeClass('active');
        }
        if (options.value) {
          _xdsoft_datetime.setCurrentTime(options.value);
          if (input && input.val) {
            input.val(_xdsoft_datetime.str);
          }
        }
        if (isNaN(options.dayOfWeekStart)) {
          options.dayOfWeekStart = 0;
        } else {
          options.dayOfWeekStart = parseInt(options.dayOfWeekStart, 10) % 7;
        }
        if (!options.timepickerScrollbar) {
          timeboxparent.xdsoftScroller(options, 'hide');
        }
        if (options.minDate && /^[\+\-](.*)$/.test(options.minDate)) {
          options.minDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.minDate), options.formatDate);
        }
        if (options.maxDate && /^[\+\-](.*)$/.test(options.maxDate)) {
          options.maxDate = dateHelper.formatDate(_xdsoft_datetime.strToDateTime(options.maxDate), options.formatDate);
        }
        if (options.minDateTime && /^\+(.*)$/.test(options.minDateTime)) {
          options.minDateTime = _xdsoft_datetime.strToDateTime(options.minDateTime).dateFormat(options.formatDate);
        }
        if (options.maxDateTime && /^\+(.*)$/.test(options.maxDateTime)) {
          options.maxDateTime = _xdsoft_datetime.strToDateTime(options.maxDateTime).dateFormat(options.formatDate);
        }
        applyButton.toggle(options.showApplyButton);
        month_picker.find('.xdsoft_today_button').css('visibility', !options.todayButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.prev).css('visibility', !options.prevButton ? 'hidden' : 'visible');
        month_picker.find('.' + options.next).css('visibility', !options.nextButton ? 'hidden' : 'visible');
        setMask(options);
        if (options.validateOnBlur) {
          input.off('blur.xdsoft').on('blur.xdsoft', function () {
            if (options.allowBlank && (!$.trim($(this).val()).length || typeof options.mask === "string" && $.trim($(this).val()) === options.mask.replace(/[0-9]/g, '_'))) {
              $(this).val(null);
              datetimepicker.data('xdsoft_datetime').empty();
            } else {
              var d = dateHelper.parseDate($(this).val(), options.format);
              if (d) {
                // parseDate() may skip some invalid parts like date or time, so make it clear for user: show parsed date/time
                $(this).val(dateHelper.formatDate(d, options.format));
              } else {
                var splittedHours = +[$(this).val()[0], $(this).val()[1]].join(''),
                  splittedMinutes = +[$(this).val()[2], $(this).val()[3]].join('');

                // parse the numbers as 0312 => 03:12
                if (!options.datepicker && options.timepicker && splittedHours >= 0 && splittedHours < 24 && splittedMinutes >= 0 && splittedMinutes < 60) {
                  $(this).val([splittedHours, splittedMinutes].map(function (item) {
                    return item > 9 ? item : '0' + item;
                  }).join(':'));
                } else {
                  $(this).val(dateHelper.formatDate(_xdsoft_datetime.now(), options.format));
                }
              }
              datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
            }
            datetimepicker.trigger('changedatetime.xdsoft');
            datetimepicker.trigger('close.xdsoft');
          });
        }
        options.dayOfWeekStartPrev = options.dayOfWeekStart === 0 ? 6 : options.dayOfWeekStart - 1;
        datetimepicker.trigger('xchange.xdsoft').trigger('afterOpen.xdsoft');
      };
      datetimepicker.data('options', options).on('touchstart mousedown.xdsoft', function (event) {
        event.stopPropagation();
        event.preventDefault();
        yearselect.hide();
        monthselect.hide();
        return false;
      });

      //scroll_element = timepicker.find('.xdsoft_time_box');
      timeboxparent.append(timebox);
      timeboxparent.xdsoftScroller(options);
      datetimepicker.on('afterOpen.xdsoft', function () {
        timeboxparent.xdsoftScroller(options);
      });
      datetimepicker.append(datepicker).append(timepicker);
      if (options.withoutCopyright !== true) {
        datetimepicker.append(xdsoft_copyright);
      }
      datepicker.append(month_picker).append(calendar).append(applyButton);
      if (options.insideParent) {
        $(input).parent().append(datetimepicker);
      } else {
        $(options.parentID).append(datetimepicker);
      }
      XDSoft_datetime = function XDSoft_datetime() {
        var _this = this;
        _this.now = function (norecursion) {
          var d = new Date(),
            date,
            time;
          if (!norecursion && options.defaultDate) {
            date = _this.strToDateTime(options.defaultDate);
            d.setFullYear(date.getFullYear());
            d.setMonth(date.getMonth());
            d.setDate(date.getDate());
          }
          d.setFullYear(d.getFullYear());
          if (!norecursion && options.defaultTime) {
            time = _this.strtotime(options.defaultTime);
            d.setHours(time.getHours());
            d.setMinutes(time.getMinutes());
            d.setSeconds(time.getSeconds());
            d.setMilliseconds(time.getMilliseconds());
          }
          return d;
        };
        _this.isValidDate = function (d) {
          if (Object.prototype.toString.call(d) !== "[object Date]") {
            return false;
          }
          return !isNaN(d.getTime());
        };
        _this.setCurrentTime = function (dTime, requireValidDate) {
          if (typeof dTime === 'string') {
            _this.currentTime = _this.strToDateTime(dTime);
          } else if (_this.isValidDate(dTime)) {
            _this.currentTime = dTime;
          } else if (!dTime && !requireValidDate && options.allowBlank && !options.inline) {
            _this.currentTime = null;
          } else {
            _this.currentTime = _this.now();
          }
          datetimepicker.trigger('xchange.xdsoft');
        };
        _this.empty = function () {
          _this.currentTime = null;
        };
        _this.getCurrentTime = function () {
          return _this.currentTime;
        };
        _this.nextMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }
          var month = _this.currentTime.getMonth() + 1,
            year;
          if (month === 12) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() + 1);
            month = 0;
          }
          year = _this.currentTime.getFullYear();
          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));
          _this.currentTime.setMonth(month);
          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
          if (year !== _this.currentTime.getFullYear() && $.isFunction(options.onChangeYear)) {
            options.onChangeYear.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };
        _this.prevMonth = function () {
          if (_this.currentTime === undefined || _this.currentTime === null) {
            _this.currentTime = _this.now();
          }
          var month = _this.currentTime.getMonth() - 1;
          if (month === -1) {
            _this.currentTime.setFullYear(_this.currentTime.getFullYear() - 1);
            month = 11;
          }
          _this.currentTime.setDate(Math.min(new Date(_this.currentTime.getFullYear(), month + 1, 0).getDate(), _this.currentTime.getDate()));
          _this.currentTime.setMonth(month);
          if (options.onChangeMonth && $.isFunction(options.onChangeMonth)) {
            options.onChangeMonth.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
          }
          datetimepicker.trigger('xchange.xdsoft');
          return month;
        };
        _this.getWeekOfYear = function (datetime) {
          if (options.onGetWeekOfYear && $.isFunction(options.onGetWeekOfYear)) {
            var week = options.onGetWeekOfYear.call(datetimepicker, datetime);
            if (typeof week !== 'undefined') {
              return week;
            }
          }
          var onejan = new Date(datetime.getFullYear(), 0, 1);

          //First week of the year is th one with the first Thursday according to ISO8601
          if (onejan.getDay() !== 4) {
            onejan.setMonth(0, 1 + (4 - onejan.getDay() + 7) % 7);
          }
          return Math.ceil(((datetime - onejan) / 86400000 + onejan.getDay() + 1) / 7);
        };
        _this.strToDateTime = function (sDateTime) {
          var tmpDate = [],
            timeOffset,
            currentTime;
          if (sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime)) {
            return sDateTime;
          }
          tmpDate = /^([+-]{1})(.*)$/.exec(sDateTime);
          if (tmpDate) {
            tmpDate[2] = dateHelper.parseDate(tmpDate[2], options.formatDate);
          }
          if (tmpDate && tmpDate[2]) {
            timeOffset = tmpDate[2].getTime() - tmpDate[2].getTimezoneOffset() * 60000;
            currentTime = new Date(_this.now(true).getTime() + parseInt(tmpDate[1] + '1', 10) * timeOffset);
          } else {
            currentTime = sDateTime ? dateHelper.parseDate(sDateTime, options.format) : _this.now();
          }
          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now();
          }
          return currentTime;
        };
        _this.strToDate = function (sDate) {
          if (sDate && sDate instanceof Date && _this.isValidDate(sDate)) {
            return sDate;
          }
          var currentTime = sDate ? dateHelper.parseDate(sDate, options.formatDate) : _this.now(true);
          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }
          return currentTime;
        };
        _this.strtotime = function (sTime) {
          if (sTime && sTime instanceof Date && _this.isValidDate(sTime)) {
            return sTime;
          }
          var currentTime = sTime ? dateHelper.parseDate(sTime, options.formatTime) : _this.now(true);
          if (!_this.isValidDate(currentTime)) {
            currentTime = _this.now(true);
          }
          return currentTime;
        };
        _this.str = function () {
          var format = options.format;
          if (options.yearOffset) {
            format = format.replace('Y', _this.currentTime.getFullYear() + options.yearOffset);
            format = format.replace('y', String(_this.currentTime.getFullYear() + options.yearOffset).substring(2, 4));
          }
          return dateHelper.formatDate(_this.currentTime, format);
        };
        _this.currentTime = this.now();
      };
      _xdsoft_datetime = new XDSoft_datetime();
      applyButton.on('touchend click', function (e) {
        //pathbrite
        e.preventDefault();
        datetimepicker.data('changed', true);
        _xdsoft_datetime.setCurrentTime(getCurrentValue());
        input.val(_xdsoft_datetime.str());
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_today_button').on('touchend mousedown.xdsoft', function () {
        datetimepicker.data('changed', true);
        _xdsoft_datetime.setCurrentTime(0, true);
        datetimepicker.trigger('afterOpen.xdsoft');
      }).on('dblclick.xdsoft', function () {
        var currentDate = _xdsoft_datetime.getCurrentTime(),
          minDate,
          maxDate;
        currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate());
        minDate = _xdsoft_datetime.strToDate(options.minDate);
        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
        if (currentDate < minDate) {
          return;
        }
        maxDate = _xdsoft_datetime.strToDate(options.maxDate);
        maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate());
        if (currentDate > maxDate) {
          return;
        }
        input.val(_xdsoft_datetime.str());
        input.trigger('change');
        datetimepicker.trigger('close.xdsoft');
      });
      month_picker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
          timer = 0,
          stop = false;
        (function arguments_callee1(v) {
          if ($this.hasClass(options.next)) {
            _xdsoft_datetime.nextMonth();
          } else if ($this.hasClass(options.prev)) {
            _xdsoft_datetime.prevMonth();
          }
          if (options.monthChangeSpinner) {
            if (!stop) {
              timer = setTimeout(arguments_callee1, v || 100);
            }
          }
        })(500);
        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee2() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee2);
        });
      });
      timepicker.find('.xdsoft_prev,.xdsoft_next').on('touchend mousedown.xdsoft', function () {
        var $this = $(this),
          timer = 0,
          stop = false,
          period = 110;
        (function arguments_callee4(v) {
          var pheight = timeboxparent[0].clientHeight,
            height = timebox[0].offsetHeight,
            top = Math.abs(parseInt(timebox.css('marginTop'), 10));
          if ($this.hasClass(options.next) && height - pheight - options.timeHeightInTimePicker >= top) {
            timebox.css('marginTop', '-' + (top + options.timeHeightInTimePicker) + 'px');
          } else if ($this.hasClass(options.prev) && top - options.timeHeightInTimePicker >= 0) {
            timebox.css('marginTop', '-' + (top - options.timeHeightInTimePicker) + 'px');
          }
          /**
           * Fixed bug:
           * When using css3 transition, it will cause a bug that you cannot scroll the timepicker list.
           * The reason is that the transition-duration time, if you set it to 0, all things fine, otherwise, this
           * would cause a bug when you use jquery.css method.
           * Let's say: * { transition: all .5s ease; }
           * jquery timebox.css('marginTop') will return the original value which is before you clicking the next/prev button,
           * meanwhile the timebox[0].style.marginTop will return the right value which is after you clicking the
           * next/prev button.
           *
           * What we should do:
           * Replace timebox.css('marginTop') with timebox[0].style.marginTop.
           */
          timeboxparent.trigger('scroll_element.xdsoft_scroller', [Math.abs(parseInt(timebox[0].style.marginTop, 10) / (height - pheight))]);
          period = period > 10 ? 10 : period - 10;
          if (!stop) {
            timer = setTimeout(arguments_callee4, v || period);
          }
        })(500);
        $([options.ownerDocument.body, options.contentWindow]).on('touchend mouseup.xdsoft', function arguments_callee5() {
          clearTimeout(timer);
          stop = true;
          $([options.ownerDocument.body, options.contentWindow]).off('touchend mouseup.xdsoft', arguments_callee5);
        });
      });
      xchangeTimer = 0;
      // base handler - generating a calendar and timepicker
      datetimepicker.on('xchange.xdsoft', function (event) {
        clearTimeout(xchangeTimer);
        xchangeTimer = setTimeout(function () {
          if (_xdsoft_datetime.currentTime === undefined || _xdsoft_datetime.currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          }
          var table = '',
            start = new Date(_xdsoft_datetime.currentTime.getFullYear(), _xdsoft_datetime.currentTime.getMonth(), 1, 12, 0, 0),
            i = 0,
            j,
            today = _xdsoft_datetime.now(),
            maxDate = false,
            minDate = false,
            minDateTime = false,
            maxDateTime = false,
            hDate,
            day,
            d,
            y,
            m,
            w,
            classes = [],
            customDateSettings,
            newRow = true,
            time = '',
            h,
            line_time,
            description;
          while (start.getDay() !== options.dayOfWeekStart) {
            start.setDate(start.getDate() - 1);
          }
          table += '<table><thead><tr>';
          if (options.weeks) {
            table += '<th></th>';
          }
          for (j = 0; j < 7; j += 1) {
            table += '<th>' + options.i18n[globalLocale].dayOfWeekShort[(j + options.dayOfWeekStart) % 7] + '</th>';
          }
          table += '</tr></thead>';
          table += '<tbody>';
          if (options.maxDate !== false) {
            maxDate = _xdsoft_datetime.strToDate(options.maxDate);
            maxDate = new Date(maxDate.getFullYear(), maxDate.getMonth(), maxDate.getDate(), 23, 59, 59, 999);
          }
          if (options.minDate !== false) {
            minDate = _xdsoft_datetime.strToDate(options.minDate);
            minDate = new Date(minDate.getFullYear(), minDate.getMonth(), minDate.getDate());
          }
          if (options.minDateTime !== false) {
            minDateTime = _xdsoft_datetime.strToDate(options.minDateTime);
            minDateTime = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), minDateTime.getHours(), minDateTime.getMinutes(), minDateTime.getSeconds());
          }
          if (options.maxDateTime !== false) {
            maxDateTime = _xdsoft_datetime.strToDate(options.maxDateTime);
            maxDateTime = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), maxDateTime.getHours(), maxDateTime.getMinutes(), maxDateTime.getSeconds());
          }
          var maxDateTimeDay;
          if (maxDateTime !== false) {
            maxDateTimeDay = (maxDateTime.getFullYear() * 12 + maxDateTime.getMonth()) * 31 + maxDateTime.getDate();
          }
          while (i < _xdsoft_datetime.currentTime.countDaysInMonth() || start.getDay() !== options.dayOfWeekStart || _xdsoft_datetime.currentTime.getMonth() === start.getMonth()) {
            classes = [];
            i += 1;
            day = start.getDay();
            d = start.getDate();
            y = start.getFullYear();
            m = start.getMonth();
            w = _xdsoft_datetime.getWeekOfYear(start);
            description = '';
            classes.push('xdsoft_date');
            if (options.beforeShowDay && $.isFunction(options.beforeShowDay.call)) {
              customDateSettings = options.beforeShowDay.call(datetimepicker, start);
            } else {
              customDateSettings = null;
            }
            if (options.allowDateRe && Object.prototype.toString.call(options.allowDateRe) === "[object RegExp]") {
              if (!options.allowDateRe.test(dateHelper.formatDate(start, options.formatDate))) {
                classes.push('xdsoft_disabled');
              }
            }
            if (options.allowDates && options.allowDates.length > 0) {
              if (options.allowDates.indexOf(dateHelper.formatDate(start, options.formatDate)) === -1) {
                classes.push('xdsoft_disabled');
              }
            }
            var currentDay = (start.getFullYear() * 12 + start.getMonth()) * 31 + start.getDate();
            if (maxDate !== false && start > maxDate || minDateTime !== false && start < minDateTime || minDate !== false && start < minDate || maxDateTime !== false && currentDay > maxDateTimeDay || customDateSettings && customDateSettings[0] === false) {
              classes.push('xdsoft_disabled');
            }
            if (options.disabledDates.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_disabled');
            }
            if (options.disabledWeekDays.indexOf(day) !== -1) {
              classes.push('xdsoft_disabled');
            }
            if (input.is('[disabled]')) {
              classes.push('xdsoft_disabled');
            }
            if (customDateSettings && customDateSettings[1] !== "") {
              classes.push(customDateSettings[1]);
            }
            if (_xdsoft_datetime.currentTime.getMonth() !== m) {
              classes.push('xdsoft_other_month');
            }
            if ((options.defaultSelect || datetimepicker.data('changed')) && dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_current');
            }
            if (dateHelper.formatDate(today, options.formatDate) === dateHelper.formatDate(start, options.formatDate)) {
              classes.push('xdsoft_today');
            }
            if (start.getDay() === 0 || start.getDay() === 6 || options.weekends.indexOf(dateHelper.formatDate(start, options.formatDate)) !== -1) {
              classes.push('xdsoft_weekend');
            }
            if (options.highlightedDates[dateHelper.formatDate(start, options.formatDate)] !== undefined) {
              hDate = options.highlightedDates[dateHelper.formatDate(start, options.formatDate)];
              classes.push(hDate.style === undefined ? 'xdsoft_highlighted_default' : hDate.style);
              description = hDate.desc === undefined ? '' : hDate.desc;
            }
            if (options.beforeShowDay && $.isFunction(options.beforeShowDay)) {
              classes.push(options.beforeShowDay(start));
            }
            if (newRow) {
              table += '<tr>';
              newRow = false;
              if (options.weeks) {
                table += '<th>' + w + '</th>';
              }
            }
            table += '<td data-date="' + d + '" data-month="' + m + '" data-year="' + y + '"' + ' class="xdsoft_date xdsoft_day_of_week' + start.getDay() + ' ' + classes.join(' ') + '" title="' + description + '">' + '<div>' + d + '</div>' + '</td>';
            if (start.getDay() === options.dayOfWeekStartPrev) {
              table += '</tr>';
              newRow = true;
            }
            start.setDate(d + 1);
          }
          table += '</tbody></table>';
          calendar.html(table);
          month_picker.find('.xdsoft_label span').eq(0).text(options.i18n[globalLocale].months[_xdsoft_datetime.currentTime.getMonth()]);
          month_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear() + options.yearOffset);

          // generate timebox
          time = '';
          h = '';
          m = '';
          var minTimeMinutesOfDay = 0;
          if (options.minTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.minTime);
            minTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }
          var maxTimeMinutesOfDay = 24 * 60;
          if (options.maxTime !== false) {
            var t = _xdsoft_datetime.strtotime(options.maxTime);
            maxTimeMinutesOfDay = 60 * t.getHours() + t.getMinutes();
          }
          if (options.minDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.minDateTime);
            var currentDayIsMinDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
            if (currentDayIsMinDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m > minTimeMinutesOfDay) minTimeMinutesOfDay = m;
            }
          }
          if (options.maxDateTime !== false) {
            var t = _xdsoft_datetime.strToDateTime(options.maxDateTime);
            var currentDayIsMaxDateTimeDay = dateHelper.formatDate(_xdsoft_datetime.currentTime, options.formatDate) === dateHelper.formatDate(t, options.formatDate);
            if (currentDayIsMaxDateTimeDay) {
              var m = 60 * t.getHours() + t.getMinutes();
              if (m < maxTimeMinutesOfDay) maxTimeMinutesOfDay = m;
            }
          }
          line_time = function line_time(h, m) {
            var now = _xdsoft_datetime.now(),
              current_time,
              isALlowTimesInit = options.allowTimes && $.isArray(options.allowTimes) && options.allowTimes.length;
            now.setHours(h);
            h = parseInt(now.getHours(), 10);
            now.setMinutes(m);
            m = parseInt(now.getMinutes(), 10);
            classes = [];
            var currentMinutesOfDay = 60 * h + m;
            if (input.is('[disabled]') || currentMinutesOfDay >= maxTimeMinutesOfDay || currentMinutesOfDay < minTimeMinutesOfDay) {
              classes.push('xdsoft_disabled');
            }
            current_time = new Date(_xdsoft_datetime.currentTime);
            current_time.setHours(parseInt(_xdsoft_datetime.currentTime.getHours(), 10));
            if (!isALlowTimesInit) {
              current_time.setMinutes(Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes() / options.step) * options.step);
            }
            if ((options.initTime || options.defaultSelect || datetimepicker.data('changed')) && current_time.getHours() === parseInt(h, 10) && (!isALlowTimesInit && options.step > 59 || current_time.getMinutes() === parseInt(m, 10))) {
              if (options.defaultSelect || datetimepicker.data('changed')) {
                classes.push('xdsoft_current');
              } else if (options.initTime) {
                classes.push('xdsoft_init_time');
              }
            }
            if (parseInt(today.getHours(), 10) === parseInt(h, 10) && parseInt(today.getMinutes(), 10) === parseInt(m, 10)) {
              classes.push('xdsoft_today');
            }
            time += '<div class="xdsoft_time ' + classes.join(' ') + '" data-hour="' + h + '" data-minute="' + m + '">' + dateHelper.formatDate(now, options.formatTime) + '</div>';
          };
          if (!options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length) {
            for (i = 0, j = 0; i < (options.hours12 ? 12 : 24); i += 1) {
              for (j = 0; j < 60; j += options.step) {
                var currentMinutesOfDay = i * 60 + j;
                if (currentMinutesOfDay < minTimeMinutesOfDay) continue;
                if (currentMinutesOfDay >= maxTimeMinutesOfDay) continue;
                h = (i < 10 ? '0' : '') + i;
                m = (j < 10 ? '0' : '') + j;
                line_time(h, m);
              }
            }
          } else {
            for (i = 0; i < options.allowTimes.length; i += 1) {
              h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
              m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
              line_time(h, m);
            }
          }
          timebox.html(time);
          opt = '';
          for (i = parseInt(options.yearStart, 10); i <= parseInt(options.yearEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getFullYear() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + (i + options.yearOffset) + '</div>';
          }
          yearselect.children().eq(0).html(opt);
          for (i = parseInt(options.monthStart, 10), opt = ''; i <= parseInt(options.monthEnd, 10); i += 1) {
            opt += '<div class="xdsoft_option ' + (_xdsoft_datetime.currentTime.getMonth() === i ? 'xdsoft_current' : '') + '" data-value="' + i + '">' + options.i18n[globalLocale].months[i] + '</div>';
          }
          monthselect.children().eq(0).html(opt);
          $(datetimepicker).trigger('generate.xdsoft');
        }, 10);
        event.stopPropagation();
      }).on('afterOpen.xdsoft', function () {
        if (options.timepicker) {
          var classType, pheight, height, top;
          if (timebox.find('.xdsoft_current').length) {
            classType = '.xdsoft_current';
          } else if (timebox.find('.xdsoft_init_time').length) {
            classType = '.xdsoft_init_time';
          }
          if (classType) {
            pheight = timeboxparent[0].clientHeight;
            height = timebox[0].offsetHeight;
            top = timebox.find(classType).index() * options.timeHeightInTimePicker + 1;
            if (height - pheight < top) {
              top = height - pheight;
            }
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [parseInt(top, 10) / (height - pheight)]);
          } else {
            timeboxparent.trigger('scroll_element.xdsoft_scroller', [0]);
          }
        }
      });
      timerclick = 0;
      calendar.on('touchend click.xdsoft', 'td', function (xdevent) {
        xdevent.stopPropagation(); // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
        timerclick += 1;
        var $this = $(this),
          currentTime = _xdsoft_datetime.currentTime;
        if (currentTime === undefined || currentTime === null) {
          _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
          currentTime = _xdsoft_datetime.currentTime;
        }
        if ($this.hasClass('xdsoft_disabled')) {
          return false;
        }
        currentTime.setDate(1);
        currentTime.setFullYear($this.data('year'));
        currentTime.setMonth($this.data('month'));
        currentTime.setDate($this.data('date'));
        datetimepicker.trigger('select.xdsoft', [currentTime]);
        input.val(_xdsoft_datetime.str());
        if (options.onSelectDate && $.isFunction(options.onSelectDate)) {
          options.onSelectDate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
        }
        datetimepicker.data('changed', true);
        datetimepicker.trigger('xchange.xdsoft');
        datetimepicker.trigger('changedatetime.xdsoft');
        if ((timerclick > 1 || options.closeOnDateSelect === true || options.closeOnDateSelect === false && !options.timepicker) && !options.inline) {
          datetimepicker.trigger('close.xdsoft');
        }
        setTimeout(function () {
          timerclick = 0;
        }, 200);
      });
      timebox.on('touchstart', 'div', function (xdevent) {
        this.touchMoved = false;
      }).on('touchmove', 'div', handleTouchMoved).on('touchend click.xdsoft', 'div', function (xdevent) {
        if (!this.touchMoved) {
          xdevent.stopPropagation();
          var $this = $(this),
            currentTime = _xdsoft_datetime.currentTime;
          if (currentTime === undefined || currentTime === null) {
            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
            currentTime = _xdsoft_datetime.currentTime;
          }
          if ($this.hasClass('xdsoft_disabled')) {
            return false;
          }
          currentTime.setHours($this.data('hour'));
          currentTime.setMinutes($this.data('minute'));
          datetimepicker.trigger('select.xdsoft', [currentTime]);
          datetimepicker.data('input').val(_xdsoft_datetime.str());
          if (options.onSelectTime && $.isFunction(options.onSelectTime)) {
            options.onSelectTime.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), xdevent);
          }
          datetimepicker.data('changed', true);
          datetimepicker.trigger('xchange.xdsoft');
          datetimepicker.trigger('changedatetime.xdsoft');
          if (options.inline !== true && options.closeOnTimeSelect === true) {
            datetimepicker.trigger('close.xdsoft');
          }
        }
      });
      datepicker.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollMonth) {
          return true;
        }
        if (event.deltaY < 0) {
          _xdsoft_datetime.nextMonth();
        } else {
          _xdsoft_datetime.prevMonth();
        }
        return false;
      });
      input.on('mousewheel.xdsoft', function (event) {
        if (!options.scrollInput) {
          return true;
        }
        if (!options.datepicker && options.timepicker) {
          current_time_index = timebox.find('.xdsoft_current').length ? timebox.find('.xdsoft_current').eq(0).index() : 0;
          if (current_time_index + event.deltaY >= 0 && current_time_index + event.deltaY < timebox.children().length) {
            current_time_index += event.deltaY;
          }
          if (timebox.children().eq(current_time_index).length) {
            timebox.children().eq(current_time_index).trigger('mousedown');
          }
          return false;
        }
        if (options.datepicker && !options.timepicker) {
          datepicker.trigger(event, [event.deltaY, event.deltaX, event.deltaY]);
          if (input.val) {
            input.val(_xdsoft_datetime.str());
          }
          datetimepicker.trigger('changedatetime.xdsoft');
          return false;
        }
      });
      datetimepicker.on('changedatetime.xdsoft', function (event) {
        if (options.onChangeDateTime && $.isFunction(options.onChangeDateTime)) {
          var $input = datetimepicker.data('input');
          options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input, event);
          delete options.value;
          $input.trigger('change');
        }
      }).on('generate.xdsoft', function () {
        if (options.onGenerate && $.isFunction(options.onGenerate)) {
          options.onGenerate.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'));
        }
        if (triggerAfterOpen) {
          datetimepicker.trigger('afterOpen.xdsoft');
          triggerAfterOpen = false;
        }
      }).on('click.xdsoft', function (xdevent) {
        xdevent.stopPropagation();
      });
      current_time_index = 0;

      /**
       * Runs the callback for each of the specified node's ancestors.
       *
       * Return FALSE from the callback to stop ascending.
       *
       * @param {DOMNode} node
       * @param {Function} callback
       * @returns {undefined}
       */
      forEachAncestorOf = function forEachAncestorOf(node, callback) {
        do {
          node = node.parentNode;
          if (!node || callback(node) === false) {
            break;
          }
        } while (node.nodeName !== 'HTML');
      };

      /**
       * Sets the position of the picker.
       *
       * @returns {undefined}
       */
      setPos = function setPos() {
        var dateInputOffset, dateInputElem, verticalPosition, left, position, datetimepickerElem, dateInputHasFixedAncestor, $dateInput, windowWidth, verticalAnchorEdge, datetimepickerCss, windowHeight, windowScrollTop;
        $dateInput = datetimepicker.data('input');
        dateInputOffset = $dateInput.offset();
        dateInputElem = $dateInput[0];
        verticalAnchorEdge = 'top';
        verticalPosition = dateInputOffset.top + dateInputElem.offsetHeight - 1;
        left = dateInputOffset.left;
        position = "absolute";
        windowWidth = $(options.contentWindow).width();
        windowHeight = $(options.contentWindow).height();
        windowScrollTop = $(options.contentWindow).scrollTop();
        if (options.ownerDocument.documentElement.clientWidth - dateInputOffset.left < datepicker.parent().outerWidth(true)) {
          var diff = datepicker.parent().outerWidth(true) - dateInputElem.offsetWidth;
          left = left - diff;
        }
        if ($dateInput.parent().css('direction') === 'rtl') {
          left -= datetimepicker.outerWidth() - $dateInput.outerWidth();
        }
        if (options.fixed) {
          verticalPosition -= windowScrollTop;
          left -= $(options.contentWindow).scrollLeft();
          position = "fixed";
        } else {
          dateInputHasFixedAncestor = false;
          forEachAncestorOf(dateInputElem, function (ancestorNode) {
            if (ancestorNode === null) {
              return false;
            }
            if (options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position') === 'fixed') {
              dateInputHasFixedAncestor = true;
              return false;
            }
          });
          if (dateInputHasFixedAncestor && !options.insideParent) {
            position = 'fixed';

            //If the picker won't fit entirely within the viewport then display it above the date input.
            if (verticalPosition + datetimepicker.outerHeight() > windowHeight + windowScrollTop) {
              verticalAnchorEdge = 'bottom';
              verticalPosition = windowHeight + windowScrollTop - dateInputOffset.top;
            } else {
              verticalPosition -= windowScrollTop;
            }
          } else {
            if (verticalPosition + datetimepicker[0].offsetHeight > windowHeight + windowScrollTop) {
              verticalPosition = dateInputOffset.top - datetimepicker[0].offsetHeight + 1;
            }
          }
          if (verticalPosition < 0) {
            verticalPosition = 0;
          }
          if (left + dateInputElem.offsetWidth > windowWidth) {
            left = windowWidth - dateInputElem.offsetWidth;
          }
        }
        datetimepickerElem = datetimepicker[0];
        forEachAncestorOf(datetimepickerElem, function (ancestorNode) {
          var ancestorNodePosition;
          ancestorNodePosition = options.contentWindow.getComputedStyle(ancestorNode).getPropertyValue('position');
          if (ancestorNodePosition === 'relative' && windowWidth >= ancestorNode.offsetWidth) {
            left = left - (windowWidth - ancestorNode.offsetWidth) / 2;
            return false;
          }
        });
        datetimepickerCss = {
          position: position,
          left: options.insideParent ? dateInputElem.offsetLeft : left,
          top: '',
          //Initialize to prevent previous values interfering with new ones.
          bottom: '' //Initialize to prevent previous values interfering with new ones.
        };

        if (options.insideParent) {
          datetimepickerCss[verticalAnchorEdge] = dateInputElem.offsetTop + dateInputElem.offsetHeight;
        } else {
          datetimepickerCss[verticalAnchorEdge] = verticalPosition;
        }
        datetimepicker.css(datetimepickerCss);
      };
      datetimepicker.on('open.xdsoft', function (event) {
        var onShow = true;
        if (options.onShow && $.isFunction(options.onShow)) {
          onShow = options.onShow.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }
        if (onShow !== false) {
          datetimepicker.show();
          setPos();
          $(options.contentWindow).off('resize.xdsoft', setPos).on('resize.xdsoft', setPos);
          if (options.closeOnWithoutClick) {
            $([options.ownerDocument.body, options.contentWindow]).on('touchstart mousedown.xdsoft', function arguments_callee6() {
              datetimepicker.trigger('close.xdsoft');
              $([options.ownerDocument.body, options.contentWindow]).off('touchstart mousedown.xdsoft', arguments_callee6);
            });
          }
        }
      }).on('close.xdsoft', function (event) {
        var onClose = true;
        month_picker.find('.xdsoft_month,.xdsoft_year').find('.xdsoft_select').hide();
        if (options.onClose && $.isFunction(options.onClose)) {
          onClose = options.onClose.call(datetimepicker, _xdsoft_datetime.currentTime, datetimepicker.data('input'), event);
        }
        if (onClose !== false && !options.opened && !options.inline) {
          datetimepicker.hide();
        }
        event.stopPropagation();
      }).on('toggle.xdsoft', function () {
        if (datetimepicker.is(':visible')) {
          datetimepicker.trigger('close.xdsoft');
        } else {
          datetimepicker.trigger('open.xdsoft');
        }
      }).data('input', input);
      timer = 0;
      datetimepicker.data('xdsoft_datetime', _xdsoft_datetime);
      datetimepicker.setOptions(options);
      function getCurrentValue() {
        var ct = false,
          time;
        if (options.startDate) {
          ct = _xdsoft_datetime.strToDate(options.startDate);
        } else {
          ct = options.value || (input && input.val && input.val() ? input.val() : '');
          if (ct) {
            ct = _xdsoft_datetime.strToDateTime(ct);
            if (options.yearOffset) {
              ct = new Date(ct.getFullYear() - options.yearOffset, ct.getMonth(), ct.getDate(), ct.getHours(), ct.getMinutes(), ct.getSeconds(), ct.getMilliseconds());
            }
          } else if (options.defaultDate) {
            ct = _xdsoft_datetime.strToDateTime(options.defaultDate);
            if (options.defaultTime) {
              time = _xdsoft_datetime.strtotime(options.defaultTime);
              ct.setHours(time.getHours());
              ct.setMinutes(time.getMinutes());
            }
          }
        }
        if (ct && _xdsoft_datetime.isValidDate(ct)) {
          datetimepicker.data('changed', true);
        } else {
          ct = '';
        }
        return ct || 0;
      }
      function setMask(options) {
        var isValidValue = function isValidValue(mask, value) {
            var reg = mask.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g, '\\$1').replace(/_/g, '{digit+}').replace(/([0-9]{1})/g, '{digit$1}').replace(/\{digit([0-9]{1})\}/g, '[0-$1_]{1}').replace(/\{digit[\+]\}/g, '[0-9_]{1}');
            return new RegExp(reg).test(value);
          },
          getCaretPos = function getCaretPos(input) {
            try {
              if (options.ownerDocument.selection && options.ownerDocument.selection.createRange) {
                var range = options.ownerDocument.selection.createRange();
                return range.getBookmark().charCodeAt(2) - 2;
              }
              if (input.setSelectionRange) {
                return input.selectionStart;
              }
            } catch (e) {
              return 0;
            }
          },
          setCaretPos = function setCaretPos(node, pos) {
            node = typeof node === "string" || node instanceof String ? options.ownerDocument.getElementById(node) : node;
            if (!node) {
              return false;
            }
            if (node.createTextRange) {
              var textRange = node.createTextRange();
              textRange.collapse(true);
              textRange.moveEnd('character', pos);
              textRange.moveStart('character', pos);
              textRange.select();
              return true;
            }
            if (node.setSelectionRange) {
              node.setSelectionRange(pos, pos);
              return true;
            }
            return false;
          };
        if (options.mask) {
          input.off('keydown.xdsoft');
        }
        if (options.mask === true) {
          if (dateHelper.formatMask) {
            options.mask = dateHelper.formatMask(options.format);
          } else {
            options.mask = options.format.replace(/Y/g, '9999').replace(/F/g, '9999').replace(/m/g, '19').replace(/d/g, '39').replace(/H/g, '29').replace(/i/g, '59').replace(/s/g, '59');
          }
        }
        if ($.type(options.mask) === 'string') {
          if (!isValidValue(options.mask, input.val())) {
            input.val(options.mask.replace(/[0-9]/g, '_'));
            setCaretPos(input[0], 0);
          }
          input.on('paste.xdsoft', function (event) {
            // couple options here
            // 1. return false - tell them they can't paste
            // 2. insert over current characters - minimal validation
            // 3. full fledged parsing and validation
            // let's go option 2 for now

            // fires multiple times for some reason

            // https://stackoverflow.com/a/30496488/1366033
            var clipboardData = event.clipboardData || event.originalEvent.clipboardData || window.clipboardData,
              pastedData = clipboardData.getData('text'),
              val = this.value,
              pos = this.selectionStart;
            var valueBeforeCursor = val.substr(0, pos);
            var valueAfterPaste = val.substr(pos + pastedData.length);
            val = valueBeforeCursor + pastedData + valueAfterPaste;
            pos += pastedData.length;
            if (isValidValue(options.mask, val)) {
              this.value = val;
              setCaretPos(this, pos);
            } else if ($.trim(val) === '') {
              this.value = options.mask.replace(/[0-9]/g, '_');
            } else {
              input.trigger('error_input.xdsoft');
            }
            event.preventDefault();
            return false;
          });
          input.on('keydown.xdsoft', function (event) {
            var val = this.value,
              key = event.which,
              pos = this.selectionStart,
              selEnd = this.selectionEnd,
              hasSel = pos !== selEnd,
              digit;

            // only alow these characters
            if (key >= KEY0 && key <= KEY9 || key >= _KEY0 && key <= _KEY9 || key === BACKSPACE || key === DEL) {
              // get char to insert which is new character or placeholder ('_')
              digit = key === BACKSPACE || key === DEL ? '_' : String.fromCharCode(_KEY0 <= key && key <= _KEY9 ? key - KEY0 : key);

              // we're deleting something, we're not at the start, and have normal cursor, move back one
              // if we have a selection length, cursor actually sits behind deletable char, not in front
              if (key === BACKSPACE && pos && !hasSel) {
                pos -= 1;
              }

              // don't stop on a separator, continue whatever direction you were going
              //   value char - keep incrementing position while on separator char and we still have room
              //   del char   - keep decrementing position while on separator char and we still have room
              while (true) {
                var maskValueAtCurPos = options.mask.substr(pos, 1);
                var posShorterThanMaskLength = pos < options.mask.length;
                var posGreaterThanZero = pos > 0;
                var notNumberOrPlaceholder = /[^0-9_]/;
                var curPosOnSep = notNumberOrPlaceholder.test(maskValueAtCurPos);
                var continueMovingPosition = curPosOnSep && posShorterThanMaskLength && posGreaterThanZero;

                // if we hit a real char, stay where we are
                if (!continueMovingPosition) break;

                // hitting backspace in a selection, you can possibly go back any further - go forward
                pos += key === BACKSPACE && !hasSel ? -1 : 1;
              }
              if (event.metaKey) {
                // cmd has been pressed
                pos = 0;
                hasSel = true;
              }
              if (hasSel) {
                // pos might have moved so re-calc length
                var selLength = selEnd - pos;

                // if we have a selection length we will wipe out entire selection and replace with default template for that range
                var defaultBlank = options.mask.replace(/[0-9]/g, '_');
                var defaultBlankSelectionReplacement = defaultBlank.substr(pos, selLength);
                var selReplacementRemainder = defaultBlankSelectionReplacement.substr(1); // might be empty

                var valueBeforeSel = val.substr(0, pos);
                var insertChars = digit + selReplacementRemainder;
                var charsAfterSelection = val.substr(pos + selLength);
                val = valueBeforeSel + insertChars + charsAfterSelection;
              } else {
                var valueBeforeCursor = val.substr(0, pos);
                var insertChar = digit;
                var valueAfterNextChar = val.substr(pos + 1);
                val = valueBeforeCursor + insertChar + valueAfterNextChar;
              }
              if ($.trim(val) === '') {
                // if empty, set to default
                val = defaultBlank;
              } else {
                // if at the last character don't need to do anything
                if (pos === options.mask.length) {
                  event.preventDefault();
                  return false;
                }
              }

              // resume cursor location
              pos += key === BACKSPACE ? 0 : 1;
              // don't stop on a separator, continue whatever direction you were going
              while (/[^0-9_]/.test(options.mask.substr(pos, 1)) && pos < options.mask.length && pos > 0) {
                pos += key === BACKSPACE ? 0 : 1;
              }
              if (isValidValue(options.mask, val)) {
                this.value = val;
                setCaretPos(this, pos);
              } else if ($.trim(val) === '') {
                this.value = options.mask.replace(/[0-9]/g, '_');
              } else {
                input.trigger('error_input.xdsoft');
              }
            } else {
              if ([AKEY, CKEY, VKEY, ZKEY, YKEY].indexOf(key) !== -1 && ctrlDown || [ESC, ARROWUP, ARROWDOWN, ARROWLEFT, ARROWRIGHT, F5, CTRLKEY, TAB, ENTER].indexOf(key) !== -1) {
                return true;
              }
            }
            event.preventDefault();
            return false;
          });
        }
      }
      _xdsoft_datetime.setCurrentTime(getCurrentValue());
      input.data('xdsoft_datetimepicker', datetimepicker).on('open.xdsoft focusin.xdsoft mousedown.xdsoft touchstart', function () {
        if (input.is(':disabled') || input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick) {
          return;
        }
        if (!options.openOnFocus) {
          return;
        }
        clearTimeout(timer);
        timer = setTimeout(function () {
          if (input.is(':disabled')) {
            return;
          }
          triggerAfterOpen = true;
          _xdsoft_datetime.setCurrentTime(getCurrentValue(), true);
          if (options.mask) {
            setMask(options);
          }
          datetimepicker.trigger('open.xdsoft');
        }, 100);
      }).on('keydown.xdsoft', function (event) {
        var elementSelector,
          key = event.which;
        if ([ENTER].indexOf(key) !== -1 && options.enterLikeTab) {
          elementSelector = $("input:visible,textarea:visible,button:visible,a:visible");
          datetimepicker.trigger('close.xdsoft');
          elementSelector.eq(elementSelector.index(this) + 1).focus();
          return false;
        }
        if ([TAB].indexOf(key) !== -1) {
          datetimepicker.trigger('close.xdsoft');
          return true;
        }
      }).on('blur.xdsoft', function () {
        datetimepicker.trigger('close.xdsoft');
      });
    };
    destroyDateTimePicker = function destroyDateTimePicker(input) {
      var datetimepicker = input.data('xdsoft_datetimepicker');
      if (datetimepicker) {
        datetimepicker.data('xdsoft_datetime', null);
        datetimepicker.remove();
        input.data('xdsoft_datetimepicker', null).off('.xdsoft');
        $(options.contentWindow).off('resize.xdsoft');
        $([options.contentWindow, options.ownerDocument.body]).off('mousedown.xdsoft touchstart');
        if (input.unmousewheel) {
          input.unmousewheel();
        }
      }
    };
    $(options.ownerDocument).off('keydown.xdsoftctrl keyup.xdsoftctrl').off('keydown.xdsoftcmd keyup.xdsoftcmd').on('keydown.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = true;
      }
    }).on('keyup.xdsoftctrl', function (e) {
      if (e.keyCode === CTRLKEY) {
        ctrlDown = false;
      }
    }).on('keydown.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = true;
      }
    }).on('keyup.xdsoftcmd', function (e) {
      if (e.keyCode === CMDKEY) {
        cmdDown = false;
      }
    });
    this.each(function () {
      var datetimepicker = $(this).data('xdsoft_datetimepicker'),
        $input;
      if (datetimepicker) {
        if ($.type(opt) === 'string') {
          switch (opt) {
            case 'show':
              $(this).select().focus();
              datetimepicker.trigger('open.xdsoft');
              break;
            case 'hide':
              datetimepicker.trigger('close.xdsoft');
              break;
            case 'toggle':
              datetimepicker.trigger('toggle.xdsoft');
              break;
            case 'destroy':
              destroyDateTimePicker($(this));
              break;
            case 'reset':
              this.value = this.defaultValue;
              if (!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(dateHelper.parseDate(this.value, options.format))) {
                datetimepicker.data('changed', false);
              }
              datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
              break;
            case 'validate':
              $input = datetimepicker.data('input');
              $input.trigger('blur.xdsoft');
              break;
            default:
              if (datetimepicker[opt] && $.isFunction(datetimepicker[opt])) {
                result = datetimepicker[opt](opt2);
              }
          }
        } else {
          datetimepicker.setOptions(opt);
        }
        return 0;
      }
      if ($.type(opt) !== 'string') {
        if (!options.lazyInit || options.open || options.inline) {
          createDateTimePicker($(this));
        } else {
          lazyInit($(this));
        }
      }
    });
    return result;
  };
  $.fn.datetimepicker.defaults = default_options;
  function HighlightedDate(date, desc, style) {
    "use strict";

    this.date = date;
    this.desc = desc;
    this.style = style;
  }
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/datepicker.js

/*
 * Render Date Picker
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixRenderDatePicker = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '[data-picker]'
    }, options);
    this.each(function () {
      if ($.isFunction($.fn.datetimepicker)) {
        $(settings.controls).each(function () {
          var $this = $(this);
          var dateFormat = $this.data('picker-format'),
            timeEnabled = $this.data('picker-timepicker'),
            lang = $this.data('picker-lang'),
            myminDate = $this.data('picker-min-date'),
            mymaxDate = $this.data('picker-max-date'),
            rtlEnabled = false;

          // If there is no data-xxx, save current source to it
          if ((0,esm_typeof/* default */.Z)(dateFormat) === ( true ? "undefined" : 0)) dateFormat = 'M d, Y'; //Y-m-d H:i:s
          if ((0,esm_typeof/* default */.Z)(timeEnabled) === ( true ? "undefined" : 0)) timeEnabled = false;
          if ((0,esm_typeof/* default */.Z)(lang) === ( true ? "undefined" : 0)) lang = 'en';
          if ((0,esm_typeof/* default */.Z)(myminDate) === ( true ? "undefined" : 0)) myminDate = false; //yesterday is minimum date(for today use 0 or -1970/01/01)
          if ((0,esm_typeof/* default */.Z)(mymaxDate) === ( true ? "undefined" : 0)) mymaxDate = false; //tomorrow is maximum date calendar, such as '+2050/01/01'
          if ((0,esm_typeof/* default */.Z)(rtlEnabled) === ( true ? "undefined" : 0)) rtlEnabled = false;
          $.datetimepicker.setLocale(lang);

          //RTL 
          if ($('body').hasClass('rtl')) {
            rtlEnabled = true;
          }

          //hide or display time selector
          if (timeEnabled) {
            $(document).on('mouseenter', 'td.xdsoft_date[data-date]', function () {
              if ($(this).hasClass('xdsoft_disabled')) {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').hide();
              } else {
                $(this).closest('.xdsoft_datepicker').next('.xdsoft_timepicker.active').show();
              }
            });
          }
          $this.datetimepicker({
            rtl: rtlEnabled,
            timepicker: timeEnabled,
            format: dateFormat,
            formatTime: 'H:i',
            formatDate: 'Y/m/d',
            minDate: myminDate,
            maxDate: mymaxDate
          });
        });

        //Dynamic listening for the latest value
        $(document).on('mouseleave', '[data-handler]', function () {
          $('[data-picker]').each(function () {
            $(this).closest('div').find('label, .uix-controls__bar').addClass('is-active');
          });
        });
      } // function datetimepicker is exist
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/fn/controls-hover.js
var controls_hover = __webpack_require__(366);
;// CONCATENATED MODULE: ./src/components/form/js/fn/single-seletor.js

/*
 * Render Single Selector
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSingleSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__single-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          $(this).find('> span').each(function () {
            var targetID = '#' + $(this).parent().attr('data-targetid');
            var switchIDs = '';

            //add switch IDs
            $(this).parent().find('> span').each(function () {
              if ((0,esm_typeof/* default */.Z)($(this).data("switchid")) != ( true ? "undefined" : 0)) {
                switchIDs += $(this).data("switchid") + ',';
              }
            });
            $(this).parent().attr("data-switchids", switchIDs.replace(/,\s*$/, ''));

            //Set actived style from their values
            if ($(targetID).val() == $(this).data('value')) {
              $(this).addClass('is-active').attr('aria-checked', true);
            } else {
              $(this).removeClass('is-active').attr('aria-checked', false);
            }
          });

          // Mouse events
          //------------------------------------------

          var singleSelItem = settings.controls + ' > span';

          /*
          * Initialize single switch
          *
          * @param  {Element} obj                 - Radio controls. 
          * @return {Void}
          */
          var hideAllSingleSelItems = function hideAllSingleSelItems(obj) {
            obj.each(function (index) {
              var $sel = $(this),
                defaultValue = $('#' + $sel.attr('data-targetid')).val(),
                deffaultSwitchIndex = 0;

              //get default selected switch index
              $sel.find('> span').each(function (index) {
                if (defaultValue == $(this).data('value')) {
                  deffaultSwitchIndex = index;
                }
              });
              if ((0,esm_typeof/* default */.Z)($sel.data('switchids')) != ( true ? "undefined" : 0) && $sel.data('switchids') != '') {
                var _switchIDsArr = $sel.data('switchids').split(',');
                _switchIDsArr.forEach(function (element, index) {
                  if (deffaultSwitchIndex != index) {
                    $('#' + element).hide();
                  } else {
                    $('#' + element).show();
                  }
                });
              }
            });
          };
          hideAllSingleSelItems($this);
          $(document).off('click.FORM_SINGLE_SEL').on('click.FORM_SINGLE_SEL', singleSelItem, function (e) {
            e.preventDefault();
            var $selector = $(this).parent(),
              $option = $(this),
              targetID = '#' + $selector.data("targetid"),
              switchID = '#' + $option.data("switchid"),
              curVal = $option.data('value');

            //Radio Selector
            $selector.find('> span').removeClass('is-active').attr('aria-checked', false);
            $(targetID).val(curVal);
            $option.addClass('is-active').attr('aria-checked', true);

            //Switch some options
            if ((0,esm_typeof/* default */.Z)($option.data("switchid")) != ( true ? "undefined" : 0)) {
              hideAllSingleSelItems($selector);
              $(switchID).show();
            }

            //Dynamic listening for the latest value
            $(targetID).focus().blur();
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });

      $(settings.controls).each(function () {});
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/multi-seletor.js

/*
 * Render Multiple Selector
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomMultiSel = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__multi-sel'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          $(this).find('> span').each(function () {
            var targetID = '#' + $(this).parent().attr('data-targetid');
            if ($(targetID).val().indexOf($(this).data('value')) >= 0) {
              $(this).addClass('is-active').attr('aria-checked', true);
            } else {
              $(this).removeClass('is-active').attr('aria-checked', false);
            }
          });

          // Click Event of Multiple Selector
          //------------------------------------------
          var multiSel = '.uix-controls__multi-sel',
            multiSelItem = multiSel + ' > span';
          $(document).off('click.FORM_MULTI_SEL').on('click.FORM_MULTI_SEL', multiSelItem, function (e) {
            e.preventDefault();
            var $selector = $(this).parent(),
              $option = $(this),
              targetID = '#' + $selector.data("targetid"),
              curVal = $option.data('value'),
              tarVal = $(targetID).val() + ',',
              resVal = '';
            $option.toggleClass('is-active').attr('aria-checked', function (index, attr) {
              return attr == 'true' ? false : true;
            });
            if (tarVal.indexOf(curVal + ',') < 0) {
              resVal = tarVal + curVal + ',';
            } else {
              resVal = tarVal.replace(curVal + ',', '');
            }
            resVal = resVal.replace(/,\s*$/, '').replace(/^,/, '');
            $(targetID).val(resVal);

            //Dynamic listening for the latest value
            $(targetID).focus().blur();
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });
    });
  };
})(jQuery);
// EXTERNAL MODULE: ./src/components/form/js/fn/file-dropzone.js
var file_dropzone = __webpack_require__(283);
// EXTERNAL MODULE: ./src/components/form/js/fn/upload.js
var upload = __webpack_require__(433);
// EXTERNAL MODULE: ./src/components/form/js/fn/controls-disable.js
var controls_disable = __webpack_require__(260);
;// CONCATENATED MODULE: ./src/components/form/js/fn/controls-line.js

/*
 * Create Line Effect on Click
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderControlsLineEff = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls.uix-controls--line'
    }, options);
    this.each(function () {
      var $this = $(this);
      var customControls = settings.controls;
      $(customControls).each(function () {
        var dataExist = $(this).data('exist');
        if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
          $('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>').insertAfter($(this).find('label'));

          //Multiple Selector or Single Selector
          if ($(this).hasClass('uix-controls__multi-sel') || $(this).hasClass('uix-controls__single-sel')) {
            $(this).find('> span').each(function () {
              $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
            });
          }

          //Custom Input Number
          if ($(this).hasClass('uix-controls__number')) {
            $(this).prepend('<ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>');
          }

          //Prevent the form from being initialized again
          $(this).data('exist', 1);
        }
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/radio-and-checkbox.js

/*
 * Render Custom Radio, Checkbox and Toggle 
 *
 * @param  {String} radioWrapper             - Wrapper of the radio.
 * @param  {String} toggle                   - Toggle of the checkbox.
 * @param  {String} checkboxWrapper          - Wrapper of the checkbox.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomRadioCheckbox = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      radioWrapper: '.uix-controls__radio',
      toggle: '.uix-controls__toggle',
      checkboxWrapper: '.uix-controls__checkbox'
    }, options);
    this.each(function () {
      $(settings.checkboxWrapper).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.checkboxWrapper).find('input[type="checkbox"]').each(function () {
            var dataExist = $(this).data('exist'),
              $obj = $(this).closest('.uix-controls');
            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__checkbox-trigger"></span>').insertAfter($(this));

              //hide or display a associated div
              var targetID = '#' + $obj.attr('data-targetid');
              if ($(this).is(':checked')) {
                $obj.addClass('is-active').attr('aria-checked', true);
                $(targetID).show();
              } else {
                $obj.removeClass('is-active').attr('aria-checked', false);
                $(targetID).hide();
              }

              //Prevent the form from being initialized again
              $(this).data('exist', 1);
            }
          });

          // Mouse events
          //------------------------------------------
          $(document).on('change', settings.toggle + ' [type="checkbox"]', function (e) {
            //hide or display a associated div
            var $obj = $(this).closest('.uix-controls'),
              targetID = '#' + $obj.attr('data-targetid');
            if (this.checked) {
              $obj.addClass('is-active').attr('aria-checked', true);
              $(targetID).show();
            } else {
              $obj.removeClass('is-active').attr('aria-checked', false);
              $(targetID).hide();
            }
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });

      $(settings.toggle).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.toggle).find('input[type="checkbox"]').each(function () {
            var dataExist = $(this).data('exist'),
              $obj = $(this).closest('.uix-controls'),
              offText = $obj.data('off-text'),
              onText = $obj.data('on-text');
            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__toggle-trigger" data-off-text="' + offText + '" data-on-text="' + onText + '"></span>').insertAfter($(this));
              //hide or display a associated div
              var targetID = '#' + $obj.attr('data-targetid');
              if ($(this).is(':checked')) {
                $obj.addClass('is-active').attr('aria-checked', true);
                $(targetID).show();
              } else {
                $obj.removeClass('is-active').attr('aria-checked', false);
                $(targetID).hide();
              }

              //Prevent the form from being initialized again
              $(this).data('exist', 1);
            }
          });

          // Mouse events
          //------------------------------------------
          $(document).on('change', settings.checkboxWrapper + ' [type="checkbox"]', function (e) {
            //hide or display a associated div
            var $obj = $(this).closest('.uix-controls'),
              targetID = '#' + $obj.attr('data-targetid');
            if (this.checked) {
              $obj.addClass('is-active').attr('aria-checked', true);
              $(targetID).show();
            } else {
              $obj.removeClass('is-active').attr('aria-checked', false);
              $(targetID).hide();
            }
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });

      $(settings.radioWrapper).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------  
          $(settings.radioWrapper).find('input[type="radio"]').each(function () {
            var dataExist = $(this).data('exist');
            if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
              $('<span class="uix-controls__radio-trigger"></span>').insertAfter($(this));

              //Prevent the form from being initialized again
              $(this).data('exist', 1);
            }
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/select.js

/*
 * Render Custom Select
 *
 * @param  {String} selector             - The current selector.
 * @param  {String} targetWrapper        - Wrapper of the selector.
 * @param  {String} trigger              - Trigger of the selector.
 * @param  {String} itemsWrapper         - Selector's options container.
 * @param  {Element} item                 - Each option of the selector.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderCustomSelect = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      selector: '.uix-controls__select',
      targetWrapper: '.uix-controls__select-wrapper',
      trigger: '.uix-controls__select-trigger',
      itemsWrapper: '.uix-controls__select__option-container',
      item: '.uix-controls__select__option'
    }, options);
    this.each(function () {
      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this);
        var classes = $this.attr('class'),
          id = $this.attr('id'),
          name = $this.attr('name'),
          labelText = $this.find('> span').html(),
          dataExist = $this.data('exist');
        var template = '';
        if ((0,esm_typeof/* default */.Z)(dataExist) === ( true ? "undefined" : 0) && dataExist != 1) {
          template = '<div class="' + classes + ' js-uix-new">';
          template += '<span class="uix-controls__select-trigger">' + $this.find('select').attr('placeholder') + '</span><ins class="uix-controls__bar"></ins><ins class="uix-controls__basic-bar"></ins>';
          template += '<div role="presentation" class="uix-controls__select__option-container">';
          $this.find('select option').each(function (index) {
            var selected = '';
            if ($(this).is(':selected')) {
              selected = 'is-active';
            }
            template += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
          });
          template += '</div></div>';
          if ((0,esm_typeof/* default */.Z)(labelText) != ( true ? "undefined" : 0) && labelText != '') {
            template += '<span class="uix-controls__select-label">' + labelText + '</span>';
          }
          $this.wrap('<div class="' + settings.targetWrapper.replace('.', '') + ' ' + ($this.hasClass('uix-controls--line') ? 'uix-controls--line' : '') + ' ' + ($this.hasClass('is-fullwidth') ? 'is-fullwidth' : '') + ' ' + ($this.hasClass('is-disabled') ? 'is-disabled' : '') + '"></div>');
          $this.hide();
          $this.after(template);

          //Prevent the form from being initialized again
          $(this).data('exist', 1);
        }
      });

      //Show/Hide Selector
      $(document).off('click.FORM_CUSTOM_SELECT').on('click.FORM_CUSTOM_SELECT', settings.trigger, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
          $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new');
        $selectCurWrapper.addClass('is-opened');
      });

      //Do not add off() to this
      $(document.body).on('click', function (e) {
        if (e.target.className != '' && (0,esm_typeof/* default */.Z)(e.target.className) != ( true ? "undefined" : 0) && Object.prototype.toString.call(e.target.className) != '[object SVGAnimatedString]') {
          if (e.target.className.indexOf('uix-controls__select__option') < 0) {
            $(settings.selector + '.js-uix-new').removeClass('is-opened');
          }
        }
      });

      //Set the default selector text
      $(settings.selector + '.js-uix-new').each(function (index) {
        $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
      });

      //Change Event Here
      //Prevents the triggering of multiple change events
      $(document).off('click.FORM_CUSTOM_SELECT_ITEM').on('click.FORM_CUSTOM_SELECT_ITEM', settings.item, function (e) {
        e.preventDefault();
        var $selectWrapper = $(this).closest(settings.targetWrapper),
          $selectCurWrapper = $selectWrapper.find(settings.selector + '.js-uix-new'),
          curVal = $(this).data('value');

        //Close the selector
        $selectCurWrapper.removeClass('is-opened');

        //Set the selector text
        $selectCurWrapper.find(settings.trigger).text($(this).html()).addClass('is-active');

        //Activate this option
        $selectCurWrapper.find(settings.item).removeClass('is-active');
        $(this).addClass('is-active');

        //Set select option 'selected', by value
        $selectWrapper.find('select').val(curVal);
        $selectWrapper.find('select option').removeAttr('selected');
        $selectWrapper.find('select option[value="' + curVal + '"]').attr('selected', 'selected').change();
      });

      //Synchronize to the original select change event
      $(settings.selector).not('.js-uix-new').each(function () {
        var $this = $(this).find('select'),
          $cusSelect = $this.closest(settings.targetWrapper).find(settings.selector + '.js-uix-new');
        var newOptions = '';
        $this.closest(settings.targetWrapper).find('select option').each(function (index) {
          var selected = '';
          if ($(this).is(':selected')) {
            selected = 'is-active';
          }
          newOptions += '<span role="option" class="uix-controls__select__option ' + selected + '" data-value="' + $(this).attr('value') + '">' + $(this).html() + '</span>';
        });
        $cusSelect.find(settings.itemsWrapper).html('<div>' + newOptions + '</div>');

        //Set the default selector text
        $cusSelect.each(function (index) {
          $(this).find(settings.trigger).text($(this).find(settings.item + '.is-active').html());
        });
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/tag-input.js

/*
 * Render Tag Input
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderTagInput = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__tags-wrapper'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Initialize status
          //------------------------------------------
          var taginputTip = $this.data('placeholder');
          var $tagInputUserArea = $("<div><ul class=\"uix-controls__tags__list\"></ul><div class=\"uix-controls__tags\"><input type=\"text\" autoComplete=\"off\" placeholder=\"".concat(taginputTip, "\" value=\"\"></div></div>"));

          //init tag input
          $this.append($tagInputUserArea);

          //
          var lastId = -1;
          var defaultTagsVal = [];
          var maxTags = (0,esm_typeof/* default */.Z)($this.data('max-tags')) != ( true ? "undefined" : 0) ? $this.data('max-tags') : 10;
          var dVal = $this.find('> input').attr('type', 'hidden').val();

          //get default value
          if (dVal) {
            dVal.trim().replace(/^\,|\,$/g, '').split(',').forEach(function (item, index) {
              defaultTagsVal.push({
                content: item,
                id: index
              });
            });
          }

          //
          // What the user has entered
          var defaultItems = dVal !== '' && dVal !== null ? defaultTagsVal : [];

          //init data
          $this.data({
            'data': defaultItems,
            'user-input': '',
            'already-in-items': false,
            'max': maxTags
          });
          var updateTagResult = function updateTagResult(el, data) {
            var tagList = '';
            var resArr = [];
            data.forEach(function (listitem, index) {
              resArr.push(listitem.content);
              tagList += "<li data-item=\"".concat(listitem.id, "\">").concat(listitem.content, "</li>");
            });

            //update value
            el.find('> input').val(resArr.join(','));

            //create list
            el.find('.uix-controls__tags__list').html(tagList);
          };
          updateTagResult($this, defaultItems);

          // Mouse events
          //------------------------------------------
          $(document).off('click.FORM_TAG_INPUT_DELETE').on('click.FORM_TAG_INPUT_DELETE', settings.controls + ' .uix-controls__tags__list > li', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var idToRemove = Number(e.target.dataset["item"]);
            var newArray = currentItems.filter(function (listitem) {
              return listitem.id !== idToRemove;
            });
            currentItems = newArray;

            //update data
            $obj.data({
              'data': currentItems
            });

            //
            updateTagResult($obj, currentItems);
          });
          $(document).on('change input', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var _userInput = e.currentTarget.value;
            var _alreadyInItems = false;
            if (currentItems && currentItems.length > 0) {
              var alreadyIn = currentItems.some(function (obj) {
                return obj.content.toLowerCase() == _userInput.toLowerCase();
              });
              if (alreadyIn) {
                _alreadyInItems = true;
              } else {
                _alreadyInItems = false;
              }
            }

            //update data
            $obj.data({
              'user-input': e.currentTarget.value,
              'already-in-items': _alreadyInItems
            });
          });
          $(document).on('keypress', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            var currentItems = $obj.data('data');
            var userInput = $obj.data('user-input');
            var alreadyInItems = $obj.data('already-in-items');
            if (e.which == 13) {
              e.preventDefault();
              if (alreadyInItems) return false;

              //
              var newArray = currentItems;
              var currentcontent = userInput.trim();
              if (!currentcontent) {
                return;
              }

              //Limit the total number of tags added
              if ($obj.data('max') - 1 < newArray.length) {
                return;
              }
              newArray.push({
                content: currentcontent,
                id: ++lastId
              });
              currentItems = newArray;

              //update data
              $obj.data({
                'data': currentItems,
                'user-input': ''
              });

              //
              $(this).val('');
              updateTagResult($obj, currentItems);
            }
          });
          $(document).on('focus', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            $obj.addClass('is-active');
          });
          $(document).on('blur', settings.controls + ' .uix-controls__tags input', function (e) {
            var $obj = $(this).closest(settings.controls);
            $obj.removeClass('is-active');
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/number-input.js

/*
 * Render Number Input
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderNumberInput = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__number'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Mouse events
          //------------------------------------------
          $(document).off('click.FORM_NUMBER_BTN_ADD').on('click.FORM_NUMBER_BTN_ADD', settings.controls + ' .uix-controls__number__btn--add', function (e) {
            var step = parseFloat($(this).data('step')),
              decimals = $(this).data('decimals'),
              $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
              numberInputVal = parseFloat($numberInput.val()),
              max = $numberInput.attr('max');
            if ((0,esm_typeof/* default */.Z)(step) === ( true ? "undefined" : 0) || isNaN(step)) step = 1;
            if ((0,esm_typeof/* default */.Z)(decimals) === ( true ? "undefined" : 0)) decimals = 0;
            if ((0,esm_typeof/* default */.Z)(max) != ( true ? "undefined" : 0) && parseFloat(numberInputVal + step) > max) {
              step = 0;
            }
            numberInputVal = parseFloat(numberInputVal + step);
            $numberInput.val(numberInputVal.toFixed(decimals));
          });
          $(document).off('click.FORM_NUMBER_BTN_REMOVE').on('click.FORM_NUMBER_BTN_REMOVE', settings.controls + ' .uix-controls__number__btn--remove', function (e) {
            var step = $(this).data('step'),
              decimals = $(this).data('decimals'),
              $numberInput = $(this).closest('.uix-controls__number').find('input[type="number"]'),
              numberInputVal = parseFloat($numberInput.val()),
              min = $numberInput.attr('min');
            if ((0,esm_typeof/* default */.Z)(step) === ( true ? "undefined" : 0) || isNaN(step)) step = 1;
            if ((0,esm_typeof/* default */.Z)(decimals) === ( true ? "undefined" : 0)) decimals = 0;
            if ((0,esm_typeof/* default */.Z)(min) != ( true ? "undefined" : 0) && parseFloat(numberInputVal - step) < min) {
              step = 0;
            }
            numberInputVal -= step;
            $numberInput.val(numberInputVal.toFixed(decimals));
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/fn/dynamic-fields.js
















/*
 * Render Dynamic Fields
 *
 * @param  {String} controls                 - Wrapper of controls.
 * @return {Void}
 */
(function ($) {
  'use strict';

  $.fn.UixRenderDynamicFields = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      controls: '.uix-controls__dynamic-fields-container'
    }, options);
    this.each(function () {
      $(settings.controls).each(function () {
        var $this = $(this);
        var actived = $this.data('activated');
        if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
          // Mouse events
          //------------------------------------------
          var $addButton = $this.find('.uix-controls__dynamic-fields__addbtn'),
            //The add button
            $appendWrapper = $this.find('.uix-controls__dynamic-fields__append'),
            //The field wrapper ID or class 
            loopCls = '.uix-controls__dynamic-fields__tmpl__wrapper',
            defaultItems = $appendWrapper.find(loopCls).length;
          var x = defaultItems == 0 ? 1 : defaultItems + 1,
            maxField = $this.data('max-fields'),
            fieldHTML = '';

          //Maximum number of forms added
          if ((0,esm_typeof/* default */.Z)(maxField) === ( true ? "undefined" : 0)) {
            maxField = 5;
          }

          //Add a field
          var addOne = function addOne(fieldCode) {
            //replace the index of field name
            fieldCode = fieldCode.replace(/___GUID___/gi, UixGUID.create());

            //hide add button
            if (x == maxField) $addButton.hide();
            if (x <= maxField) {
              $appendWrapper.append(fieldCode);

              //Initialize Form
              $(document).UixRenderCustomSelect(); //Render Custom Select
              $(document).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox
              $(document).UixRenderControlsLineEff(); //Create Line Effect on Click
              $(document).UixRenderControlsDisable(); //Disabled Controls
              $(document).UixRenderCustomFile(); //Render Custom File Type
              $(document).UixRenderCustomFileDropzone(); //Render Custom File Dropzone
              $(document).UixRenderControlsHover(); //Hover Effect
              $(document).UixRenderCustomMultiSel(); //Render Multiple Selector
              $(document).UixRenderCustomSingleSel(); //Render Single Selector
              $(document).UixRenderNormalRadio(); //Render Normal Radio
              $(document).UixRenderDatePicker(); //Render Date Picker	
              $(document).UixRenderTagInput(); //Render Tag Input
              $(document).UixRenderNumberInput(); //Render Number Input

              x++;
            }
          };

          // default item
          if (defaultItems == 0) {
            addOne($this.find('.uix-controls__dynamic-fields__tmpl').html());
          }

          //Prevent duplicate function assigned
          $addButton.off('click').off('click').on('click', function (e) {
            e.preventDefault();

            //template init
            addOne($this.find('.uix-controls__dynamic-fields__tmpl').html());

            //Remove per item
            //Prevent duplicate function assigned
            $this.find('.uix-controls__dynamic-fields__removebtn').off('click').on('click', function (e) {
              e.preventDefault();

              //display add button
              $addButton.show();

              //remove current item
              $(this).closest(loopCls).remove();
              x--;
            });
            return false;
          });

          //------------------------------------------

          //Prevents front-end javascripts that are activated in the background to repeat loading.
          $this.data('activated', 1);
        } //endif actived			
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/form/js/index.js


/* 
 *************************************
 * <!-- Form -->
 *************************************
 */
/*
    Note:
	
	If you use the "change" event to asynchronously change a custom control of select, radio or checkbox, 
	you need add a callback function that initializes the style:
	
	$( document ).UixRenderXXXXXXXXX();

	
*/




















var FORM = function (module, $, window, document) {
  if (window.FORM === null) return false;
  module.FORM = module.FORM || {};
  module.FORM.version = '0.1.8';
  module.FORM.documentReady = function ($) {
    /*
     * Callbacks for special forms (supports asynchronous)
     * Add this code to initialize the style when calling 
     * the form externally with other scripts
     *
     * @return {Void}
     */
    $(document).UixRenderCustomSelect(); //Render Custom Select
    $(document).UixRenderCustomRadioCheckbox(); //Render Custom Radio, Toggle And Checkbox
    $(document).UixRenderControlsLineEff(); //Create Line Effect on Click
    $(document).UixRenderControlsDisable(); //Disabled Controls
    $(document).UixRenderCustomFile(); //Render Custom File Type
    $(document).UixRenderCustomFileDropzone(); //Render Custom File Dropzone
    $(document).UixRenderControlsHover(); //Hover Effect
    $(document).UixRenderCustomMultiSel(); //Render Multiple Selector
    $(document).UixRenderCustomSingleSel(); //Render Single Selector
    $(document).UixRenderNormalRadio(); //Render Normal Radio
    $(document).UixRenderDatePicker(); //Render Date Picker	
    $(document).UixRenderTagInput(); //Render Tag Input
    $(document).UixRenderDynamicFields(); //Render Dynamic Fields
    $(document).UixRenderNumberInput(); //Render Number Input

    /* 
     ---------------------------
     Click Event of Submit Button
     ---------------------------
     */
    //Search Submit Event in WordPress
    $('.uix-search-box__submit').off('click').on('click', function () {
      $(this).closest('form').submit();
    });
  };
  module.components.documentReady.push(module.FORM.documentReady);
  return /*#__PURE__*/_createClass(function FORM() {
    _classCallCheck(this, FORM);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/gallery/js/index.js


/* 
 *************************************
 * <!-- Gallery -->
 *************************************
 */


var GALLERY = function (module, $, window, document) {
  if (window.GALLERY === null) return false;
  module.GALLERY = module.GALLERY || {};
  module.GALLERY.version = '0.0.5';
  module.GALLERY.documentReady = function ($) {
    $('.uix-gallery').each(function () {
      var galleryType = $(this).data('show-type');

      /* 
       ---------------------------
       Add a tagname to each list item
       ---------------------------
       */
      // Masonry
      if (galleryType.indexOf('masonry') >= 0) {
        $(this).addClass('masonry-container');
        $(this).find('.uix-gallery__item').addClass('masonry-item');
      }

      // Filterable
      if (galleryType.indexOf('filter') >= 0) {
        $(this).addClass('filter-container');
        $(this).find('.uix-gallery__item').addClass('filter-item');
      }
      if (galleryType.indexOf('filter') >= 0 || galleryType.indexOf('masonry') >= 0) {
        var filterCat = $(this).data('filter-id'),
          $grid = $(this).find('.uix-gallery__tiles'),
          $allItems = $(this).find('.uix-gallery__item'),
          $filterOptions = $(filterCat);
        var MuuriGrid = new Muuri($grid.get(0), {
          items: $grid.get(0).querySelectorAll('.uix-gallery__item'),
          // Default show animation
          showDuration: 300,
          showEasing: 'ease',
          // Default hide animation
          hideDuration: 300,
          hideEasing: 'ease',
          // Item's visible/hidden state styles
          visibleStyles: {
            opacity: '1',
            transform: 'scale(1)'
          },
          hiddenStyles: {
            opacity: '0',
            transform: 'scale(0.5)'
          },
          // Layout
          layout: {
            fillGaps: false,
            horizontal: false,
            alignRight: false,
            alignBottom: false,
            rounding: true
          },
          layoutOnResize: 100,
          layoutOnInit: true,
          layoutDuration: 300,
          layoutEasing: 'ease',
          //// Drag & Drop
          dragEnabled: false
        });

        // When all items have loaded refresh their
        // dimensions and layout the grid.
        $grid.waitForImages().done(function () {
          MuuriGrid.refreshItems().layout();
          // For a little finishing touch, let's fade in
          // the images after all them have loaded and
          // they are corrertly positioned.
          $('body').addClass('images-loaded');
        });

        /* 
         ---------------------------
         Function of Filterable and Masonry
         ---------------------------
         */
        if (galleryType.indexOf('filter') >= 0) {
          $filterOptions.find('li > a').off('click').on('click', function () {
            var $this = $(this);
            var activeClass = 'current-cat',
              isActive = $this.parent().hasClass(activeClass),
              group = isActive ? 'all' : $this.data('group');

            // Hide current label, show current label in title
            if (!isActive) {
              $filterOptions.find('.' + activeClass).removeClass(activeClass);
            }
            $this.parent().toggleClass(activeClass);

            // Filter elements
            var filterFieldValue = group;
            MuuriGrid.filter(function (item) {
              var element = item.getElement(),
                curCats = element.getAttribute('data-groups').toString().replace(/^\,|\,$/g, '').replace(/^\[|\]$/g, '') + ',all',
                isFilterMatch = !filterFieldValue ? true : (curCats || '').indexOf(filterFieldValue) > -1;
              return isFilterMatch;
            });
            return false;
          });
        } else {
          //remove filter button of all
          $filterOptions.find('[data-group="all"]').parent('li').remove();
        }
      }
    });
  };
  module.components.documentReady.push(module.GALLERY.documentReady);
  return /*#__PURE__*/_createClass(function GALLERY() {
    _classCallCheck(this, GALLERY);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/hybrid-content-slider/js/index.js



/* 
 *************************************
 * <!-- Hybrid Content Slider -->
 *************************************
 */


var HYBRID_CONTENT_SLIDER = function (module, $, window, document) {
  if (window.HYBRID_CONTENT_SLIDER === null) return false;
  module.HYBRID_CONTENT_SLIDER = module.HYBRID_CONTENT_SLIDER || {};
  module.HYBRID_CONTENT_SLIDER.version = '0.1.1';
  module.HYBRID_CONTENT_SLIDER.pageLoaded = function () {
    $('.uix-hybrid-content-slider').each(function () {
      var $sliderWrapper = $(this),
        $slider = $sliderWrapper.find('.uix-hybrid-content-slider__items'),
        $sliderItem = $sliderWrapper.find('.uix-hybrid-content-slider__items > div'),
        itemsTotal = $sliderItem.length,
        amountVisible = 1,
        sliderDir = $sliderWrapper.data('dir'),
        sliderSpeed = $sliderWrapper.data('speed'),
        sliderNext = $sliderWrapper.data('next'),
        sliderPrev = $sliderWrapper.data('prev'),
        sliderPagination = $sliderWrapper.data('pagination'),
        carouseDraggable = $sliderWrapper.data('draggable'),
        carouseDraggableCursor = $sliderWrapper.data('draggable-cursor');
      if ((0,esm_typeof/* default */.Z)(sliderDir) === ( true ? "undefined" : 0)) sliderDir = 'horizontal';
      if ((0,esm_typeof/* default */.Z)(sliderSpeed) === ( true ? "undefined" : 0)) sliderSpeed = 250;
      if ((0,esm_typeof/* default */.Z)(sliderNext) === ( true ? "undefined" : 0)) sliderNext = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--next';
      if ((0,esm_typeof/* default */.Z)(sliderPrev) === ( true ? "undefined" : 0)) sliderPrev = '#uix-hybrid-content-slider__controls-123 .uix-hybrid-content-slider__controls--prev';
      if ((0,esm_typeof/* default */.Z)(sliderPagination) === ( true ? "undefined" : 0)) sliderPagination = '#uix-hybrid-content-slider__pagination-123';
      if ((0,esm_typeof/* default */.Z)(carouseDraggable) === ( true ? "undefined" : 0)) carouseDraggable = false;
      if ((0,esm_typeof/* default */.Z)(carouseDraggableCursor) === ( true ? "undefined" : 0)) carouseDraggableCursor = 'move';

      //Autoplay parameters
      var dataAuto = $sliderWrapper.data('auto'),
        dataTiming = $sliderWrapper.data('timing'),
        dataLoop = $sliderWrapper.data('loop');
      if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
      if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
      if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;

      //Autoplay times
      var playTimes;
      //A function called "timer" once every second (like a digital watch).
      $sliderWrapper[0].animatedSlides;

      //Store the latest position (X,Y) in a temporary variable
      var tempItemsPos = [];

      //each item width and height
      var eachItemNewWidth,
        eachItemNewHeight = [];

      // Returns the value of a number rounded to the nearest integer.
      var midIndex = 0;

      // Get the width and height of each item
      $sliderItem.each(function (index) {
        var _height = $(this).height();
        eachItemNewHeight.push(_height);
        $(this).attr({
          'data-height': _height,
          'data-index': index
        });
      });

      //Returns the total height of items
      var totalItemsHeight = 0;
      for (var i = 0; i < eachItemNewHeight.length; i++) {
        totalItemsHeight += eachItemNewHeight[i];
        if (i + 1 == itemsTotal - amountVisible) break;
      }

      //Set target index of the slider buttons
      setButtonTargetIndex($(sliderNext), $(sliderPrev), 'init', null);

      //set actived item & initialize the height of container
      setContainerSize(0);
      $sliderItem.addClass('js-is-ready');

      // Activate the current item from carouse
      setItemState(0);

      /* 
       ---------------------------
       Initialize slider
       ---------------------------
       */
      var eachItemOldWidth = $slider.width() / amountVisible;
      eachItemNewWidth = $sliderWrapper.width() / amountVisible;
      if (sliderDir === 'horizontal') {
        $slider.css('width', itemsTotal * eachItemOldWidth);
      }

      // Re-order all items
      sliderReOrder();

      //default button status
      $(sliderPrev).addClass('is-disabled').data('disabled', 1);

      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */

      function sliderReOrder() {
        //Initialize the width and height of each item
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($sliderItem, {
            width: boxWidth,
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            x: function x(i, target) {
              return i * boxWidth;
            }
          });
        } else {
          TweenMax.set($sliderItem, {
            height: function height(i, target) {
              return eachItemNewHeight[i];
            },
            y: function y(i, target) {
              var yIncrement = 0;
              for (var k = 0; k < eachItemNewHeight.length; k++) {
                var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }
              return yIncrement;
            }
          });
        }
      }

      /* 
       ---------------------------
       Next/Prev buttons
       ---------------------------
       */
      var _prev = $(sliderPrev),
        _next = $(sliderNext);
      _next.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnNextMove();
      });
      _prev.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnPrevMove();
      });

      // (right/down)
      function btnPrevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;
        _prev.attr('aria-disabled', 'true');
        _prev.delay(sliderSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');
          next();
        });

        //
        movePositionWithButton(false, _prev, 'prev');

        //Pause the auto play event
        clearInterval($sliderWrapper[0].animatedSlides);
      }

      // (left/up)
      function btnNextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;
        _next.attr('aria-disabled', 'true');
        _next.delay(sliderSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');
          next();
        });

        //
        movePositionWithButton(false, _next, 'next');

        //Pause the auto play event
        clearInterval($sliderWrapper[0].animatedSlides);
      }

      /* 
       ---------------------------
       Pagination
       ---------------------------
       */
      if ($(sliderPagination).length > 0 && $(sliderPagination).html().length == 0) {
        //Button to add pagination automatically
        var _dot = '';
        _dot += '<ul class="uix-hybrid-content-slider__pagination--default">';
        for (var _i = 0; _i < itemsTotal; _i++) {
          _dot += '<li><a data-target-index="' + _i + '" href="javascript:void(0);"></a></li>';
        }
        _dot += '</ul>';
        $(sliderPagination).html(_dot).promise().done(function () {
          // Activate the currently selected Pagination
          setPaginationState(0);
        });
      } else {
        // Activate the currently selected Pagination
        setPaginationState(0);
      }
      $(sliderPagination).find('li a').off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();

        //Prevent buttons' events from firing multiple times
        if ($(this).attr('aria-disabled') == 'true') return false;
        $(sliderPagination).find('li a').attr('aria-disabled', 'true');
        $(sliderPagination).find('li a').delay(sliderSpeed).queue(function (next) {
          $(sliderPagination).find('li a').attr('aria-disabled', 'false');
          next();
        });

        //
        if (!$(this).parent().hasClass('is-active')) {
          movePositionWithButton(true, $(this), 'next');

          //Pause the auto play event
          clearInterval($sliderWrapper[0].animatedSlides);
        }
      });

      //Drag and Drop
      //-------------------------------------	
      var $dragDropTrigger = $sliderWrapper;
      var hammerProps = {};

      //Make the cursor a move icon when a user hovers over an item
      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);
      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      }

      //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag
      var direction;
      var dragDropElement = $dragDropTrigger[0],
        dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true;
      var targetIndex = 0;

      //Temporarily store arrays as strings
      //!!!important ///////////////////////////////////////
      //!!! Prevent dragging events from nesting multiple 
      //!!! times to reduce subscripts.
      //!!!important ///////////////////////////////////////
      var allHeightStr = eachItemNewHeight.toString();

      // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element
      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type;

        //Get the current item index
        targetIndex = $(ev.target).data('index');
        if ((0,esm_typeof/* default */.Z)(targetIndex) === ( true ? "undefined" : 0)) targetIndex = $(ev.target).closest('.uix-hybrid-content-slider__item').data('index');
        if ((0,esm_typeof/* default */.Z)(targetIndex) === ( true ? "undefined" : 0)) targetIndex = $(ev.target).find('.uix-hybrid-content-slider__item').data('index');
        switch (direction) {
          case 'panleft':
          case 'panup':
            targetIndex = targetIndex + 1;
            break;
          case 'panright':
          case 'pandown':
            targetIndex = targetIndex;
            break;
        }

        //Determine whether it is the first or the last    
        var currentIsFirstOrLast = false;
        var firstItemOffset = sliderDir === 'horizontal' ? $slider.find('[data-index="0"]')[0]._gsTransform.x : $slider.find('[data-index="0"]')[0]._gsTransform.y;
        var maxMoveOffset = sliderDir === 'horizontal' ? -eachItemNewWidth * (itemsTotal - amountVisible) : -totalItemsHeight;

        //
        if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
          //first item
          currentIsFirstOrLast = true;
        }
        if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
          //last item
          currentIsFirstOrLast = true;
        }

        //Rebound effect of drag offset 
        //
        //!important -> Please do not use multiple case conditions, 
        //otherwise it may cause vertical data problems

        if (sliderDir === 'horizontal') {
          switch (direction) {
            case 'panleft':
              if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
                elAnim = false;
                var simulationButtonNext = $(sliderNext);
                itemUpdates($sliderWrapper, simulationButtonNext, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }
              break;
            case 'panright':
              if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
                elAnim = false;
                var simulationButtonPrev = $(sliderPrev);
                itemUpdates($sliderWrapper, simulationButtonPrev, ev.deltaX, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }
              break;
          }
        } else {
          var draggingItemHeight = (0,esm_typeof/* default */.Z)(allHeightStr.split(',')[targetIndex - 1]) === ( true ? "undefined" : 0) ? allHeightStr.split(',')[targetIndex] : allHeightStr.split(',')[targetIndex - 1];
          switch (direction) {
            case 'panup':
              if (ev.deltaY > -draggingItemHeight / 4 && ev.deltaY < 0) {
                elAnim = false;
                var _simulationButtonNext = $(sliderNext);
                itemUpdates($sliderWrapper, _simulationButtonNext, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }
              break;
            case 'pandown':
              if (ev.deltaY < draggingItemHeight / 4 && ev.deltaY > 0) {
                elAnim = false;
                var _simulationButtonPrev = $(sliderPrev);
                itemUpdates($sliderWrapper, _simulationButtonPrev, ev.deltaY, 0.1, true, targetIndex, allHeightStr);
              } else {
                elAnim = currentIsFirstOrLast ? false : true;
              }
              break;
          }
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          //
          //!important -> Please do not use multiple case conditions, 
          //otherwise it may cause vertical data problems

          if (sliderDir === 'horizontal') {
            switch (direction) {
              case 'panleft':
                btnNextMove();
                break;
              case 'panright':
                btnPrevMove();
                break;
            }
          } else {
            switch (direction) {
              case 'panup':
                btnNextMove();
                break;
              case 'pandown':
                btnPrevMove();
                break;
            }
          }
        } else {
          //Rebound effect of drag offset 
          itemUpdates($sliderWrapper, false, tempItemsPos, null, false, targetIndex, allHeightStr);
        }

        //Pause the auto play event
        clearInterval($sliderWrapper[0].animatedSlides);
      });

      //Autoplay Slider
      //-------------------------------------		
      if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
        sliderAutoPlay(playTimes, dataTiming, dataLoop);
        var autoplayEnter = function autoplayEnter() {
          clearInterval($sliderWrapper[0].animatedSlides);
        };
        var autoplayLeave = function autoplayLeave() {
          sliderAutoPlay(playTimes, dataTiming, dataLoop);
        };

        // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid
        $sliderWrapper.on('mouseenter', autoplayEnter);
        $sliderWrapper.on('mouseleave', autoplayLeave);

        // To determine if it is a touch screen.
        if (Modernizr.touchevents) {
          $sliderWrapper.on('pointerenter', autoplayEnter);
          $sliderWrapper.on('pointerleave', autoplayLeave);
        }
      }

      /*
       * Trigger slider autoplay
       *
       * @param  {Function} playTimes      - Number of times.
       * @param  {Number} timing           - Autoplay interval.
       * @param  {Boolean} loop            - Gives the slider a seamless infinite loop.
       * @return {Void}             
       */
      function sliderAutoPlay(playTimes, timing, loop) {
        $sliderWrapper[0].animatedSlides = setInterval(function () {
          var autoMove = function autoMove(indexGo) {
            // Retrieve the position (X,Y) of an element 
            var moveX = eachItemNewWidth * indexGo;
            var moveYIncrement = 0;
            for (var k = 0; k < eachItemNewHeight.length; k++) {
              var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
              moveYIncrement += tempY;
              if (k == indexGo) break;
            }
            var moveY = moveYIncrement;

            //
            var delta = sliderDir === 'horizontal' ? -moveX : -moveY;

            //
            itemUpdates($sliderWrapper, 'auto', delta, null, false, indexGo, eachItemNewHeight);
          };
          playTimes = parseFloat($sliderItem.filter('.is-active').index());
          playTimes++;
          if (!loop) {
            if (playTimes < itemsTotal && playTimes >= 0) {
              autoMove(playTimes);
            }
          } else {
            if (playTimes == itemsTotal) playTimes = 0;
            if (playTimes < 0) playTimes = itemsTotal - 1;
            autoMove(playTimes);
          }
        }, timing);
      }

      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper                  - Wrapper of slider.
       * @param  {?Element|String|Boolean} curBtn   - The button that currently triggers the move.
                * @param  {Number|Array} delta               - The value returned will need to be adjusted according 
                *                                              to the offset  * rate.
                * @param  {?Number} speed                     - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging                  - Determine if the object is being dragged.
                * @param  {!Number} indexGo                   - The target item index.
                * @param  {String|Array} itemsHeight          - Return all items height (the string type is 
                *                                               used when a drag event is triggered).
       * @return {Void}
       */
      function itemUpdates(wrapper, curBtn, delta, speed, dragging, indexGo, itemsHeight) {
        if (speed == null) speed = sliderSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-hybrid-content-slider__items'),
          //Default: $slider
          $curItems = $curWrapper.find('> div'); //Default: $sliderItem

        //Get height constant
        var itemsHeightArr = [];
        var _itemsHeight = itemsHeight.toString().split(',');
        _itemsHeight.forEach(function (element) {
          itemsHeightArr.push(parseFloat(element));
        });

        //Check next or previous event
        var btnType = 'init';
        if (curBtn !== false && curBtn !== 'auto') {
          if ((0,esm_typeof/* default */.Z)(curBtn.attr('class')) !== ( true ? "undefined" : 0)) {
            btnType = curBtn.attr('class').indexOf('--next') >= 0 ? 'next' : 'prev';
          } else {
            btnType = 'next';
          }
        }

        //Check next or previous event ( Autoplay )
        if (curBtn === 'auto') btnType = 'next';
        ;

        //Clone the first element to the last position
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var xIncrement = 0;
              for (var k = 0; k < itemsTotal; k++) {
                var tempX = k == 0 ? 0 : boxWidth;
                xIncrement += tempX;
                if (k == i) break;
              }
              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? xIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );

                  var curWidthIncrement = 0;
                  for (var m = 0; m < itemsTotal; m++) {
                    var tempW = m == 0 ? 0 : boxWidth;
                    curWidthIncrement += tempW;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }
                  return xIncrement + -curWidthIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
                  return x + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //Get index of current element
                var currentIndex = 0;

                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth));

                //Initialize the height of container
                currentIndex = Math.round($curItems.first()[0]._gsTransform.x / boxWidth);
                setContainerSize(currentIndex);

                //Set target index of the slider buttons
                setButtonTargetIndex($(sliderNext), $(sliderPrev), btnType, btnType == 'next' ? Math.abs(currentIndex) : Math.abs(currentIndex) + 1);

                // Activate the currently selected Pagination
                setPaginationState(Math.abs(currentIndex));

                // Activate the current item from carouse
                setItemState(Math.abs(currentIndex));

                //Store the latest position (X,Y) in a temporary variable
                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        } else {
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var yIncrement = 0;
              for (var k = 0; k < itemsHeightArr.length; k++) {
                var tempY = (0,esm_typeof/* default */.Z)(itemsHeightArr[k - 1]) === ( true ? "undefined" : 0) ? 0 : itemsHeightArr[k - 1];
                yIncrement += tempY;
                if (k == i) break;
              }
              if (Array.isArray(delta)) {
                //Rebound effect of drag offset 
                return delta.length == 0 ? yIncrement : delta[i];
              } else {
                if (!dragging) {
                  //console.log( 'btnType: ' + btnType + ' indexGo: ' + indexGo );

                  var curHeightIncrement = 0;
                  for (var m = 0; m < itemsHeightArr.length; m++) {
                    var tempH = (0,esm_typeof/* default */.Z)(itemsHeightArr[m - 1]) === ( true ? "undefined" : 0) ? 0 : itemsHeightArr[m - 1];
                    curHeightIncrement += tempH;
                    if (m == (btnType == 'next' ? indexGo : indexGo - 1)) break;
                  }
                  return yIncrement + -curHeightIncrement;
                } else {
                  //console.log( 'dragging...' );
                  var draggingItemHeight = (0,esm_typeof/* default */.Z)(itemsHeightArr[indexGo - 1]) === ( true ? "undefined" : 0) ? itemsHeightArr[indexGo] : itemsHeightArr[indexGo - 1];
                  var y = Math.round(target._gsTransform.y / draggingItemHeight) * draggingItemHeight;
                  return y + delta;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && !Array.isArray(delta)) {
                //The state of the control button
                setButtonState($curItems.first()[0]._gsTransform.y, totalItemsHeight);

                //Set target index of the slider buttons
                setButtonTargetIndex($(sliderNext), $(sliderPrev), btnType, indexGo);

                //set actived item & initialize the height of container
                setContainerSize(btnType == 'next' ? indexGo : indexGo - 1);

                // Activate the currently selected Pagination
                setPaginationState(btnType == 'next' ? indexGo : indexGo - 1);

                // Activate the current item from carouse
                setItemState(btnType == 'next' ? indexGo : indexGo - 1);

                //Store the latest position (X,Y) in a temporary variable
                tempItemsPos = createStoreLatestPosition();
              }
            }
          });
        }
      }

      /*
       * Use the button to trigger the transition between the two sliders
       *
       * @param  {Boolean} paginationEnabled   - Determine whether it is triggered by pagination
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */
      function movePositionWithButton(paginationEnabled, $btn, type) {
        var
          //Protection button is not triggered multiple times.
          btnDisabled = $btn.data('disabled'),
          //Get current button index
          tIndex = parseFloat($btn.attr('data-target-index'));

        // Retrieve the position (X,Y) of an element 
        var moveX = eachItemNewWidth,
          moveY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[tIndex - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[tIndex - 1];
        if (paginationEnabled) {
          //--
          moveX = eachItemNewWidth * tIndex;

          //--
          var moveYIncrement = 0;
          for (var k = 0; k < eachItemNewHeight.length; k++) {
            var tempY = (0,esm_typeof/* default */.Z)(eachItemNewHeight[k - 1]) === ( true ? "undefined" : 0) ? 0 : eachItemNewHeight[k - 1];
            moveYIncrement += tempY;
            if (k == tIndex) break;
          }
          moveY = moveYIncrement;
        }

        //
        var delta;
        if (type == 'next') {
          delta = sliderDir === 'horizontal' ? -moveX : -moveY;
        } else {
          delta = sliderDir === 'horizontal' ? moveX : moveY;
        }
        if ((0,esm_typeof/* default */.Z)(btnDisabled) === ( true ? "undefined" : 0)) {
          itemUpdates($sliderWrapper, $btn, delta, null, false, tIndex, eachItemNewHeight);
        }
      }

      /*
       * Activate the currently selected Pagination
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */
      function setPaginationState(index) {
        $(sliderPagination).find('li').removeClass('is-active');
        $(sliderPagination).find('li a[data-target-index="' + index + '"]').parent().addClass('is-active');
      }

      /*
       * Activate the current item from carouse
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */
      function setItemState(index) {
        $sliderItem.removeClass('is-active');
        $sliderItem.eq(index).addClass('is-active');
      }

      /*
       * Store the latest position (X,Y) in a temporary variable
       *
       * @return {Array}              - Return to a new position.
       */
      function createStoreLatestPosition() {
        var pos = [];
        // Retrieve the temporary variable of each item.
        $sliderItem.each(function () {
          pos.push(sliderDir === 'horizontal' ? $(this)[0]._gsTransform.x : $(this)[0]._gsTransform.y);
        });
        return pos;
      }

      /*
       * Initialize the height of container
       *
                * @param  {Number} index          - Get index of current element.
       * @return {Void}
       */
      function setContainerSize(index) {
        var _h = eachItemNewHeight[Math.abs(index)];
        if ((0,esm_typeof/* default */.Z)(_h) !== ( true ? "undefined" : 0)) {
          TweenMax.to($slider, 0.2, {
            height: eachItemNewHeight[Math.abs(index)]
          });
        }
      }

      /*
       * Set target index of the slider buttons
       *
       * @param  {Element} nextBtn      - The next move button.
       * @param  {Element} prevBtn      - The previous move button.
                * @param  {String} type          - The type of button is triggered. Values: next, prev, init
                * @param  {?Number} indexGo      - The target item index.
       * @return {Void}
       */
      function setButtonTargetIndex(nextBtn, prevBtn, type, indexGo) {
        switch (type) {
          case 'init':
            nextBtn.attr({
              'data-target-index': 1
            });
            prevBtn.attr({
              'data-target-index': 0
            });
            break;
          case 'next':
            var nextBtnOldTargetIndex1 = parseFloat(nextBtn.attr('data-target-index'));
            var prevBtnOldTargetIndex1 = parseFloat(prevBtn.attr('data-target-index'));
            if (indexGo != null) {
              nextBtnOldTargetIndex1 = indexGo;
              prevBtnOldTargetIndex1 = indexGo - 1;
            }
            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex1 + 1
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex1 + 1
            });
            break;
          case 'prev':
            var nextBtnOldTargetIndex2 = parseFloat(nextBtn.attr('data-target-index')) - 1;
            var prevBtnOldTargetIndex2 = parseFloat(prevBtn.attr('data-target-index')) - 1;
            if (indexGo != null) {
              nextBtnOldTargetIndex2 = indexGo;
              prevBtnOldTargetIndex2 = indexGo - 1;
            }
            nextBtn.attr({
              'data-target-index': nextBtnOldTargetIndex2
            });
            prevBtn.attr({
              'data-target-index': prevBtnOldTargetIndex2
            });
            break;
        }
      }

      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */
      function setButtonState(firstOffset, lastOffset) {
        if (Math.abs(firstOffset) == lastOffset) {
          $(sliderNext).addClass('is-disabled').data('disabled', 1);
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        }
      }
    });
  };
  module.components.pageLoaded.push(module.HYBRID_CONTENT_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function HYBRID_CONTENT_SLIDER() {
    _classCallCheck(this, HYBRID_CONTENT_SLIDER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/hover-delay-interaction/js/index.js


/* 
 *************************************
 * <!-- Hover Delay Interaction -->
 *************************************
 */

var HOVER_DELAY_INTERACTION = function (module, $, window, document) {
  if (window.HOVER_DELAY_INTERACTION === null) return false;
  module.HOVER_DELAY_INTERACTION = module.HOVER_DELAY_INTERACTION || {};
  module.HOVER_DELAY_INTERACTION.version = '0.0.1';
  module.HOVER_DELAY_INTERACTION.documentReady = function ($) {
    var delayTime = 250;
    $('.uix-hover-delay-el').on('mouseover', function () {
      var $this = $(this);
      if ($this.prop('hoverTimeout')) {
        $this.prop('hoverTimeout', clearTimeout($this.prop('hoverTimeout')));
      }
      $this.prop('hoverIntent', setTimeout(function () {
        $this.find('> div').html('Okay!');
      }, delayTime));
    }).on('mouseleave', function () {
      var $this = $(this);
      if ($this.prop('hoverIntent')) {
        $this.prop('hoverIntent', clearTimeout($this.prop('hoverIntent')));
      }
      $this.prop('hoverTimeout', setTimeout(function () {
        $this.find('> div').html('Touch Me');
      }, delayTime));
    });
  };
  module.components.documentReady.push(module.HOVER_DELAY_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function HOVER_DELAY_INTERACTION() {
    _classCallCheck(this, HOVER_DELAY_INTERACTION);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/image-shapes/js/index.js


/* 
 *************************************
 * <!-- Image Shapes -->
 *************************************
 */


var IMAGE_SHAPES = function (module, $, window, document) {
  if (window.IMAGE_SHAPES === null) return false;
  module.IMAGE_SHAPES = module.IMAGE_SHAPES || {};
  module.IMAGE_SHAPES.version = '0.0.2';
  module.IMAGE_SHAPES.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //  Initialize
    shapesInit(windowWidth);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        shapesInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize Shapes
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @param  {Number} h         - Returns height of browser viewport
     * @return {Void}
     */
    function shapesInit(w) {
      $('.uix-shape-img').each(function () {
        var $this = $(this);
        var ranID = 'uix-shape-img-' + UixGUID.create(),
          svgPath = $this.data('path'),
          svgW = parseFloat($this.data('svg-const-width')),
          svgH = parseFloat($this.data('svg-const-height')),
          svgRatio = svgW / svgH,
          curImgURL = $this.find('img').attr('src');
        var imgW = parseFloat($this.data('img-width'));
        var imgRatio = null,
          bothWidthRatio = null,
          newSvgHeight = null,
          newImgHeight = null,
          svgOut = '',
          curImgW = imgW,
          curImgH = null;
        if (imgW > w) {
          imgW = w;
        }

        //Check if the picture is loaded on the page
        var img = new Image();
        img.onload = function () {
          curImgH = $this.find('img').height();
          curImgW = $this.find('img').width();
          imgRatio = curImgW / curImgH;

          //Add a custom shape SVG to the page
          bothWidthRatio = imgW / svgW;
          newSvgHeight = imgW / svgRatio;
          newImgHeight = svgW / imgRatio;
          svgOut += '<svg fill-rule="evenodd" clip-rule="evenodd" width="' + imgW + 'px" height="' + newSvgHeight + 'px" viewBox="0 0 ' + imgW + ' ' + newSvgHeight + '" >';
          svgOut += '	<pattern id="' + ranID + '" patternUnits="userSpaceOnUse" width="' + svgW + '" height="' + svgH + '">';
          svgOut += '		  <image xlink:href="' + curImgURL + '" width="' + svgW + 'px" height="' + newImgHeight + 'px" x="0" y="0" />';
          svgOut += '	</pattern> ';
          svgOut += '	<path fill="url(#' + ranID + ')" transform="scale(' + bothWidthRatio + ')" d="' + svgPath + '"/>';
          svgOut += '</svg>';
          $this.addClass('is-active').html(svgOut);
        };
        img.src = curImgURL;
      });
    }
  };
  module.components.documentReady.push(module.IMAGE_SHAPES.documentReady);
  return /*#__PURE__*/_createClass(function IMAGE_SHAPES() {
    _classCallCheck(this, IMAGE_SHAPES);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/infinite-scrolling-element/js/index.js



/* 
 *************************************
 * <!-- Infinite Scrolling Element -->
 *************************************
 */


var INFINITE_SCROLLING_EL = function (module, $, window, document) {
  if (window.INFINITE_SCROLLING_EL === null) return false;
  module.INFINITE_SCROLLING_EL = module.INFINITE_SCROLLING_EL || {};
  module.INFINITE_SCROLLING_EL.version = '0.0.3';
  module.INFINITE_SCROLLING_EL.documentReady = function ($) {
    $('.uix-infinite-scrolling').each(function () {
      var $this = $(this);
      var speed = $this.data('speed'),
        gap = $this.data('gap');
      if ((0,esm_typeof/* default */.Z)(speed) === ( true ? "undefined" : 0)) speed = 3000;
      if ((0,esm_typeof/* default */.Z)(gap) === ( true ? "undefined" : 0)) gap = 20;
      var root = $this[0];
      var wrapperWidth = root.clientWidth;
      var $list = root.firstElementChild; // whitespace nodes might interfere with using `firstChild`
      var $itemsOriginal = $list.children;
      var itemsTotal = $itemsOriginal.length;

      //original width (including: padding)
      //------------------------------------------
      var itemsWidthOriginal = [];
      Array.prototype.forEach.call($list.children, function (node, index) {
        itemsWidthOriginal.push(node.clientWidth + gap);
      });
      var allWidthOriginal = itemsWidthOriginal.reduce(function (previousValue, currentValue, currentIndex, array) {
        var newVal = previousValue + currentValue;
        return newVal;
      });

      //clone elements in order to complement content area
      //------------------------------------------
      var loopTimes = Math.ceil(wrapperWidth / allWidthOriginal);
      for (var i = 0; i < loopTimes; i++) {
        var $clonedItems = $list.cloneNode(true).querySelectorAll('li'); //do not use `children`
        Array.prototype.some.call($clonedItems, function (node, index) {
          $list.appendChild(node);
          if (index === itemsTotal - 1) return true;
        });
      }

      //calculate the total width
      //------------------------------------------
      var $items = root.getElementsByTagName('li');
      var itemsWidth = [];
      var itemPos = [];
      Array.prototype.forEach.call($items, function (node, index) {
        itemsWidth.push(node.clientWidth + gap);
      });
      itemPos.push(0, itemsWidth[0]);
      var allWidth = itemsWidth.reduce(function (previousValue, currentValue, currentIndex, array) {
        var newVal = previousValue + currentValue;
        itemPos.push(newVal);
        return newVal;
      });
      itemPos.pop();

      // console.log('itemsWidth: ', itemsWidth);
      // console.log('itemPos: ', itemPos);
      // console.log('allWidth: ', allWidth);

      //initially colorize each box and position in a row
      //------------------------------------------
      TweenMax.set($items, {
        x: function x(i) {
          return itemPos[i];
        }
      });

      //TimelineMax
      var tl = new TimelineMax({
        repeat: -1,
        paused: true
      });
      tl.to($items, speed / 1000, {
        ease: Linear.easeNone,
        x: "-=" + allWidthOriginal,
        //move each box "allWidthOriginal" to left
        modifiers: {
          x: function x(_x, target) {
            return _x % allWidth; //force x value to be between 0 and "allWidth" using modulus
          }
        }
      }).progress(1).progress(0).play();

      //Pause/Play		
      $this.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();
      });
    });
  };
  module.components.documentReady.push(module.INFINITE_SCROLLING_EL.documentReady);
  return /*#__PURE__*/_createClass(function INFINITE_SCROLLING_EL() {
    _classCallCheck(this, INFINITE_SCROLLING_EL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/lava-lamp-style-menu/js/index.js


/* 
 *************************************
 * <!-- Lava-Lamp Style Menu -->
 *************************************
 */


var LAVA_LAMP_STYLE_MENU = function (module, $, window, document) {
  if (window.LAVA_LAMP_STYLE_MENU === null) return false;
  module.LAVA_LAMP_STYLE_MENU = module.LAVA_LAMP_STYLE_MENU || {};
  module.LAVA_LAMP_STYLE_MENU.version = '0.0.3';
  module.LAVA_LAMP_STYLE_MENU.documentReady = function ($) {
    var $menuContainer = $('.uix-lavalamp-menu__container'),
      menu = 'ul.uix-lavalamp-menu',
      followEl = menu + ' .uix-lavalamp-menu__slide-line';

    //Prevent this module from loading in other pages
    if ($menuContainer.length == 0) return false;

    // adds sliding underline HTML
    $(menu).append('<span class="uix-lavalamp-menu__slide-line"></span>');

    // set initial position of element
    TweenMax.set(followEl, {
      css: {
        width: 0,
        x: 0,
        y: 0
      }
    });
    function mouseFollowEv(index) {
      var $this = $(menu + ' > li').eq(index).find('a'),
        offset = $this.offset(),
        offsetBody = $('.uix-lavalamp-menu__container').offset(); //find the offset of the wrapping div  

      //Activate navigation style
      $(menu + ' > li').removeClass('is-active');
      $this.parent().addClass('is-active');

      // GSAP animate to clicked menu item
      TweenMax.to(followEl, 1, {
        css: {
          width: parseFloat($this.outerWidth() + 0) + 'px',
          x: offset.left - offsetBody.left + 'px'
        },
        ease: Elastic.easeOut.config(1, 0.5)
      });
    }

    //!import: Please do not try `$( document ).on( MOUSE_EVENT )` to improve performance
    $(menu + ' > li a').on('mouseover', function () {
      mouseFollowEv($(this).parent().index());
    });
    mouseFollowEv(0);
  };
  module.components.documentReady.push(module.LAVA_LAMP_STYLE_MENU.documentReady);
  return /*#__PURE__*/_createClass(function LAVA_LAMP_STYLE_MENU() {
    _classCallCheck(this, LAVA_LAMP_STYLE_MENU);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
// EXTERNAL MODULE: ./src/components/_third-party-plugins/Miscellaneous/scrollLock.js
var scrollLock = __webpack_require__(111);
;// CONCATENATED MODULE: ./src/components/lightbox/js/index.js



/* 
 *************************************
 * <!-- Custom Lightbox -->
 *************************************
 */




var LIGHTBOX = function (module, $, window, document) {
  if (window.LIGHTBOX === null) return false;
  module.LIGHTBOX = module.LIGHTBOX || {};
  module.LIGHTBOX.version = '0.2.3';
  module.LIGHTBOX.pageLoaded = function () {
    if ($('.uix-lightbox__container').length == 0) {
      $('body').prepend('<div class="uix-lightbox__loading is-loaded uix-t-c"><i class="fa fa-spinner fa-spin"></i> Loading...</div><a class="uix-lightbox__original__close" href="javascript:void(0);"></a><div class="uix-lightbox__container"><div class="uix-lightbox__inner"><div class="uix-lightbox__html"></div><p class="title"></p></div></div><div class="uix-lightbox__container-mask"></div><div class="uix-lightbox__close"><button type="button"></button></div>');
    }

    // To display the template tag content.
    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
          return html.replace(/[\r\n]/g, '');
        }).html(),
        _id = $(this).attr('id');

      //If it is dialog, clone the contents of the <template> into the body
      if ((0,esm_typeof/* default */.Z)(_id) !== ( true ? "undefined" : 0) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id);

        //append content to body
        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });
    var innerEl = '.uix-lightbox__inner',
      wrapperEl = '.uix-lightbox__container',
      loaderEl = '.uix-lightbox__loading',
      maskEl = '.uix-lightbox__container-mask',
      closeEl = '.uix-lightbox__close',
      largeImgCloseEl = '.uix-lightbox__original__close',
      triggerEl = '.uix-lightbox__trigger',
      docURL = window.location.href,
      $content = $(innerEl).find('.uix-lightbox__html'),
      customWidth = 1000; //Match the width in the css file;

    //Detect URL change & Fire click event
    window.addEventListener('popstate', function (e) {
      var eleTarget = null;
      $('[data-lb-ajax]').each(function () {
        var prevURL = decodeURIComponent(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + encodeURIComponent('uix-lightbox-ajaxURL').replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
        if ($(this).attr('href') === prevURL) {
          eleTarget = this;
        }
      });
      var backURL = $(eleTarget).data('lb-ajax-doc-url');
      if ((0,esm_typeof/* default */.Z)(backURL) != ( true ? "undefined" : 0)) {
        lightboxClose(backURL);
      }
    });
    $(document).off('click.LIGHTBOX_TRIGGER').on('click.LIGHTBOX_TRIGGER', triggerEl, function () {
      var $this = $(this);
      var dataPhoto = $this.data('lb-src'),
        dataHtmlID = $this.data('lb-html'),
        dataFixed = $this.data('lb-fixed'),
        dataMaskClose = $this.data('lb-mask-close'),
        dataAjax = $this.data('lb-ajax'),
        htmlContent = '',
        imgSrcStr = '',
        imgSrcStrToW = '';
      if ((0,esm_typeof/* default */.Z)(dataFixed) === ( true ? "undefined" : 0)) {
        dataFixed = true;
      }
      if ((0,esm_typeof/* default */.Z)(dataMaskClose) === ( true ? "undefined" : 0)) {
        dataMaskClose = false;
      }
      if ((0,esm_typeof/* default */.Z)(dataAjax) === ( true ? "undefined" : 0)) {
        dataAjax = false;
      }
      if (dataAjax) {
        $(wrapperEl).addClass('js-uix-ajax');

        //Record current page URL for history
        if ((0,esm_typeof/* default */.Z)($this.data('lb-ajax-doc-url')) === ( true ? "undefined" : 0)) $this.data('lb-ajax-doc-url', docURL);
      }

      //Display loading
      $(loaderEl).removeClass('is-loaded');

      //Reset the wrapper position
      $(wrapperEl).css('margin-top', 0);
      if (!dataFixed) {
        $(wrapperEl).addClass('js-uix-no-fixed');
        $(closeEl).addClass('is-active');

        //Initialize the wrapper position
        $(wrapperEl).css('margin-top', $(window).scrollTop() + 'px');
      }

      //Reset current container type
      $(innerEl).removeClass('js-uix-custom js-uix-pure-image');

      // Locks the page
      if (!$(wrapperEl).hasClass('js-uix-no-fixed')) {
        $.scrollLock(true);

        //Add class for body
        //When scrollLock is used, scrollTop value will change
        $('body').addClass('scrollLock');
      }

      // Show the lightbox
      var showLightbox = function showLightbox() {
        $(closeEl).addClass('is-active');
        $(wrapperEl).show();
        $(maskEl).show();
        $(innerEl).show();
      };

      // hide the content container
      var hideLightboxContent = function hideLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'none'
          }
        });
      };

      // show the content container
      var showLightboxContent = function showLightboxContent() {
        TweenMax.set($content, {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };
      hideLightboxContent();

      ////////////////////////
      //////// PHOTOS ///////
      ////////////////////////  
      if ((0,esm_typeof/* default */.Z)(dataPhoto) != ( true ? "undefined" : 0) && dataPhoto != '') {
        //show the lightbox
        showLightbox();
        if (dataPhoto.indexOf('[') >= 0 && dataPhoto.indexOf(']') >= 0) {
          imgSrcStr = JSON.parse(dataPhoto.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
        } else {
          imgSrcStr = dataPhoto;
        }

        //Judging whether multiple image sets
        if (Object.prototype.toString.call(imgSrcStr) == '[object Array]') {
          var largePhotos = '',
            thumbs = '';
          imgSrcStrToW = imgSrcStr[0].large;

          //push the large photos
          largePhotos += '<div class="uix-lightbox__photo-container uix-lightbox__photo-sets-container"><a href="javascript:" class="uix-lightbox__photo-sets__prev"></a><a href="javascript:" class="uix-lightbox__photo-sets__next"></a><ul>';
          for (var i = 0; i < imgSrcStr.length; i++) {
            var tempID = 'lightbox-' + UixGUID.create();
            largePhotos += '<li>';
            largePhotos += '	<a class="uix-lightbox__original__link" data-target-id="' + tempID + '-sets-' + i + '" href="javascript:void(0);">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</a>';
            largePhotos += '	<div class="uix-lightbox__original__target" id="' + tempID + '-sets-' + i + '">';
            largePhotos += '	   <img src="' + imgSrcStr[i].large + '" alt="">';
            largePhotos += '	</div>';
            largePhotos += '</li>';
          }
          largePhotos += '</ul></div>';

          //push the thumbs
          thumbs += '<div class="uix-lightbox__thumb-container"><ul>';
          for (var k = 0; k < imgSrcStr.length; k++) {
            var active = k == 0 ? 'class="is-active"' : '';
            thumbs += '<li ' + active + '><img src="' + imgSrcStr[k].thumb + '" alt=""></li>';
          }
          thumbs += '</ul></div>';
          htmlContent = largePhotos + thumbs;
        } else {
          var _tempID = 'lightbox-' + UixGUID.create();

          //Only one image
          imgSrcStrToW = imgSrcStr;
          htmlContent += '<div class="uix-lightbox__photo-container">';
          htmlContent += '	<a class="uix-lightbox__original__link" data-target-id="' + _tempID + '" href="javascript:void(0);">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</a>';
          htmlContent += '	<div class="uix-lightbox__original__target" id="' + _tempID + '">';
          htmlContent += '	   <img src="' + imgSrcStr + '" alt="">';
          htmlContent += '	</div>';
          htmlContent += '</div>';
        }
        $content.html(htmlContent).promise().done(function () {
          //Set current container type
          $(innerEl).addClass('js-uix-pure-image');

          //Set container width
          var img = new Image();
          img.src = imgSrcStrToW;
          img.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded');

            // show the content container
            showLightboxContent();
            var sw = window.innerWidth - 30,
              ow = this.width,
              oh = this.height,
              ratioH = oh / ow,
              ratioW = ow / oh,
              w = ow > customWidth ? customWidth : ow,
              h;
            if (w > sw) w = sw;
            h = w * ratioH;

            //Prevent height overflow
            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $(innerEl).css({
              'width': w + 'px'
            });

            //Don't write variables outside
            var $lbSetsContainer = $('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container');
            $lbSetsContainer.css({
              'height': h + 'px'
            });

            //Set a new height & width of inside images
            $content.find('.uix-lightbox__photo-sets-container ul > li img').css({
              'height': h + 'px'
            });
            if (!$('body').hasClass('rtl')) {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-left': '-3rem'
              });
            } else {
              $content.find('.uix-lightbox__photo-sets-container').css({
                'width': 'calc(' + h * ratioW + 'px + 6rem)',
                'margin-right': '-3rem'
              });
            }

            //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside
            var $lbTarImg = $('.uix-lightbox__photo-container > .uix-lightbox__original__target');
            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }
          };
          $(innerEl).find('> .uix-lightbox__html').removeClass('js-uix-no-img');
        });
      }

      ////////////////////////
      //////// HTML /////////
      ////////////////////////  
      if ((0,esm_typeof/* default */.Z)(dataHtmlID) != ( true ? "undefined" : 0) && dataHtmlID != '') {
        dataHtmlID = dataHtmlID.replace('#', '');
        var $htmlAjaxContainer = $('#' + dataHtmlID).find('.uix-lightbox__content > div');

        //show the lightbox
        showLightbox();

        // Content pushing completed
        var htmlContentLoaded = function htmlContentLoaded() {
          //remove loading
          $(loaderEl).addClass('is-loaded');

          //Set current container type
          $(innerEl).addClass('js-uix-custom');

          //Set container width
          if ($(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').length > 0) {
            if (window.innerWidth <= 768) {
              $(innerEl).css('width', window.innerWidth - 10 + 'px');
            } else {
              $(innerEl).css('width', $(innerEl).find('> .uix-lightbox__html .uix-lightbox__content').width() + 'px');
            }
            $(innerEl).find('> .uix-lightbox__html').addClass('js-uix-no-img');
          }
        };
        if ($(wrapperEl).hasClass('js-uix-ajax')) {
          //Add content to the dynamic AJAX container
          var ajaxURL = $this.attr('href'),
            ajaxConfig = dataAjax;

          // Modify the URL without reloading the page
          if (history.pushState) {
            history.pushState(null, null, ajaxURL);
          } else {
            location.hash = ajaxURL;
          }
          document.cookie = 'uix-lightbox-ajaxURL=' + ajaxURL;

          // Add a request or response interceptor
          var axiosInterceptor = axios.interceptors.request.use(function (config) {
            // Do something before request is sent

            //
            return config;
          }, function (error) {
            return Promise.reject(error);
          });

          // To send data in the application/x-www-form-urlencoded format instead
          var formData = new FormData();
          var defaultPostData = {
            action: 'load_singlepages_ajax_content'
          };
          for (var _k in defaultPostData) {
            formData.append(_k, defaultPostData[_k]);
          }

          // Create a request event
          axios({
            timeout: 15000,
            method: ajaxConfig.method,
            url: ajaxURL,
            data: formData,
            responseType: 'text'
          }).then(function (response) {
            var htmlCode = response.data;
            $htmlAjaxContainer.html($(htmlCode).find(dataAjax.target).html()).promise().done(function () {
              $content.html($('#' + dataHtmlID).html()).promise().done(function () {
                // Apply some asynchronism scripts
                $(document).UixApplyAsyncScripts({
                  lightBox: false,
                  ajaxPostList: false
                });

                // show the content container
                showLightboxContent();

                // Content pushing completed
                htmlContentLoaded();
              });
            });
          })["catch"](function (error) {
            if (error.response) {
              // The request was made and the server responded with a status code
              // that falls out of the range of 2xx
              var status = error.response.status;
              console.log(status);
              if (status == 404 || status == 405) window.location.href = ajaxURL;
            } else if (error.request) {
              // The request was made but no response was received
              // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
              // http.ClientRequest in node.js
              console.log(error.request);

              //
              window.location.href = ajaxURL;
            } else {
              // If there was a problem, we need to
              // dispatch the error condition
              console.log(error.message);
            }
          });

          // Remove an interceptor later
          axios.interceptors.request.eject(axiosInterceptor);
        } else {
          // show the content container
          showLightboxContent();
          $content.html($('#' + dataHtmlID).html()).promise().done(function () {
            // Content pushing completed
            htmlContentLoaded();
          });
        } //endif $( wrapperEl ).hasClass( 'js-uix-ajax' )
      }

      return false;
    }); /* end click event for triggerEl */

    ////////////////////////
    // Close the lightbox //
    ////////////////////////   	
    $(document).off('click.LIGHTBOX_CLOSE').on('click.LIGHTBOX_CLOSE', closeEl + ',' + maskEl, function () {
      lightboxClose(docURL);
    });
    $(document).off('click.LIGHTBOX_THUMB').on('click.LIGHTBOX_THUMB', '.uix-lightbox__thumb-container li', function () {
      lightboxThumbSwitch($(this).index(), $(this));
    });
    $(document).off('click.LIGHTBOX_PHOTO_SETS').on('click.LIGHTBOX_PHOTO_SETS', '.uix-lightbox__photo-sets-container > a', function () {
      var $largePhoto = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
        $thumb = $(this).closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li'),
        total = $thumb.length,
        curIndex = $thumb.filter('.is-active').index();
      var prevIndex = curIndex - 1,
        nextIndex = curIndex + 1;
      if (prevIndex < 0) prevIndex = total - 1;
      if (nextIndex > total - 1) nextIndex = 0;
      if ($(this).hasClass('uix-lightbox__photo-sets__prev')) {
        lightboxThumbSwitch(prevIndex, $thumb.eq(prevIndex));
      }
      if ($(this).hasClass('uix-lightbox__photo-sets__next')) {
        lightboxThumbSwitch(nextIndex, $thumb.eq(nextIndex));
      }
    });

    ////////////////////////////////
    // Close/Open enlarge image //
    ///////////////////////////////	
    if (window.innerWidth > 768) {
      $(document).off('click.LIGHTBOX_ORGINAL_LINK').on('click.LIGHTBOX_ORGINAL_LINK', '.uix-lightbox__original__link', function (e) {
        $('.uix-lightbox__original__target#' + $(this).data('target-id')).addClass('is-active');
        if ($(this).closest('.uix-lightbox__container.js-uix-no-fixed').length > 0) {
          $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').addClass('no-fixed-imgEnlarged');
        }

        //---
        $('html').css('overflow-y', 'hidden');
        $(largeImgCloseEl).addClass('is-active');
      });
      $(document).off('click.LIGHTBOX_LARGE_IMG_CLOSE').on('click.LIGHTBOX_LARGE_IMG_CLOSE', largeImgCloseEl, function (e) {
        $('.uix-lightbox__original__target').removeClass('is-active');
        $('.uix-lightbox__container.js-uix-no-fixed, .uix-lightbox__original__target--imgfull').removeClass('no-fixed-imgEnlarged');

        //---
        $(this).removeClass('is-active');
        $('html').css('overflow-y', 'auto');
      });
    }

    /*
     * Click thumbnail to show large photo
     *
     * @param  {Number} index           - The target index of large photo.
     * @param  {Element} obj             - Target large image <li>.
     * @return {Void}
     */
    function lightboxThumbSwitch(index, obj) {
      var $largePhoto = obj.closest('.uix-lightbox__html').find('.uix-lightbox__photo-container.uix-lightbox__photo-sets-container'),
        $thumb = obj.closest('.uix-lightbox__html').find('.uix-lightbox__thumb-container li');

      // show the content container
      var showLightboxContent = function showLightboxContent() {
        TweenMax.set(obj.closest('.uix-lightbox__html'), {
          css: {
            'display': 'block'
          },
          onComplete: function onComplete() {
            TweenMax.to(this.target, 0.5, {
              alpha: 1
            });
          }
        });
      };
      $thumb.removeClass('is-active');
      obj.addClass('is-active');

      //all items
      TweenMax.set($largePhoto.find('li'), {
        css: {
          'display': 'none',
          'opacity': 0
        },
        onComplete: function onComplete() {
          $(this.target).removeClass('is-active');
        }
      });

      //current item
      TweenMax.set($largePhoto.find('li').eq(index), {
        css: {
          'display': 'block',
          'opacity': 0
        },
        onComplete: function onComplete() {
          var _cur = this.target;
          $(_cur).addClass('is-active');
          //
          //Reset the container height
          var imgClick = new Image();
          imgClick.src = $largePhoto.find('li').eq(index).find('img').attr('src');
          imgClick.onload = function () {
            //remove loading
            $(loaderEl).addClass('is-loaded');

            // show the content container
            showLightboxContent();
            var sw = window.innerWidth - 30,
              ow = this.width,
              oh = this.height,
              ratioH = oh / ow,
              w = ow > customWidth ? customWidth : ow,
              h;
            if (w > sw) w = sw;
            h = w * ratioH;

            //Prevent height overflow
            if (h > window.innerHeight) h = window.innerHeight * 0.95;
            $largePhoto.css({
              'height': h + 'px'
            }).find('img').css({
              'height': h + 'px'
            });

            //If the image is larger than the current window, it will display at the top.
            //Don't write variables outside
            var $lbTarImg = $largePhoto.find('li').eq(index).find('.uix-lightbox__original__target');
            if (oh > window.innerHeight) {
              $lbTarImg.addClass('uix-lightbox__original__target--imgfull');
            } else {
              $lbTarImg.removeClass('uix-lightbox__original__target--imgfull');
            }
            TweenMax.to(_cur, 0.5, {
              alpha: 1
            });
          }; //imgClick.onload       
        }
      });
    }

    /*
     * Close the lightbox
     *
     * @param  {String} url             - The current page URL for history.
     * @return {Void}
     */
    function lightboxClose(url) {
      //Detect URL change when AJAX calls are done
      if ($(wrapperEl).hasClass('js-uix-ajax')) {
        history.pushState(null, null, url);
      }

      //Remove all dynamic classes
      $(wrapperEl).removeClass('js-uix-no-fixed js-uix-ajax');
      $(closeEl).removeClass('is-active');

      //Add a scroll bar.
      $('html').css('overflow-y', 'auto');

      //Reset current container type
      $(innerEl).removeClass('js-uix-custom js-uix-pure-image');

      //close windows
      $(wrapperEl).hide();
      $(maskEl).hide();

      // Unlocks the page
      $.scrollLock(false);

      //Remove class for body
      //When scrollLock is used, scrollTop value will change
      $('body').removeClass('scrollLock');
    }
  };
  module.components.pageLoaded.push(module.LIGHTBOX.pageLoaded);
  return /*#__PURE__*/_createClass(function LIGHTBOX() {
    _classCallCheck(this, LIGHTBOX);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/list-bulleted/js/index.js


/* 
 *************************************
 * <!-- Bulleted List -->
 *************************************
 */


var BULLETED_LIST = function (module, $, window, document) {
  if (window.BULLETED_LIST === null) return false;
  module.BULLETED_LIST = module.BULLETED_LIST || {};
  module.BULLETED_LIST.version = '0.0.1';
  module.BULLETED_LIST.documentReady = function ($) {
    // Icon bulleted lists
    $('[data-list-bullet]').each(function () {
      var bullet = $(this).attr('data-list-bullet');
      $(this).find('li').prepend('<i class="' + bullet + '" aria-hidden="true"></i>');
    });
  };
  module.components.documentReady.push(module.BULLETED_LIST.documentReady);
  return /*#__PURE__*/_createClass(function BULLETED_LIST() {
    _classCallCheck(this, BULLETED_LIST);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/list-posts/js/index.js



/* 
 *************************************
 * <!-- Posts List With Ajax -->
 *************************************
 */





var POST_LIST_AJAX = function (module, $, window, document) {
  if (window.POST_LIST_AJAX === null) return false;
  module.POST_LIST_AJAX = module.POST_LIST_AJAX || {};
  module.POST_LIST_AJAX.version = '0.1.9';
  module.POST_LIST_AJAX.documentReady = function ($) {
    $('[data-ajax-list-json]').each(function () {
      var $this = $(this);
      var wrapperID = 'refresh-all-waypoint-' + UixGUID.create();
      var curPage = $this.data('ajax-list-page-now'),
        initCurPage = curPage,
        perShow = $this.data('ajax-list-page-per'),
        totalPage = $this.data('ajax-list-page-total'),
        method = $this.data('ajax-list-method'),
        trigger = $this.data('ajax-list-trigger'),
        infinitescroll = $this.data('ajax-list-infinitescroll'),
        jsonFile = $this.data('ajax-list-json'),
        render = $this.data('ajax-list-render'),
        template7ID = $this.data('ajax-list-temp-id'),
        pushContainer = $this.data('ajax-list-push-container-class'),
        triggerActive = $this.data('ajax-list-trigger-active-class'),
        pageParmStr = $this.data('ajax-list-page-parm-str'),
        noneInfo = $this.data('ajax-list-none-info');
      $this.attr('id', wrapperID);
      if ((0,esm_typeof/* default */.Z)(pageParmStr) === ( true ? "undefined" : 0)) {
        pageParmStr = {
          'totalPage': 'total',
          'currentPage': 'page',
          'displayPerPage': 'per'
        };
      }
      if ((0,esm_typeof/* default */.Z)(curPage) === ( true ? "undefined" : 0)) {
        curPage = 1;
      }
      if ((0,esm_typeof/* default */.Z)(perShow) === ( true ? "undefined" : 0)) {
        perShow = 8;
      }
      if ((0,esm_typeof/* default */.Z)(totalPage) === ( true ? "undefined" : 0)) {
        totalPage = 3;
      }
      if ((0,esm_typeof/* default */.Z)(totalPage) != ( true ? "undefined" : 0) && totalPage == '-1') {
        totalPage = 9999;
      }
      if ((0,esm_typeof/* default */.Z)(trigger) === ( true ? "undefined" : 0)) {
        trigger = '.uix-load-more';
      }
      if ((0,esm_typeof/* default */.Z)(infinitescroll) === ( true ? "undefined" : 0)) {
        infinitescroll = false;
      }
      if ((0,esm_typeof/* default */.Z)(render) === ( true ? "undefined" : 0)) {
        render = 'before';
      }
      if ((0,esm_typeof/* default */.Z)(jsonFile) === ( true ? "undefined" : 0)) {
        jsonFile = '';
      }
      if ((0,esm_typeof/* default */.Z)(template7ID) === ( true ? "undefined" : 0)) {
        template7ID = '';
      }
      if ((0,esm_typeof/* default */.Z)(triggerActive) === ( true ? "undefined" : 0)) {
        triggerActive = 'is-waiting';
      }
      if ((0,esm_typeof/* default */.Z)(method) === ( true ? "undefined" : 0)) {
        method = 'POST';
      }
      if ((0,esm_typeof/* default */.Z)(noneInfo) === ( true ? "undefined" : 0)) {
        noneInfo = '{"none":"","error":""}';
      }
      triggerActive = triggerActive.replace('.', '');
      if ((0,esm_typeof/* default */.Z)(pushContainer) === ( true ? "undefined" : 0)) {
        pushContainer = '.uix-ajax-items__container';
        if ($this.find(pushContainer).length == 0) {
          $('#' + template7ID).after('<div class="uix-ajax-items__container"></div>');
        }
      }

      //Get all attributes of an element and push the new attributes like "data-*"
      var curAttrs = $this.attr(),
        defaultPostData = '',
        customPostData = '';
      $.each(curAttrs, function (i, val) {
        if (i.indexOf('data-ajax-list-field-') >= 0) {
          customPostData += '"' + i.replace('data-ajax-list-field-', '') + '": ' + '"' + val + '", ';
        }
      });
      customPostData = customPostData.replace(/,\s*$/, '');

      //Parse the JSON data
      if (jsonFile != '' && template7ID != '') {
        //Default output of the first page
        if (curPage == 2) {
          //Perform dynamic loading
          if (customPostData != '') {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1, ' + customPostData + ' }');
          } else {
            defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": 1 }');
          }
          ajaxLoadInit($this, defaultPostData, $(trigger), curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
        }
        if (infinitescroll) {
          var scrollUpdate = function scrollUpdate() {
            var spyTop = parseFloat($button[0].getBoundingClientRect().top + $button.outerHeight(true));
            if (spyTop < window.innerHeight && !$button.hasClass(triggerActive)) {
              // Active this button
              $button.addClass(triggerActive);
              var _curPage = $button.attr('data-cur-page');

              //Add next page number to the button
              _curPage = parseFloat(_curPage) + 1;
              $button.attr('data-cur-page', _curPage);

              //Avoid touching the same button multiple times
              if (_curPage == totalPage + 1) return false;

              //Perform dynamic loading
              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + _curPage + ' }');
              }
              ajaxLoadInit($this, defaultPostData, $button, _curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
            }
          }; // Add function to the element that should be used as the scrollable area.
          /* 
           ---------------------------
           Infinite scroll
           ---------------------------
           */
          var $button = $(trigger),
            btnTop = $button.offset().top;

          //Add default page number to the button
          $button.attr('data-cur-page', initCurPage);

          //Hide the next button 
          if (totalPage == 1) {
            $button.addClass('is-hide');
          }
          var throttleFunc = UixThrottle(scrollUpdate, 5);
          window.removeEventListener('scroll', throttleFunc);
          window.removeEventListener('touchmove', throttleFunc);
          window.addEventListener('scroll', throttleFunc);
          window.addEventListener('touchmove', throttleFunc);
          throttleFunc();
        } else {
          /* 
           ---------------------------
           Ajax with JSON data
           ---------------------------
           */

          var triggerStr = '';
          if (trigger.indexOf('[') >= 0 && trigger.indexOf(']') >= 0) {
            triggerStr = JSON.parse(trigger.replace(/([a-zA-Z0-9]+?):/g, '"$1":').replace(/'/g, '"'));
          } else {
            triggerStr = trigger;
          }

          //Whether there are two flip buttons "Previous" and "Next"
          if (Object.prototype.toString.call(triggerStr) == '[object Array]') {
            var prevTrigger = triggerStr[0].prev,
              nextTrigger = triggerStr[1].next;

            //Add default page number to the button
            $(nextTrigger).parent().attr('data-cur-page', initCurPage);

            //--------------- Next Button ------------------
            //Hide the next button 
            if (totalPage == 1) {
              $(nextTrigger).addClass('is-hide');
            }

            //Avoid using $( document ) to cause an asynchronous load without counting from 1
            $(nextTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page');

              //Add next page number to the button
              curPage = parseFloat(curPage) + 1;
              $button.parent().attr('data-cur-page', curPage);

              //Init button status
              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(prevTrigger).removeClass('is-hide');

              // Active this button
              $button.addClass(triggerActive);

              //Perform dynamic loading
              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }
              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });

            //----------------- Previous Button ----------------
            //Hide the prev button 
            $(prevTrigger).addClass('is-hide');

            //Avoid using $( document ) to cause an asynchronous load without counting from 1
            $(prevTrigger).off('click').on('click', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.parent().attr('data-cur-page');

              //Add next page number to the button
              curPage = parseFloat(curPage) - 1;
              $button.parent().attr('data-cur-page', curPage);

              //Init button status
              $(prevTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass(triggerActive);
              $(nextTrigger).removeClass('is-hide');

              // Active this button
              $button.addClass(triggerActive);

              //Perform dynamic loading
              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }
              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          } else {
            //----------------- More Button ----------------
            //Add default page number to the button
            $(trigger).attr('data-cur-page', initCurPage);

            //Hide the next button 
            if (totalPage == 1) {
              $(trigger).addClass('is-hide');
            }

            //Avoid using $( document ) to cause an asynchronous load without counting from 1
            $(trigger).off('click.POST_LIST_AJAX').on('click.POST_LIST_AJAX', function (e) {
              e.preventDefault();
              var $button = $(this);
              var curPage = $button.attr('data-cur-page');

              //Add next page number to the button
              curPage = parseFloat(curPage) + 1;
              $button.attr('data-cur-page', curPage);

              // Active this button
              $button.addClass(triggerActive);

              //Perform dynamic loading
              if (customPostData != '') {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ', ' + customPostData + ' }');
              } else {
                defaultPostData = JSON.parse('{ "' + pageParmStr.totalPage + '": ' + totalPage + ', "' + pageParmStr.displayPerPage + '": ' + perShow + ', "' + pageParmStr.currentPage + '": ' + curPage + ' }');
              }
              ajaxLoadInit($this, defaultPostData, $button, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo);
              return false;
            });
          }
        } //end if
      }
    });

    /*
     * Ajax with JSON data
     *
     * @param  {Element} ajaxWrapper     - The outermost container of list.
     * @param  {Object} defaultPostData - Data to be sent to the server which is custom JSON fields.
     * @param  {String} trigger         - Trigger ajax loaded button object.
     * @param  {Number} curPage         - The current page to load.
     * @param  {Number} perShow         - The amount to load each time.
     * @param  {Number} totalPage       - The total page to load.
     * @param  {String} template7ID     - HTML template ID
     * @param  {String} jsonFile        - JSON file path to docking data
     * @param  {String} triggerActive   - The class name of trigger button actived.
     * @param  {String} pushContainer   - This container is used to display the loaded dynamic data.
     * @param  {String} method          - The type of request to make, which can be either "POST" or "GET".
     * @param  {String} render          - Rendering mode of display information. ==> before | html | append
     * @param  {String} noneInfo        - Returns information of ajax asynchronous callback when the content is empty.
     * @return {Void}
     */

    function ajaxLoadInit(ajaxWrapper, defaultPostData, trigger, curPage, totalPage, perShow, template7ID, jsonFile, triggerActive, pushContainer, method, render, noneInfo) {
      var $divRoot = ajaxWrapper;
      var template = document.getElementById(template7ID).innerHTML;

      // Register partial
      // Recursive Partials
      // We can even use partials to make recursive templates, like nested comments:
      // The root node of JSON, which can be `items` or `comments` by default
      /*
      compiledTemplate({
      	comments: [
      		{
      			author: 'John Doe',
      			text: 'Lorem ipsum dolor',
      			comments: [
      				{
      					author: 'Mike Doe',
      					text: 'Aliquam erat volutpat'
      				},
      				{
      					author: 'Kate Doe',
      					text: 'Donec eget fringilla turpis'
      				}
      			]
      		},
      		{
      			author: 'Jane Doe',
      			text: 'Donec sodales euismod augue'
      		}
      	]
      });
      */
      if ($divRoot.hasClass('js-ajax-comments')) {
        var recursivePartialsTemplate_Comments = template;
        Template7.registerPartial('comments', recursivePartialsTemplate_Comments);

        //update new template code
        template = '{{> "comments"}}';
      }

      //
      var compiledTemplate = Template7.compile(template),
        $button = $(trigger);

      //hide the button and callback the information
      var returnEmptyInfo = function returnEmptyInfo() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.none);
      };
      var returnDataError = function returnDataError() {
        $button.addClass('is-hide');
        $divRoot.after(noneInfo.error);
      };

      // Add a request or response interceptor
      var axiosInterceptor = axios.interceptors.request.use(function (config) {
        // Do something before request is sent

        //
        return config;
      }, function (error) {
        return Promise.reject(error);
      });

      // To send data in the application/x-www-form-urlencoded format instead
      var formData = new FormData();
      for (var k in defaultPostData) {
        formData.append(k, defaultPostData[k]);
      }

      // Create a request event
      axios({
        timeout: 15000,
        method: method,
        url: jsonFile,
        data: formData,
        responseType: 'json'
      }).then(function (response) {
        var jsonData = response.data;

        //If the data is empty
        // The root node of JSON, which can be `items` or `comments` by default
        if (jsonData && (jsonData == null || Object.prototype.toString.call(jsonData.items) == '[object String]') || jsonData && (jsonData == null || Object.prototype.toString.call(jsonData.comments) == '[object String]')) {
          returnEmptyInfo();
        }

        //Check if a key exists inside a json object
        // The root node of JSON, which can be `items` or `comments` by default
        if (jsonData && jsonData.hasOwnProperty('items') && Object.prototype.toString.call(jsonData.items) == '[object Array]' || jsonData && jsonData.hasOwnProperty('comments') && Object.prototype.toString.call(jsonData.comments) == '[object Array]') {
          //Data overflow may occur when the total number of pages is not posted
          try {
            var html = compiledTemplate(jsonData),
              curHtml = $divRoot.find(pushContainer).html();
            var result = null,
              htmlEl = null;

            //--------- Do or not append to the original content
            if (render == 'before') {
              result = curHtml + html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).before(htmlEl);
            }
            if (render == 'html') {
              result = html;
              htmlEl = $(result);
              $divRoot.find(pushContainer).html(htmlEl);
            }
            if (render == 'append') {
              $divRoot.find(pushContainer).append(html);
            }

            //--------- Apply some asynchronism scripts
            $(document).UixApplyAsyncScripts({
              ajaxPostList: false
            });

            //--------- Remove this button
            $button.removeClass(triggerActive);

            //--------- Hidden button when the page total number is set and does not equal -1 or 9999
            if (curPage == totalPage && totalPage != 9999 && totalPage != -1 && totalPage != 1) {
              returnEmptyInfo();
            }
          } catch (err) {
            console.log(err.message);
            returnDataError();
          }
        } else {
          //if not array
          returnEmptyInfo();
        }
      })["catch"](function (error) {
        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx
          var status = error.response.status;
          console.log(status);
        } else if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          console.log(error.request);

          //
          returnEmptyInfo();
        } else {
          // If there was a problem, we need to
          // dispatch the error condition
          console.log(error.message);
        }
      });

      // Remove an interceptor later
      axios.interceptors.request.eject(axiosInterceptor);
    }
  };
  module.components.documentReady.push(module.POST_LIST_AJAX.documentReady);
  return /*#__PURE__*/_createClass(function POST_LIST_AJAX() {
    _classCallCheck(this, POST_LIST_AJAX);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/fullwidth-column-to-edge/js/index.js



/* 
 *************************************
 * <!-- Full Width Column to Edge -->
 *************************************
 */



var FULL_WIDTH_COLUMN_TO_EDGE = function (module, $, window, document) {
  if (window.FULL_WIDTH_COLUMN_TO_EDGE === null) return false;
  module.FULL_WIDTH_COLUMN_TO_EDGE = module.FULL_WIDTH_COLUMN_TO_EDGE || {};
  module.FULL_WIDTH_COLUMN_TO_EDGE.version = '0.0.2';
  module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded = function () {
    $('.js-uix-fullwidth-column-to-edge--extend-right').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');
      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        fullwidthToDir($(this), 'right', window.innerWidth);

        //Prevents front-end javascripts that are activated in the background to repeat loading.
        $el.data('activated', 1);
      } //endif actived
    });

    $('.js-uix-fullwidth-column-to-edge--extend-left').each(function () {
      var $el = $(this);
      var actived = $el.data('activated');
      if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
        fullwidthToDir($(this), 'left', window.innerWidth);

        //Prevents front-end javascripts that are activated in the background to repeat loading.
        $el.data('activated', 1);
      } //endif actived
    });

    function fullwidthToDir(obj, dir, w) {
      var dividerPosition = obj.offset();
      var dividerWidth = $(window).width() - dividerPosition.left;
      var bsGridGutter = 15;
      if (w > 768) {
        obj.css('width', dividerWidth + bsGridGutter);
        if (dir == 'left') {
          var _dis = -(dividerPosition.left + bsGridGutter * 2);
          obj.css('margin-left', _dis + 'px');
        }
      } else {
        obj.css('width', 'inherit');
        if (dir == 'left') {
          obj.css('margin-left', -bsGridGutter + 'px');
        }
      }
    }
  };
  module.components.pageLoaded.push(module.FULL_WIDTH_COLUMN_TO_EDGE.pageLoaded);
  return /*#__PURE__*/_createClass(function FULL_WIDTH_COLUMN_TO_EDGE() {
    _classCallCheck(this, FULL_WIDTH_COLUMN_TO_EDGE);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/login-templates/js/index.js


/* 
 *************************************
 * <!-- Login Templates -->
 *************************************
 */


var LOGIN_UI = function (module, $, window, document) {
  if (window.LOGIN_UI === null) return false;
  module.LOGIN_UI = module.LOGIN_UI || {};
  module.LOGIN_UI.version = '0.0.2';
  module.LOGIN_UI.documentReady = function ($) {
    var $loginToggle = $('.uix-special-login__toggle'),
      $loginForms = $('.uix-special-login__form');
    $loginToggle.data('switched', true).off('click').on('click', function (e) {
      e.preventDefault();
      var $form1 = $loginForms.eq(0),
        $form2 = $loginForms.eq(1);
      if ($(this).data('switched')) {
        $(this).data('switched', false);
        TweenMax.set($form2, {
          height: 'auto'
        });
        TweenMax.from($form2, 0.5, {
          height: 0
        });
        TweenMax.to($form1, 0.5, {
          height: 0
        });

        // Switches the Icon
        $(this).find('> span i').eq(0).hide();
        $(this).find('> span i').eq(1).show();
      } else {
        $(this).data('switched', true);
        TweenMax.set($form1, {
          height: 'auto'
        });
        TweenMax.from($form1, 0.5, {
          height: 0
        });
        TweenMax.to($form2, 0.5, {
          height: 0
        });

        // Switches the Icon
        $(this).find('> span i').eq(1).hide();
        $(this).find('> span i').eq(0).show();
      }
    });
  };
  module.components.documentReady.push(module.LOGIN_UI.documentReady);
  return /*#__PURE__*/_createClass(function LOGIN_UI() {
    _classCallCheck(this, LOGIN_UI);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/fire-modal-dialog.js

/*
 * Fire Modal Dialog
 *
 * @param  {String} id                   - Modal's unique identifier.
 * @param  {Number|Boolean} height       - Custom modal height whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number|Boolean} width        - Custom modal width whick need a unit string. 
										   This attribute "data-modal-height" may not exist. Such as: 200px
 * @param  {Number} speed                - Delay Time when Full Screen Effect is fired.   
 * @param  {?Element|Boolean} btn          - Link or button that fires an event.
 * @param  {Boolean} lightbox            - Whether to enable the lightbox effect.
 * @param  {Number|Boolean} autoClose    - Specify auto-close time. This function is not enabled when this value is false.
 * @param  {Boolean} closeOnlyBtn        - Disable mask to close the window.
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixFireModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      id: 'demo',
      height: false,
      width: false,
      speed: 500,
      btn: false,
      lightbox: true,
      autoClose: false,
      closeOnlyBtn: false
    }, options);
    this.each(function () {
      if (settings.id == '') return false;

      //Prevent automatic close from affecting new fire effects
      clearTimeout(window.setCloseModalDialog);

      //Add modal mask to stage
      if ($('.uix-modal-mask').length == 0) {
        $('body').prepend('<div class="uix-modal-mask"></div>');
      }
      $.when($('.uix-modal-mask').length > 0).then(function () {
        if (settings.closeOnlyBtn) {
          $('.uix-modal-mask').addClass('js-uix-disabled');
        } else {
          $('.uix-modal-mask').removeClass('js-uix-disabled');
        }
        var dataID = settings.id,
          dataH = settings.height,
          dataW = settings.width,
          linkBtn = settings.btn,
          closeTime = settings.autoClose,
          $obj = $('.uix-modal-box#' + dataID);

        // Initializate modal
        if (linkBtn) {
          linkBtn.attr('href', 'javascript:void(0)');
          $obj.find('.uix-modal-box__content').addClass('js-uix-no-fullscreen');
          if (linkBtn.data('video-win')) {
            $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
          }
        }
        if ($obj.length > 0) {
          // Locks the page
          $.scrollLock(true);

          //Add class for body
          //When scrollLock is used, scrollTop value will change
          $('body').addClass('scrollLock');
          if ((0,esm_typeof/* default */.Z)(dataH) != ( true ? "undefined" : 0) && dataH != '' && dataH) {
            $obj.css({
              'height': dataH
            });
          }
          if ((0,esm_typeof/* default */.Z)(dataW) != ( true ? "undefined" : 0) && dataW != '' && dataW) {
            $obj.css({
              'width': dataW
            });
          }

          //Enable the lightbox effect.
          if (settings.lightbox) {
            TweenMax.set('.uix-modal-mask', {
              css: {
                opacity: 0,
                display: 'none'
              },
              onComplete: function onComplete() {
                TweenMax.to(this.target, 0.3, {
                  css: {
                    opacity: 1,
                    display: 'block'
                  }
                });
              }
            });
          }
          $obj.addClass('is-active');

          //auto close
          if (closeTime && !isNaN(closeTime)) {
            window.setCloseModalDialog = setTimeout(function () {
              $(document).closeModalDialog();
            }, closeTime);
          }
        }
        if ($obj.hasClass('is-fullscreen')) {
          setTimeout(function () {
            if (!$obj.hasClass('is-video')) {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'scroll');
            } else {
              $obj.find('.uix-modal-box__content > .uix-modal-box__body').css('overflow-y', 'hidden');
            }
          }, settings.speed);
        }
      });
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/fn/close-modal-dialog.js
/*
 * Close Modal Dialog
 *
 * @return {Void}
 */


(function ($) {
  'use strict';

  $.fn.UixCloseModalDialog = function (options) {
    // This is the easiest way to have default options.
    var settings = $.extend({
      target: '.uix-modal-box'
    }, options);
    this.each(function () {
      //Enable mask to close the window.
      $('.uix-modal-mask').removeClass('js-uix-disabled');
      $(settings.target).removeClass('is-active');
      TweenMax.to('.uix-modal-mask', 0.3, {
        css: {
          opacity: 0,
          display: 'none'
        }
      });
      $(settings.target).find('.uix-modal-box__content').removeClass('js-uix-no-fullscreen');

      // Unlocks the page
      $.scrollLock(false);

      //Remove class for body
      //When scrollLock is used, scrollTop value will change
      $('body').removeClass('scrollLock');

      //Prevent automatic close from affecting new fire effects
      clearTimeout(window.setCloseModalDialog);
    });
  };
})(jQuery);
;// CONCATENATED MODULE: ./src/components/modal-dialog/js/index.js



/* 
 *************************************
 * <!-- Modal Dialog -->
 *************************************
 */




var MODAL_DIALOG = function (module, $, window, document) {
  if (window.MODAL_DIALOG === null) return false;
  module.MODAL_DIALOG = module.MODAL_DIALOG || {};
  module.MODAL_DIALOG.version = '0.1.9';
  module.MODAL_DIALOG.documentReady = function ($) {
    //Delay Time when Full Screen Effect is fired.
    var modalSpeed = UixCssProperty.getTransitionDuration($('.uix-modal-box:first')[0]);

    // To display the template tag content.
    $('template').each(function () {
      var _content = $(this).html(function (index, html) {
          return html.replace(/[\r\n]/g, '');
        }).html(),
        _id = $(this).attr('id');

      //If it is dialog, clone the contents of the <template> into the body
      if ((0,esm_typeof/* default */.Z)(_id) !== ( true ? "undefined" : 0) && !$('body').hasClass(_id) && $('<div>' + _content + '</div>').find('[role="dialog"]').length > 0) {
        //reset id
        $(this).removeAttr('id');
        $('body').addClass(_id);

        //append content to body
        $(_content.replace(/role=[\'\"]dialog[\'\"]/, 'role="dialog" id="' + _id + '"')).appendTo('body');
      }
    });

    /*
      * Unbind that one in a safe way that won't accidentally unbind other click handlers.
      * In order to trigger other custom Modal Dialog events.
    	
    	$( '#element' ).off( 'click.MODAL_DIALOG' );
    	$( '#element' ).off( 'click.MODAL_DIALOG_CLOSE' );
    	
    */

    //Add modal mask to stage
    if ($('.uix-modal-mask').length == 0) {
      $('body').prepend('<div class="uix-modal-mask"></div>');
    }
    $(document).off('click.MODAL_DIALOG').on('click.MODAL_DIALOG', '[data-modal-id]', function () {
      var dataH = $(this).data('modal-height'),
        dataW = $(this).data('modal-width'),
        lightbox = $(this).data('modal-lightbox'),
        closeTime = $(this).data('modal-close-time'),
        closeOnlyBtn = $(this).data('modal-close-onlybtn');
      if ((0,esm_typeof/* default */.Z)(dataH) === ( true ? "undefined" : 0)) {
        dataH = false;
      }
      if ((0,esm_typeof/* default */.Z)(dataW) === ( true ? "undefined" : 0)) {
        dataW = false;
      }
      if ((0,esm_typeof/* default */.Z)(lightbox) === ( true ? "undefined" : 0)) {
        lightbox = true;
      }
      if ((0,esm_typeof/* default */.Z)(closeTime) === ( true ? "undefined" : 0)) {
        closeTime = false;
      }
      if ((0,esm_typeof/* default */.Z)(closeOnlyBtn) === ( true ? "undefined" : 0)) {
        closeOnlyBtn = false;
      }
      $(document).UixFireModalDialog({
        id: $(this).data('modal-id'),
        height: dataH,
        width: dataW,
        speed: modalSpeed,
        btn: $(this),
        lightbox: lightbox,
        autoClose: closeTime,
        closeOnlyBtn: closeOnlyBtn
      });
      return false;
    });
    $(document).off('click.MODAL_DIALOG_CLOSE').on('click.MODAL_DIALOG_CLOSE', '.uix-modal-box [data-modal-close-trigger], .uix-modal-mask:not(.js-uix-disabled)', function () {
      //btn
      if ($(this).hasClass('uix-modal-box__close')) {
        $(this).parent().removeClass('is-active');
      }
      $(document).UixCloseModalDialog();
      return false;
    });
  };
  module.components.documentReady.push(module.MODAL_DIALOG.documentReady);
  return /*#__PURE__*/_createClass(function MODAL_DIALOG() {
    _classCallCheck(this, MODAL_DIALOG);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/mousewheel-interaction/js/index.js


/* 
 *************************************
 * <!-- Mousewheel Interaction -->
 *************************************
 */

var MOUSEWHEEL_INTERACTION = function (module, $, window, document) {
  if (window.MOUSEWHEEL_INTERACTION === null) return false;
  module.MOUSEWHEEL_INTERACTION = module.MOUSEWHEEL_INTERACTION || {};
  module.MOUSEWHEEL_INTERACTION.version = '0.0.4';
  module.MOUSEWHEEL_INTERACTION.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if (!$('body').hasClass('mousewheel-interaction')) return false;

    //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.
    var quietPeriod = 500,
      //Do not change it
      animationTime = 1000; //According to page transition animation changes

    var lastAnimation = 0;
    var scrollCount = 0;
    var startY = 0;
    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;
      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };
    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
        delta,
        mobileDeltaY = null;
      var touches = e.touches;
      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }
      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 10) {
          //--- swipe up
          dir = 'up';
        }
        if (mobileDeltaY <= -10) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }
      scrollMoveInit(e, dir);
    };
    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);

    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */
    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime();
      // Cancel scroll if currently animating or within quiet period
      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }
      if (dir == 'down') {
        //scroll down
        $('#demo-mousewheel-interaction-status').html('Direction: down, Total: ' + scrollCount);
        scrollCount++;
      } else {
        //scroll up
        $('#demo-mousewheel-interaction-status').html('Direction: up, Total: ' + scrollCount);
        scrollCount++;
      }
      lastAnimation = timeNow;
    }
  };
  module.components.documentReady.push(module.MOUSEWHEEL_INTERACTION.documentReady);
  return /*#__PURE__*/_createClass(function MOUSEWHEEL_INTERACTION() {
    _classCallCheck(this, MOUSEWHEEL_INTERACTION);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/_third-party-plugins/GSAP/esm/ModifiersPlugin.js

/*!
 * VERSION: 0.0.4
 * DATE: 2018-05-30
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 */
/* eslint-disable */


var _cssRatioSetter = function _cssRatioSetter(pt, cssp, mod) {
    //Takes an individual CSSPropTween and converts it into a type:2 that has a setRatio that does everything the regular CSSPlugin.setRatio() method does but applying the mod() too. We do this to keep the main CSSPlugin.setRatio() as fast as possible (the vast majority of times, no mod() will be necessary)
    var type = pt.type,
      oldSetRatio = pt.setRatio,
      tween = cssp._tween,
      target = cssp._target;
    pt.type = 2;
    pt.m = mod;
    pt.setRatio = function (v) {
      var min = 0.000001,
        val,
        str,
        i;
      if (v === 1 && (tween._time === tween._duration || tween._time === 0)) {
        if (type !== 2) {
          if (pt.r && type !== -1) {
            val = Math.round(pt.s + pt.c);
            if (!type) {
              pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
            } else if (type === 1) {
              str = pt.xs0 + val + pt.xs1;
              for (i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }
              pt.t[pt.p] = mod.call(tween, str, target, tween);
            }
          } else {
            pt.t[pt.p] = mod.call(tween, pt.e, target, tween);
          }
        } else {
          oldSetRatio.call(pt, v);
        }
      } else if (v || !(tween._time === tween._duration || tween._time === 0) || tween._rawPrevTime === -0.000001) {
        val = pt.c * v + pt.s;
        if (pt.r) {
          val = Math.round(val);
        } else if (val < min) if (val > -min) {
          val = 0;
        }
        if (!type) {
          pt.t[pt.p] = mod.call(tween, val + pt.xs0, target, tween);
        } else if (type === 1) {
          str = pt.xs0 + val + pt.xs1;
          for (i = 1; i < pt.l; i++) {
            str += pt["xn" + i] + pt["xs" + (i + 1)];
          }
          pt.t[pt.p] = mod.call(tween, str, target, tween);
        } else if (type === -1) {
          //non-tweening value
          pt.t[pt.p] = mod.call(tween, pt.xs0, target, tween);
        } else if (oldSetRatio) {
          oldSetRatio.call(pt, v);
        }
      } else {
        if (type !== 2) {
          pt.t[pt.p] = mod.call(tween, pt.b, target, tween);
        } else {
          oldSetRatio.call(pt, v);
        }
      }
    };
  },
  _modCSS = function _modCSS(lookup, cssp) {
    var pt = cssp._firstPT,
      hasBezier = lookup.rotation && cssp._overwriteProps.join("").indexOf("bezier") !== -1; //when a Bezier tween is applying autoRotation, it's a very special case we need to handle differently.
    if (lookup.scale) {
      lookup.scaleX = lookup.scaleY = lookup.scale;
    } else if (lookup.rotationZ) {
      lookup.rotation = lookup.rotationZ;
    }
    while (pt) {
      if (typeof lookup[pt.p] === "function") {
        _cssRatioSetter(pt, cssp, lookup[pt.p]);
      } else if (hasBezier && pt.n === "bezier" && pt.plugin._overwriteProps.join("").indexOf("rotation") !== -1) {
        pt.data.mod = lookup.rotation;
      }
      pt = pt._next;
    }
  },
  ModifiersPlugin = esm_TweenLite/* _gsScope._gsDefine.plugin */.ML._gsDefine.plugin({
    propName: "modifiers",
    version: "0.0.4",
    API: 2,
    //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
    init: function init(target, value, tween) {
      this._tween = tween;
      this._vars = value;
      return true;
    },
    initAll: function initAll() {
      var tween = this._tween,
        lookup = this._vars,
        mpt = this,
        pt = tween._firstPT,
        val,
        next;
      //initAll() gets called for each and every ModifiersPlugin instance in a tween, so if there are multiple targets, there will be multiple instances. Since we're ripping through the whole tween (and all the PropTweens), we only need to run this code ONCE. So we're setting a toggle on the first PropTween that just tells us if we've done it already. We don't set it on the tween instance because if it gets invalidated, we don't want to have to track this property and reset it. PropTweens get blown away when a tween is invalidated.
      if (pt._modInitted) {
        return false;
      } else {
        pt._modInitted = 1;
      }
      while (pt) {
        next = pt._next; //record here, because it may get removed
        val = lookup[pt.n];
        if (pt.pg) {
          if (pt.t._propName === "css") {
            //handle CSSPlugin uniquely (for performance, due to the fact that the values almost always are a concatenation of numbers and strings, like suffixes, and we don't want to slow down the regular CSSPlugin setRatio() performance with conditional checks for if the value needs to be modded, so we pull any modding prop out and change it to a type:2 one that simply calls a setRatio() method where we encapsulate the modding and update all together. That way, it says in the main CSSProp linked list and just has some custom logic applied to it inside its setRatio())
            _modCSS(lookup, pt.t);
          } else if (pt.t !== mpt) {
            //don't run modProps on modProps :)
            val = lookup[pt.t._propName];
            pt.t._tween = tween;
            pt.t._mod((0,esm_typeof/* default */.Z)(val) === "object" ? val : lookup);
          }
        } else if (typeof val === "function") {
          if (pt.f === 2 && pt.t) {
            //a blob (text containing multiple numeric values)
            pt.t._applyPT.m = val;
            pt.t._tween = tween;
          } else {
            this._add(pt.t, pt.p, pt.s, pt.c, val);
            //remove from linked list
            if (next) {
              next._prev = pt._prev;
            }
            if (pt._prev) {
              pt._prev._next = next;
            } else if (tween._firstPT === pt) {
              tween._firstPT = next;
            }
            pt._next = pt._prev = null;
            tween._propLookup[pt.n] = mpt;
          }
        }
        pt = next;
      }
      return false;
    }
  }),
  ModifiersPlugin_p = ModifiersPlugin.prototype;
ModifiersPlugin_p._add = function (target, p, s, c, mod) {
  this._addTween(target, p, s, s + c, p, mod);
  this._overwriteProps.push(p);
};
ModifiersPlugin_p = esm_TweenLite/* _gsScope._gsDefine.globals.TweenLite.version.split */.ML._gsDefine.globals.TweenLite.version.split(".");
if (Number(ModifiersPlugin_p[0]) <= 1 && Number(ModifiersPlugin_p[1]) < 19 && esm_TweenLite/* _gsScope.console */.ML.console) {
  console.log("ModifiersPlugin requires GSAP 1.19.0 or later.");
}

;// CONCATENATED MODULE: ./src/components/multi-items-carousel/js/index.js



/* 
 *************************************
 * <!-- Multiple Items Carousel -->
 *************************************
 */



var MULTI_ITEMS_CAROUSEL = function (module, $, window, document) {
  if (window.MULTI_ITEMS_CAROUSEL === null) return false;
  module.MULTI_ITEMS_CAROUSEL = module.MULTI_ITEMS_CAROUSEL || {};
  module.MULTI_ITEMS_CAROUSEL.version = '0.0.6';
  module.MULTI_ITEMS_CAROUSEL.documentReady = function ($) {
    $('.uix-multi-carousel').each(function () {
      var $sliderWrapper = $(this),
        $slider = $sliderWrapper.find('.uix-multi-carousel__items'),
        $sliderItem = $sliderWrapper.find('.uix-multi-carousel__items > div'),
        itemsTotal = $sliderItem.length,
        amountVisible = $sliderWrapper.data('show'),
        sliderDir = $sliderWrapper.data('dir'),
        sliderLoop = $sliderWrapper.data('loop'),
        sliderSpeed = $sliderWrapper.data('speed'),
        sliderNext = $sliderWrapper.data('next'),
        sliderPrev = $sliderWrapper.data('prev'),
        carouseDraggable = $sliderWrapper.data('draggable'),
        carouseDraggableCursor = $sliderWrapper.data('draggable-cursor');
      if ((0,esm_typeof/* default */.Z)(sliderDir) === ( true ? "undefined" : 0)) sliderDir = 'horizontal';
      if ((0,esm_typeof/* default */.Z)(sliderLoop) === ( true ? "undefined" : 0)) sliderLoop = false;
      if ((0,esm_typeof/* default */.Z)(amountVisible) === ( true ? "undefined" : 0)) amountVisible = 3;
      if ((0,esm_typeof/* default */.Z)(sliderSpeed) === ( true ? "undefined" : 0)) sliderSpeed = 250;
      if ((0,esm_typeof/* default */.Z)(sliderNext) === ( true ? "undefined" : 0)) sliderNext = '.uix-multi-carousel__controls--next';
      if ((0,esm_typeof/* default */.Z)(sliderPrev) === ( true ? "undefined" : 0)) sliderPrev = '.uix-multi-carousel__controls--prev';
      if ((0,esm_typeof/* default */.Z)(carouseDraggable) === ( true ? "undefined" : 0)) carouseDraggable = false;
      if ((0,esm_typeof/* default */.Z)(carouseDraggableCursor) === ( true ? "undefined" : 0)) carouseDraggableCursor = 'move';
      if (window.innerWidth <= 768) amountVisible = 3;

      // Returns the value of a number rounded to the nearest integer.
      var midIndex = Math.round(amountVisible / 2) - 1;

      /* 
       ---------------------------
       Initialize slider
       ---------------------------
       */
      var eachItemNewWidth, eachItemNewHeight;
      var eachItemOldWidth = $slider.width() / amountVisible;
      var eachItemOldHeight = $slider.height() / amountVisible;
      if (sliderDir === 'horizontal') {
        eachItemNewWidth = $sliderWrapper.width() / amountVisible;
        $slider.css('width', itemsTotal * eachItemOldWidth);
      } else {
        eachItemNewHeight = $sliderWrapper.height() / amountVisible;
        $slider.css('height', itemsTotal * eachItemOldHeight);
      }

      // Re-order all items
      sliderReOrder();

      //default button status
      if (!sliderLoop) {
        $(sliderPrev).addClass('is-disabled').data('disabled', 1);
      }

      /* 
       ---------------------------
       Re-order all items
       ---------------------------
       */

      function sliderReOrder() {
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          TweenMax.set($sliderItem, {
            width: boxWidth,
            x: function x(i, target) {
              //Active the center item
              if (i === midIndex && sliderLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              }

              //Add index to each item
              $sliderItem.eq(i).attr('data-index', i);
              return i * boxWidth;
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          TweenMax.set($sliderItem, {
            height: boxHeight,
            y: function y(i, target) {
              //Active the center item
              if (i === midIndex && sliderLoop) {
                TweenMax.set(target, {
                  className: "+=is-active"
                });
              }

              //Add index to each item
              $sliderItem.eq(i).attr('data-index', i);
              return i * boxHeight;
            }
          });
        }
      }

      /* 
       ---------------------------
       Next/Prev buttons
       ---------------------------
       */
      var _prev = $(sliderPrev),
        _next = $(sliderNext);
      _next.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnNextMove();
      });
      _prev.off('click').on('click', $sliderWrapper, function (e) {
        e.preventDefault();
        btnPrevMove();
      });

      // (right/down)
      function btnPrevMove() {
        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;
        _prev.attr('aria-disabled', 'true');
        _prev.delay(sliderSpeed).queue(function (next) {
          _prev.attr('aria-disabled', 'false');
          next();
        });

        //
        movePositionWithButton(_prev, 'prev');
      }

      // (left/up)
      function btnNextMove() {
        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;
        _next.attr('aria-disabled', 'true');
        _next.delay(sliderSpeed).queue(function (next) {
          _next.attr('aria-disabled', 'false');
          next();
        });

        //
        movePositionWithButton(_next, 'next');
      }

      //Drag and Drop
      //-------------------------------------	
      var $dragDropTrigger = $sliderWrapper;
      var hammerProps = {};

      //Make the cursor a move icon when a user hovers over an item
      if (carouseDraggable && carouseDraggableCursor != '' && carouseDraggableCursor != false) $dragDropTrigger.css('cursor', carouseDraggableCursor);
      if (!carouseDraggable) {
        hammerProps = {
          inputClass: Hammer.TouchInput
        };
      }

      //Mouse event
      //Hammer.js pan event only for touch devices and not for desktop computer Click+Drag
      var direction;
      var dragDropElement = $dragDropTrigger[0],
        dragDropMC = new Hammer(dragDropElement, hammerProps);
      var elAnim = true;

      // let the pan gesture support all directions.
      // this will block the vertical scrolling on a touch-device while on the element
      dragDropMC.get('pan').set({
        direction: Hammer.DIRECTION_ALL
      });
      dragDropMC.on('press panright panleft panup pandown', function (ev) {
        //Set the direction in here
        direction = ev.type;

        //Determine whether it is the first or the last    
        var currentIsFirstOrLast = false;
        if (!sliderLoop) {
          var firstItemOffset = sliderDir === 'horizontal' ? $slider.find('[data-index="0"]')[0]._gsTransform.x : $slider.find('[data-index="0"]')[0]._gsTransform.y;
          var maxMoveOffset = sliderDir === 'horizontal' ? -eachItemNewWidth * (itemsTotal - amountVisible) : -eachItemNewHeight * (itemsTotal - amountVisible);
          if ((direction == 'panright' || direction == 'pandown') && firstItemOffset >= 0) {
            //first item
            currentIsFirstOrLast = true;
          }
          if ((direction == 'panleft' || direction == 'panup') && firstItemOffset <= maxMoveOffset) {
            //last item
            currentIsFirstOrLast = true;
          }
        }

        //Rebound effect of drag offset 
        switch (direction) {
          case 'panleft':
            if (ev.deltaX > -eachItemNewWidth / 4 && ev.deltaX < 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }
            break;
          case 'panup':
            if (ev.deltaY > -eachItemNewHeight / 4 && ev.deltaY < 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }
            break;
          case 'panright':
            if (ev.deltaX < eachItemNewWidth / 4 && ev.deltaX > 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaX, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }
            break;
          case 'pandown':
            if (ev.deltaY < eachItemNewHeight / 4 && ev.deltaY > 0) {
              elAnim = false;
              itemUpdates($sliderWrapper, ev.deltaY, 0.1, true);
            } else {
              elAnim = currentIsFirstOrLast ? false : true;
            }
            break;
        }
      });
      dragDropMC.on('panend', function (ev) {
        if (elAnim) {
          //Use the direction in here
          //You know the pan has ended
          //and you know which action they were taking
          switch (direction) {
            case 'panleft':
            case 'panup':
              var delta1 = sliderDir === 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
              itemUpdates($sliderWrapper, delta1, null, false);
              break;
            case 'panright':
            case 'pandown':
              var delta2 = sliderDir === 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
              itemUpdates($sliderWrapper, delta2, null, false);
              break;
          }
        } else {
          itemUpdates($sliderWrapper, 0, null, false);
        }
      });

      /*
       * Transition Between Items
       *
       * @param  {Element} wrapper        - Wrapper of slider.
                * @param  {Number} delta           - The value returned will need to be adjusted according to the offset rate.
                * @param  {?Number} speed          - Sliding speed. Please set to 0 when rebounding.
                * @param  {Boolean} dragging       - Determine if the object is being dragged.
       * @return {Void}
       */
      function itemUpdates(wrapper, delta, speed, dragging) {
        if (speed == null) speed = sliderSpeed / 1000;
        var $curWrapper = wrapper.children('.uix-multi-carousel__items'),
          //Default: $slider
          $curItems = $curWrapper.find('> div'); //Default: $sliderItem

        //Clone the first element to the last position
        if (sliderDir === 'horizontal') {
          var boxWidth = eachItemNewWidth;
          var wrapWidth = ($curItems.length - 1) * boxWidth;
          TweenMax.to($curItems, speed, {
            x: function x(i, target) {
              var x = Math.round(target._gsTransform.x / boxWidth) * boxWidth;
              return x + delta;
            },
            modifiers: {
              x: function x(_x, target) {
                if (sliderLoop) {
                  //Active the center item
                  if (_x === midIndex * boxWidth) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }
                  return wrap(_x, -boxWidth, wrapWidth);
                } else {
                  return _x;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.x), Math.round(($curItems.length - amountVisible) * boxWidth));
              }
            }
          });
        } else {
          var boxHeight = eachItemNewHeight;
          var wrapHeight = ($curItems.length - 1) * boxHeight;
          TweenMax.to($curItems, speed, {
            y: function y(i, target) {
              var y = Math.round(target._gsTransform.y / boxHeight) * boxHeight;
              return y + delta;
            },
            modifiers: {
              y: function y(_y, target) {
                if (sliderLoop) {
                  //Active the center item
                  if (_y === midIndex * boxHeight) {
                    TweenMax.set(target, {
                      className: "+=is-active"
                    });
                  } else {
                    TweenMax.set(target, {
                      className: "-=is-active"
                    });
                  }
                  return wrap(_y, -boxHeight, wrapHeight);
                } else {
                  return _y;
                }
              }
            },
            onComplete: function onComplete() {
              if (!dragging && delta != 0) {
                //The state of the control button
                setButtonState(Math.round($curItems.first()[0]._gsTransform.y), Math.round(($curItems.length - amountVisible) * boxHeight));
              }
            }
          });
        }
      }

      /*
       * Move function with buttons
       *
       * @param  {Element} $btn               - The button that currently triggers the move.
                * @param  {String} type                - Move next or previous.
       * @return {Void}
       */
      function movePositionWithButton($btn, type) {
        var
        //Protection button is not triggered multiple times.
        btnDisabled = $btn.data('disabled');
        var delta;
        if (type == 'next') {
          delta = sliderDir === 'horizontal' ? -eachItemNewWidth : -eachItemNewHeight;
        } else {
          delta = sliderDir === 'horizontal' ? eachItemNewWidth : eachItemNewHeight;
        }
        if ((0,esm_typeof/* default */.Z)(btnDisabled) === ( true ? "undefined" : 0)) {
          itemUpdates($sliderWrapper, delta, null, false);
        }
      }

      /*
       * The state of the control button
       *
                * @param  {Number} firstOffset          - Get the computed Translate X or Y values of a given first DOM element.
                * @param  {Number} lastOffset           - Get the computed Translate X or Y values of a given last DOM element.
       * @return {Void}
       */
      function setButtonState(firstOffset, lastOffset) {
        if (sliderLoop) return false;
        if (Math.abs(firstOffset) == lastOffset) {
          $(sliderNext).addClass('is-disabled').data('disabled', 1);
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        } else if (Math.round(firstOffset) == 0) {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).addClass('is-disabled').data('disabled', 1);
        } else {
          $(sliderNext).removeClass('is-disabled').removeData('disabled');
          $(sliderPrev).removeClass('is-disabled').removeData('disabled');
        }
      }

      /*
       * Tweens each box to a relative x/y position of "+={number}"
       *
       * @param  {Number} value           - Current position of the element, x or y coordinates.
       * @param  {Number} min             - The minimum value, used to mark the width or height of each element.
       * @param  {Number} max             - The maximum value, used to mark the width or height of the entire container.
       * @return {Number}                 - The about-to-be-applied value from the regular tween.
       */
      function wrap(value, min, max) {
        var v = value - min;
        var r = max - min;

        // force x/y value to be between {min} and {max} using modulus
        return (r + v % r) % r + min;
      }
    });
  };
  module.components.documentReady.push(module.MULTI_ITEMS_CAROUSEL.documentReady);
  return /*#__PURE__*/_createClass(function MULTI_ITEMS_CAROUSEL() {
    _classCallCheck(this, MULTI_ITEMS_CAROUSEL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/one-page/js/index.js


/* 
 *************************************
 * <!-- Full Page/One Page Transition -->
 *************************************
 */


var ONEPAGE = function (module, $, window, document) {
  if (window.ONEPAGE === null) return false;
  module.ONEPAGE = module.ONEPAGE || {};
  module.ONEPAGE.version = '0.1.1';
  module.ONEPAGE.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.
    var quietPeriod = 500,
      //Do not change it
      animationTime = 1000,
      //According to page transition animation changes
      $sectionsContainer = $('.uix-normal-load__onepage-container'),
      $sections = $sectionsContainer.find('[data-highlight-section]'),
      sectionTotal = $sections.length,
      /* topSpacing         = ( window.innerWidth <= 768 ) ? 0 : $( '.uix-header__container' ).outerHeight( true ), //with margin */
      topSpacing = 0,
      $primaryMenu = $('.uix-menu'),
      $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0;

    //Prevent this module from loading in other pages
    if ($sectionsContainer.length == 0) return false;

    // Prepare everything before binding wheel scroll
    $.each($sections, function (i) {
      $(this).attr('data-index', i);
      if (i == 0) {
        $(this).addClass('is-active');
      }
    });

    //Init the section location
    sectionStart();

    //Detect URL change
    $(window).on('hashchange', function () {
      var hash = window.location.hash,
        locArr,
        loc;
      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });

    /*
     * Init the section location
     *
     * @return {Void}
     */
    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
          locArr,
          loc,
          curTab;
        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }

    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */
    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime();
      // Cancel scroll if currently animating or within quiet period
      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }
      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }
      lastAnimation = timeNow;
    }

    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */
    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
        isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
        $next = null;
      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      }

      //ID of custom hashchange event
      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);
      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0;

        //Returns the target section
        $next = $sections.eq(nextIndex);

        //Smooth scroll to content
        if ($next.length > 0) {
          TweenMax.to(window, animationTime / 1000, {
            scrollTo: {
              y: $next.offset().top - topSpacing,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              $sections.removeClass('leave');
              $sections.eq(index).addClass('leave');
              $sections.removeClass('is-active');
              $next.addClass('is-active').removeClass('leave');

              //Changing The Site URL
              var curSectionIndex = $sections.filter('.is-active').index() + 1,
                href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id');

              // Save state on history stack
              // - First argument is any object that will let you restore state
              // - Second argument is a title (not the page title, and not currently used)
              // - Third argument is the URL - this will appear in the browser address bar
              history.pushState({}, document.title, href);
              console.log('Section ' + curSectionIndex + ' loaded!');
            }
          });
        }
      }
    }

    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */
    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu);

    //Activate the first item
    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');

    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */
    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }

    /*
     * Get link by section or article id
     *
     * @param  {String|Element} el    - The current selector or selector ID
     * @param  {Element} menuObj       - Returns the menu element within the document.
     * @param  {Boolean} echoIndex    - Whether to return the current index.
     * @return {Object}               - A new selector.
     */
    function getRelatedNavigation(el, menuObj, echoIndex) {
      if (echoIndex) {
        return menuObj.find('li > a[href="#' + $(el).attr('id') + '"]').parent('li').index();
      } else {
        return menuObj.find('li > a[href="#' + $(el).attr('id') + '"]').parent('li');
      }
    }

    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */
    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }

    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */
    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE').on('click.ONEPAGE', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        moveTo($sectionsContainer, false, $(this).parent('li').index() + 1);
      });
    }
    var navMinTop = $sidefixedMenu.length > 0 ? $sidefixedMenu.offset().top : 0,
      navMaxTop = parseFloat($(document).height() - $('.uix-footer__container').height()) - windowHeight / 3;
    function scrollUpdate() {
      var scrolled = $(window).scrollTop(),
        spyTop = parseFloat(scrolled + topSpacing),
        minTop = $('[data-highlight-section="true"]').first().offset().top,
        maxTop = $('[data-highlight-section="true"]').last().offset().top + $('[data-highlight-section="true"]').last().height();
      $('[data-highlight-section="true"]').each(function () {
        var $block = $(this),
          eleTop = $block.offset().top;

        // The 1 pixel in order to solve inaccurate value of outerHeight() 
        // in Safari and Firefox browsers.
        if (eleTop < spyTop + 1) {
          // Highlight element when related content
          getAllNavigation($primaryMenu).removeClass('is-active');
          getAllNavigation($sidefixedMenu).removeClass('is-active');
          getRelatedNavigation($block, $primaryMenu, false).addClass('is-active');
          getRelatedNavigation($block, $sidefixedMenu, false).addClass('is-active');
        }
      });

      //Cancel the current highlight element
      // The 1 pixel in order to solve inaccurate value of outerHeight() 
      // in Safari and Firefox browsers.
      if (spyTop > maxTop || spyTop < minTop - 1) {
        getAllNavigation($primaryMenu).removeClass('is-active');
        getAllNavigation($sidefixedMenu).removeClass('is-active');
      }

      //Detecting when user scrolls to bottom of div
      if (spyTop > navMaxTop || spyTop < navMinTop) {
        $sidefixedMenu.removeClass('is-fixed');
      } else {
        $sidefixedMenu.addClass('is-fixed');
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();

    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */
    var startY = 0;
    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;
      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };
    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
        delta,
        mobileDeltaY = null;
      var touches = e.touches;
      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }
      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }
        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }
      scrollMoveInit(e, dir);
    };
    window.addEventListener('wheel', onDeviceWheel, {
      passive: true
    });
    window.addEventListener('touchstart', onTouchStart, {
      passive: true
    });
    window.addEventListener('touchmove', onDeviceWheel, {
      passive: true
    });
  };
  module.components.documentReady.push(module.ONEPAGE.documentReady);
  return /*#__PURE__*/_createClass(function ONEPAGE() {
    _classCallCheck(this, ONEPAGE);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/one-page2/js/index.js


/* 
 *************************************
 * <!-- Full Page/One Page Transition 2 -->
 *************************************
 */

var ONEPAGE2 = function (module, $, window, document) {
  if (window.ONEPAGE2 === null) return false;
  module.ONEPAGE2 = module.ONEPAGE2 || {};
  module.ONEPAGE2.version = '0.0.7';
  module.ONEPAGE2.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //Determine the direction of a jQuery scroll event
    //Fix an issue for mousewheel event is too fast.
    var quietPeriod = 500,
      //Do not change it
      animationTime = 1000,
      //According to page transition animation changes
      $sectionsContainer = $('.uix-normal-load__onepage-container2'),
      $sections = $sectionsContainer.find('[data-highlight-section]'),
      sectionTotal = $sections.length,
      $primaryMenu = $('.uix-menu'),
      $sidefixedMenu = $('.uix-menu-sidefixed');
    var lastAnimation = 0;

    //Prevent this module from loading in other pages
    if ($sectionsContainer.length == 0) return false;

    //Init the sections style
    $sectionsContainer.css({
      'position': 'relative'
    });
    var secIndex = 10;
    for (var i = 0; i < sectionTotal; i++) {
      $sections.eq(i).css({
        'position': 'absolute',
        'width': '100%',
        'z-index': secIndex,
        'top': 0,
        'left': 0
      });
      secIndex--;
    }

    // Prepare everything before binding wheel scroll
    $.each($sections, function (i) {
      $(this).attr('data-index', i);
      if (i == 0) {
        $(this).addClass('is-active');
      }
    });

    //Init the section location
    sectionStart();

    //Detect URL change
    $(window).on('hashchange', function () {
      var hash = window.location.hash,
        locArr,
        loc;
      if (hash) {
        //Add hashchange event
        locArr = hash.split('section-');
        loc = locArr[1];
        moveTo($sectionsContainer, false, loc);
      }
    });

    /*
     * Init the section location
     *
     * @return {Void}
     */
    function sectionStart() {
      setTimeout(function () {
        var hash = window.location.hash,
          locArr,
          loc,
          curTab;
        if (hash) {
          //Add hashchange event
          locArr = hash.split('section-');
          loc = locArr[1];
          moveTo($sectionsContainer, false, loc);
        } else {
          moveTo($sectionsContainer, false, 1);
        }
      }, quietPeriod);
    }

    /*
     * Initialize the depth of all sections
     *
     * @param  {Number} nextIndex        - Index of next section.
     * @param  {Number} currentIndex     - Index of current section.
     * @return {Void}
     */
    function sectionsDepthInit(nextIndex, currentIndex) {
      var secIndex = 10;
      for (var _i = 0; _i < sectionTotal; _i++) {
        if (nextIndex && _i != nextIndex && _i != currentIndex) {
          $sections.eq(_i).css('z-index', secIndex);
        }
        secIndex--;
      }
    }

    /*
     * Scroll initialize
     *
     * @param  {Event} event        - The wheel event is fired when a wheel button of a pointing device (usually a mouse) is rotated. 
     * @param  {String} dir          - Gets a value that indicates the amount that the mouse wheel has changed.
     * @return {Void}
     */
    function scrollMoveInit(event, dir) {
      var timeNow = new Date().getTime();
      // Cancel scroll if currently animating or within quiet period
      if (timeNow - lastAnimation < quietPeriod + animationTime) {
        return;
      }
      if (dir == 'down') {
        //scroll down
        moveTo($sectionsContainer, 'down', false);
      } else {
        //scroll up
        moveTo($sectionsContainer, 'up', false);
      }
      lastAnimation = timeNow;
    }

    /*
     * Move Animation
     *
     * @param  {Element} el           - The container of each sections.
     * @param  {String} dir          - Rolling direction indicator.
     * @param  {Number} hashID       - ID of custom hashchange event.
     * @return {Void}
     */
    function moveTo(el, dir, hashID) {
      var index = parseFloat($sections.filter('.is-active').attr('data-index')),
        isNumeric = /^[-+]?(\d+|\d+\.\d*|\d*\.\d+)$/;
      var nextIndex = null,
        $next = null;
      if (dir == 'down' || dir === false) {
        nextIndex = index + 1;
      } else {
        nextIndex = index - 1;
      }

      //ID of custom hashchange event
      if (isNumeric.test(hashID)) nextIndex = parseFloat(hashID - 1);
      if (nextIndex <= parseFloat(sectionTotal - 1) && nextIndex >= 0) {
        if (nextIndex > parseFloat(sectionTotal - 1)) nextIndex = parseFloat(sectionTotal - 1);
        if (nextIndex < 0) nextIndex = 0;

        //Returns the target section
        $next = $sections.eq(nextIndex);
        if ($next.length > 0) {
          TweenMax.set($next, {
            css: {
              'z-index': 12,
              'top': dir == 'down' || dir === false ? windowHeight : -windowHeight
            },
            onComplete: function onComplete() {
              //Reset sections z-index
              $sections.eq(index).css('z-index', 11);
              sectionsDepthInit(nextIndex, index);
              TweenMax.to($sections.eq(index), animationTime / 1000, {
                css: {
                  'top': dir == 'down' || dir === false ? -windowHeight / 2 : windowHeight / 2
                },
                ease: Power2.easeOut
              });
              TweenMax.to(this.target, animationTime / 2000, {
                css: {
                  'top': 0
                },
                ease: Power2.easeOut,
                onComplete: function onComplete() {
                  $sections.removeClass('leave');
                  $sections.eq(index).addClass('leave');
                  $sections.removeClass('is-active');
                  $next.addClass('is-active').removeClass('leave');

                  //Changing The Site URL
                  var curSectionIndex = $sections.filter('.is-active').index() + 1,
                    href = window.location.href.substr(0, window.location.href.indexOf('#')) + '#' + $sections.filter('.is-active').attr('id');

                  // Save state on history stack
                  // - First argument is any object that will let you restore state
                  // - Second argument is a title (not the page title, and not currently used)
                  // - Third argument is the URL - this will appear in the browser address bar
                  history.pushState({}, document.title, href);
                  console.log('Section ' + curSectionIndex + ' loaded!');

                  // Highlight element when related content
                  getAllNavigation($primaryMenu).removeClass('is-active');
                  getAllNavigation($sidefixedMenu).removeClass('is-active');
                  $primaryMenu.find('li').eq(nextIndex).addClass('is-active');
                  $sidefixedMenu.find('li').eq(nextIndex).addClass('is-active');
                }
              });
            }
          });
        }
      }
    }

    /* 
     ====================================================
     *  Navigation Interaction
     ====================================================
     */
    goPageSection($primaryMenu);
    goPageSection($sidefixedMenu);

    //Activate the first item
    $primaryMenu.find('li:first').addClass('is-active');
    $sidefixedMenu.find('li:first').addClass('is-active');

    /*
     * Get section or article by href
     *
     * @param  {String|Object} el  - The current selector or selector ID
     * @return {Object}             - A new selector.
     */
    function getRelatedContent(el) {
      return $($(el).attr('href'));
    }

    /*
     * Get all links by section or article
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Element}             - A new selector.
     */
    function getAllNavigation(menuObj) {
      return menuObj.find('li');
    }

    /*
     * Smooth scroll to content
     *
     * @param  {Element} menuObj     - Returns the menu element within the document.
     * @return {Void}
     */
    function goPageSection(menuObj) {
      menuObj.find('li > a').off('click.ONEPAGE2').on('click.ONEPAGE2', function (e) {
        e.preventDefault();
        if ($(this).parent().hasClass('is-active')) return false;
        var dir = 'down';
        if ($sections.filter('.is-active').index() > $(this).parent().index()) {
          dir = 'up';
        }
        moveTo($sectionsContainer, dir, $(this).parent('li').index() + 1);
      });
    }

    /* 
     ====================================================
     *  Mouse Wheel & Touch Method
     ====================================================
     */
    var startY = 0;
    var onTouchStart = function onTouchStart(e) {
      var touches = e.touches;
      if (touches && touches.length) {
        startY = touches[0].pageY;
      }
    };
    var onDeviceWheel = function onDeviceWheel(e) {
      //Gets a value that indicates the amount that the mouse wheel has changed.
      var dir,
        delta,
        mobileDeltaY = null;
      var touches = e.touches;
      if (touches && touches.length) {
        mobileDeltaY = startY - touches[0].pageY;
      } else {
        delta = Math.max(-1, Math.min(1, -e.deltaY));
      }
      if (mobileDeltaY != null) {
        if (mobileDeltaY >= 50) {
          //--- swipe up
          dir = 'up';
        }
        if (mobileDeltaY <= -50) {
          //--- swipe down
          dir = 'down';
        }
      } else {
        if (delta < 0) {
          //scroll down
          dir = 'down';
        } else {
          //scroll up
          dir = 'up';
        }
      }
      scrollMoveInit(e, dir);
    };
    window.addEventListener('wheel', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchstart', onTouchStart, browser.supportsPassive ? {
      passive: true
    } : false);
    window.addEventListener('touchmove', onDeviceWheel, browser.supportsPassive ? {
      passive: true
    } : false);
  };
  module.components.documentReady.push(module.ONEPAGE2.documentReady);
  return /*#__PURE__*/_createClass(function ONEPAGE2() {
    _classCallCheck(this, ONEPAGE2);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/parallax/js/index.js



/* 
 *************************************
 * <!-- Parallax -->
 *************************************
 */




var PARALLAX = function (module, $, window, document) {
  if (window.PARALLAX === null) return false;
  module.PARALLAX = module.PARALLAX || {};
  module.PARALLAX.version = '0.0.8';
  module.PARALLAX.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //  Initialize
    parallaxInit(windowWidth);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        parallaxInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize parallx settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @return {Void}
     */
    function parallaxInit(w) {
      /* Pure parallax scrolling effect without other embedded HTML elements */
      $('.uix-parallax--el').each(function () {
        var $this = $(this);
        var dataSpeed = $this.data('speed'),
          dataEasing = $this.data('transition');
        if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) {
          dataSpeed = 0;
        }
        if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) {
          dataEasing = 'none 0s ease 0s';
        }
        $this.UixParallax({
          'speed': dataSpeed,
          'bg': false,
          transition: dataEasing
        });
      });

      /* Parallax scrolling effect with embedded HTML elements */
      $('.uix-parallax').each(function () {
        var $this = $(this);
        var $curImg = $this.find('.uix-parallax__img'),
          dataImg = $curImg.attr('src');
        var dataSkew = $this.data('skew'),
          dataSpeed = $this.data('speed'),
          dataEasing = $this.data('transition'),
          dataOverlay = $this.data('overlay-bg'),
          dataFullyVisible = $this.data('fully-visible'),
          dataXPos = $this.data('xpos'),
          dataOffsetTop = parseFloat($this.data('offset-top')),
          curImgH = null,
          curImgW = null,
          curSize = 'cover';
        if ((0,esm_typeof/* default */.Z)(dataOverlay) === ( true ? "undefined" : 0) || dataOverlay == 'none' || dataOverlay == 0 || dataOverlay == false) {
          dataOverlay = 'rgba(0, 0, 0, 0)';
        }
        if ((0,esm_typeof/* default */.Z)(dataSpeed) === ( true ? "undefined" : 0)) {
          // If there is no data-xxx, save current source to it
          dataSpeed = 0;
        }
        if ((0,esm_typeof/* default */.Z)(dataEasing) === ( true ? "undefined" : 0)) {
          dataEasing = 'none 0s ease 0s';
        }
        if ((0,esm_typeof/* default */.Z)(dataXPos) === ( true ? "undefined" : 0)) {
          dataXPos = '50%';
        }
        if ((0,esm_typeof/* default */.Z)(dataOffsetTop) === ( true ? "undefined" : 0)) {
          dataOffsetTop = 0;
        }
        if ((0,esm_typeof/* default */.Z)(dataFullyVisible) === ( true ? "undefined" : 0)) {
          dataFullyVisible = false;
        }

        //Trigger a callback when the selected images are loaded
        //Check if the picture is loaded on the page
        var img = new Image();
        img.onload = function () {
          curImgH = $curImg.height();
          curImgW = $curImg.width();

          //Custom height for parallax container
          if ($this.hasClass('uix-height--10') || $this.hasClass('uix-height--20') || $this.hasClass('uix-height--30') || $this.hasClass('uix-height--40') || $this.hasClass('uix-height--50') || $this.hasClass('uix-height--60') || $this.hasClass('uix-height--70') || $this.hasClass('uix-height--80') || $this.hasClass('uix-height--90') || $this.hasClass('uix-height--100')) {
            var newH = $this.height();
            $this.css({
              'height': newH + 'px'
            });
            $curImg.css('max-height', newH + 'px');
          } else {
            $this.css({
              'height': $this.height() + 'px'
            });
          }

          //If the ".uix-v-align--absolute" has more content
          if (w <= 768) {
            if ($this.find('.uix-v-align--absolute').height() >= curImgH) {
              $this.find('.uix-v-align--absolute').addClass('uix-v-align--relative');
              $curImg.hide();
            }
          }

          //Resize the background image to cover the entire container and
          //Resize the background image to make sure the image is fully visible
          if (curImgW > w) {
            curSize = 'contain';
          } else {
            curSize = 'cover';
          }

          //Determine image height and parallax container height
          //If the height is the same, higher or lower than the height of the container height, 
          //be sure to use the cover attribute
          //*** Must be placed before the "dataFullyVisible" condition
          if (curImgH <= $this.height()) {
            curSize = 'cover';
          }

          //Whether to display all pictures, including the edges
          if (dataFullyVisible) {
            if (curImgW < w) {
              curSize = 'cover';
            } else {
              curSize = 'contain';
            }
          }

          //console.log( 'Height: ' +curImgH + '===' + $this.height() + ' | Width: ' + curImgW + '===' + w + ' | ' + curSize );

          //Add background image to parallax container
          if ((0,esm_typeof/* default */.Z)(dataImg) != ( true ? "undefined" : 0)) {
            if (Modernizr.cssanimations) {
              // supported

              $this.css({
                'background': 'linear-gradient(' + dataOverlay + ', ' + dataOverlay + '), url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            } else {
              // not-supported

              $this.css({
                'background': 'url(' + dataImg + ') ' + dataXPos + ' ' + dataOffsetTop + 'px/' + curSize + ' no-repeat fixed'
              });
            }
          }

          //Apply tilt effect
          if ((0,esm_typeof/* default */.Z)(dataSkew) != ( true ? "undefined" : 0) && dataSkew != 0) {
            //Firefox browser will affect parallax effect due to transform
            $this.css({
              'transform': 'skew(0deg, ' + dataSkew + 'deg)'
            });
          }

          //Use parallax to background
          $this.UixParallax({
            'speed': dataSpeed,
            'transition': dataEasing,
            'offsetTop': dataOffsetTop,
            'bg': {
              enable: true,
              xPos: dataXPos
            }
          });
        };
        img.src = dataImg;
      });
    }
  };
  module.components.documentReady.push(module.PARALLAX.documentReady);
  return /*#__PURE__*/_createClass(function PARALLAX() {
    _classCallCheck(this, PARALLAX);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/periodical-scroll/js/index.js



/* 
 *************************************
 * <!-- Periodical Scroll -->
 *************************************
 */


var PERIODICAL_SCROLL = function (module, $, window, document) {
  if (window.PERIODICAL_SCROLL === null) return false;
  module.PERIODICAL_SCROLL = module.PERIODICAL_SCROLL || {};
  module.PERIODICAL_SCROLL.version = '0.0.5';
  module.PERIODICAL_SCROLL.documentReady = function ($) {
    $('.uix-periodical-scroll').each(function () {
      var $this = $(this);
      var speed = $this.data('speed'),
        timing = $this.data('timing');
      var $list = $this.find('> ul');
      var itemHeight = $list.find('li:first').height();
      $this.css({
        'height': itemHeight + 'px',
        'overflow': 'hidden'
      });
      if ((0,esm_typeof/* default */.Z)(speed) === ( true ? "undefined" : 0)) {
        speed = 600;
      }
      if ((0,esm_typeof/* default */.Z)(timing) === ( true ? "undefined" : 0)) {
        timing = 2000;
      }

      //If there is only one item, add one to complete the seamless loop effect
      if ($list.find('li').length == 1) {
        $list.prepend($list.find('li:first').clone());
      }

      //
      var eachItemAnimOKDelay = 150;
      var $item = $list.find('> li');
      var moveY = itemHeight * 2;

      //Prevent repetition of animation events
      TweenMax.killTweensOf($item);

      //
      var tl = new TimelineMax({
        repeat: -1,
        repeatDelay: eachItemAnimOKDelay / 1000
      });

      //pauses wherever the playhead currently is:
      tl.pause();
      setTimeout(function () {
        tl.play();
      }, speed);
      tl.add(TweenMax.staggerFromTo($item, speed / 1000, {
        opacity: 0,
        y: moveY
      }, {
        opacity: 1,
        y: 0
      }, timing / 1000)).add(TweenMax.staggerTo($item, speed / 1000, {
        delay: timing / 1000,
        opacity: 0,
        y: -moveY,
        onComplete: function onComplete() {
          TweenMax.set(this.target, {
            delay: eachItemAnimOKDelay / 1000,
            opacity: 0,
            y: moveY
          });
        }
      }, timing / 1000), 0);
      $item.on('mouseenter', function () {
        tl.pause();
      }).on('mouseleave', function () {
        tl.play();
        if ($(this).index() > 0) {
          TweenMax.set($item.first(), {
            opacity: 0,
            y: moveY
          });
        }
      });
    });
  };
  module.components.documentReady.push(module.PERIODICAL_SCROLL.documentReady);
  return /*#__PURE__*/_createClass(function PERIODICAL_SCROLL() {
    _classCallCheck(this, PERIODICAL_SCROLL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/pricing/js/index.js


/* 
 *************************************
 * <!-- Pricing -->
 *************************************
 */


var PRICING = function (module, $, window, document) {
  if (window.PRICING === null) return false;
  module.PRICING = module.PRICING || {};
  module.PRICING.version = '0.0.3';
  module.PRICING.documentReady = function ($) {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;

    //-------- Pricing initialize
    pricingInit(windowWidth);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        pricingInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
    function pricingInit(w) {
      //Initialize the height
      $('.uix-price').each(function () {
        //returns new id
        var $this = $(this);
        var $initHeight = $this.find('.js-uix-init-height');
        var priceBGH = [],
          priceBGH_excerpt = [];
        $initHeight.each(function (index) {
          //Screen protection of height
          $(this).find('.uix-price__outline, .uix-price__excerpt').css('height', 'auto');
          var tempheight = $(this).height();
          var tempheight_excerpt = $(this).find('.uix-price__excerpt').height();
          priceBGH.push(tempheight);
          priceBGH_excerpt.push(tempheight_excerpt);
        });
        var priceBGH_Max = Math.max.apply(Math, priceBGH);
        if (priceBGH_Max > 0) {
          if (w > 768) {
            // Initialize the height of all columns
            $initHeight.find('.uix-price__outline').css('height', priceBGH_Max + 'px');

            // Actived columns
            $initHeight.find('.uix-price__outline.is-active').each(function () {
              var ty = Math.abs(parseInt($(this).css('transform').split(',')[5]));
              if (!isNaN(ty)) {
                $(this).css('height', priceBGH_Max + ty * 2 + 'px');
              }
            });
          } else {
            $initHeight.find('.uix-price__outline').css('height', 'auto');
          }

          // Actived columns
          $initHeight.find('.uix-price__outline.is-active').each(function () {
            var textColor = $(this).closest('.uix-price__outline--hover').data('tcolor'),
              btnColor = $(this).closest('.uix-price__outline--hover').data('bcolor');
            $(this).css('background-color', btnColor);
            $(this).find('.uix-btn').removeClass('uix-btn__bg--primary').addClass('uix-btn__bg--secondary');
          });
        }
      });
    }
  };
  module.components.documentReady.push(module.PRICING.documentReady);
  return /*#__PURE__*/_createClass(function PRICING() {
    _classCallCheck(this, PRICING);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/progress-bar/js/index.js



/* 
 *************************************
 * <!-- Progress Bar -->
 *************************************
 */


var PROGRESS_BAR = function (module, $, window, document) {
  if (window.PROGRESS_BAR === null) return false;
  module.PROGRESS_BAR = module.PROGRESS_BAR || {};
  module.PROGRESS_BAR.version = '0.0.7';
  module.PROGRESS_BAR.documentReady = function ($) {
    var $scrollElements = $('[data-progressbar-percent]');
    $scrollElements.each(function () {
      var viewport = 1;
      var $el = $(this);

      //
      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top;

        //Prevent asynchronous loading of repeated calls
        var actived = $el.data('activated');
        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            var percent = $el.data('progressbar-percent'),
              unit = $el.data('progressbar-unit');
            if ((0,esm_typeof/* default */.Z)(percent) === ( true ? "undefined" : 0)) {
              percent = 0;
            }
            if ((0,esm_typeof/* default */.Z)(unit) === ( true ? "undefined" : 0)) {
              unit = '%';
            }

            //Radial Progress Bar
            if ($el.hasClass('uix-progressbar--circle')) {
              $el.find('.uix-progressbar__track').html('<span>' + percent + '<em class="uix-progressbar__unit">' + unit + '</em></span>');
              $el.addClass('uix-progressbar--progress-' + percent);
            }

            //Rectangle Progress Bar
            if ($el.hasClass('uix-progressbar--rectangle')) {
              $el.find('.uix-progressbar__bar > span').html('' + percent + '<em class="uix-progressbar__unit">' + unit + '</em>');
              $el.addClass('uix-progressbar--progress-' + percent);
            }

            //Prevents front-end javascripts that are activated in the background to repeat loading.
            $el.data('activated', 1);
          } //endif actived
        }
      };

      // Add function to the element that should be used as the scrollable area.
      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();
    }); //end each        
  };

  module.components.documentReady.push(module.PROGRESS_BAR.documentReady);
  return /*#__PURE__*/_createClass(function PROGRESS_BAR() {
    _classCallCheck(this, PROGRESS_BAR);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/progress-line/js/index.js


/* 
 *************************************
 * <!-- Progress Line -->
 *************************************
 */


var PROGRESS_LINE = function (module, $, window, document) {
  if (window.PROGRESS_LINE === null) return false;
  module.PROGRESS_LINE = module.PROGRESS_LINE || {};
  module.PROGRESS_LINE.version = '0.0.3';
  module.PROGRESS_LINE.documentReady = function ($) {
    var $obj = $('.uix-progress-line'),
      $progressLineCircle = $obj.find('.uix-progress-line__circle'),
      progressLineRestore = function progressLineRestore() {
        var k = 0;
        var progressLineAnimGo = setInterval(function () {
          $progressLineCircle.eq(k).addClass('is-active');
          $progressLineCircle.eq(k).next('.uix-progress-line__bar').addClass('is-active');
          k++;
          if (k == 10) {
            clearInterval(progressLineAnimGo);
          }
        }, 50);
      };

    //
    $progressLineCircle.on('mouseenter', function () {
      var curIndex = $(this).index() / 2;
      $progressLineCircle.removeClass('is-active');
      $progressLineCircle.next('.uix-progress-line__bar').removeClass('is-active');
      for (var i = curIndex; i >= 0; i--) {
        $progressLineCircle.eq(i).addClass('is-active');
        $progressLineCircle.eq(i).next('.uix-progress-line__bar').addClass('is-active');
      }
    });
    $progressLineCircle.parent().on('mouseleave', function () {
      progressLineRestore();
    });

    //Adapt line width for different resolution
    //		const plLength     = $progressLineCircle.length,
    //			  newPlW       = $obj.find( '.uix-progress-line__circle' ).first().width(),
    //			  plWrapperW   = $obj.width();
    //
    //		$obj.find( '.uix-progress-line__bar' ).css( 'width', parseFloat( plWrapperW - newPlW*plLength )/(plLength-1) + 'px' );
    //		
  };

  module.components.documentReady.push(module.PROGRESS_LINE.documentReady);
  return /*#__PURE__*/_createClass(function PROGRESS_LINE() {
    _classCallCheck(this, PROGRESS_LINE);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/retina/js/index.js


/* 
 *************************************
 * <!-- Retina Graphics for Website -->
 *************************************
 */

var RETINA = function (module, $, window, document) {
  if (window.RETINA === null) return false;
  module.RETINA = module.RETINA || {};
  module.RETINA.version = '0.0.1';
  module.RETINA.documentReady = function ($) {
    //Determine if you have retinal display
    var hasRetina = false,
      rootRetina = typeof exports === 'undefined' ? window : exports,
      mediaQuery = '(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)';
    if (rootRetina.devicePixelRatio > 1 || rootRetina.matchMedia && rootRetina.matchMedia(mediaQuery).matches) {
      hasRetina = true;
    }
    if (hasRetina) {
      //do something
      $('[data-retina]').each(function () {
        $(this).attr({
          'src': $(this).data('retina')
        });
      });
    }
  };
  module.components.documentReady.push(module.RETINA.documentReady);
  return /*#__PURE__*/_createClass(function RETINA() {
    _classCallCheck(this, RETINA);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/rotating-elements/js/index.js



/* 
 *************************************
 * <!-- Rotating Elements -->
 *************************************
 */

var ROTATING_EL = function (module, $, window, document) {
  if (window.ROTATING_EL === null) return false;
  module.ROTATING_EL = module.ROTATING_EL || {};
  module.ROTATING_EL.version = '0.0.2';
  module.ROTATING_EL.documentReady = function ($) {
    $('[data-pointer-to-deg]').each(function () {
      var $this = $(this);
      var config = $this.data('pointer-to-deg');
      if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0)) {
        config = false;
      }
      if (config) {
        if ($(config.target).length == 0) return false;
        var pointer = $(config.target)[0],
          pointerBox = pointer.getBoundingClientRect(),
          centerPoint = window.getComputedStyle(pointer).transformOrigin,
          centers = centerPoint.split(' ');
        var mouseX, mouseY;
        if (config.mouseSpy) {
          $(document).on('mousemove touchstart touchmove', function (e) {
            var pointerEvent = e;
            if (e.targetTouches && e.targetTouches[0]) {
              e.preventDefault();
              pointerEvent = e.targetTouches[0];
              mouseX = pointerEvent.pageX;
              mouseY = pointerEvent.pageY;
            } else {
              mouseX = e.clientX;
              mouseY = e.clientY;
            }
            var centerY = pointerBox.top + parseInt(centers[1]) - window.pageYOffset,
              centerX = pointerBox.left + parseInt(centers[0]) - window.pageXOffset,
              radians = Math.atan2(mouseX - centerX, mouseY - centerY),
              degrees = radians * (180 / Math.PI) * -1 + 180;
            pointer.style.transform = 'rotate(' + degrees + 'deg)';
          });
        }
        $this.off('click').on('click', function (e) {
          e.preventDefault();
          pointer.style.transform = 'rotate(' + config.deg + 'deg)';
        });
      }
    });
  };
  module.components.documentReady.push(module.ROTATING_EL.documentReady);
  return /*#__PURE__*/_createClass(function ROTATING_EL() {
    _classCallCheck(this, ROTATING_EL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/scroll-reveal/js/index.js



/* 
 *************************************
 * <!-- Scroll Reveal -->
 *************************************
 */

var SCROLL_REVEAL = function (module, $, window, document) {
  if (window.SCROLL_REVEAL === null) return false;
  module.SCROLL_REVEAL = module.SCROLL_REVEAL || {};
  module.SCROLL_REVEAL.version = '0.1.6';
  module.SCROLL_REVEAL.documentReady = function ($) {
    //From JSON config in data attribute in HTML
    var $scrollElements = $('[data-uix-anim]');
    $scrollElements.each(function () {
      var viewport;
      var $el = $(this);
      var tl = new TimelineMax({
        paused: true
      });

      //
      var config = $el.data('uix-anim');
      if ((0,esm_typeof/* default */.Z)(config) === ( true ? "undefined" : 0) || config == '' || config === false) {
        config = {
          "from": {
            "opacity": 0,
            "x": 70
          },
          "to": {
            "opacity": 1,
            "x": 0
          },
          "ease": "Power2.easeOut",
          "duration": 0.4,
          "delay": 0,
          "infinite": false,
          "viewport": '100%' //A percentage of the viewport's height.
        };
      }

      //get attributes to tweenMax
      var fromCSS = config.from,
        toCSS = config.to,
        myEase = config.ease,
        myDuration = config.duration,
        myDelay = config.delay,
        infinite = config.infinite;

      //A percentage of the viewport's height.
      viewport = config.viewport;
      if ((0,esm_typeof/* default */.Z)(viewport) === ( true ? "undefined" : 0)) viewport = '100%';
      if ((0,esm_typeof/* default */.Z)(myEase) === ( true ? "undefined" : 0)) myEase = 'Power2.easeOut';
      if ((0,esm_typeof/* default */.Z)(myDelay) === ( true ? "undefined" : 0)) myDelay = 0;
      if ((0,esm_typeof/* default */.Z)(myDuration) === ( true ? "undefined" : 0)) myDuration = 0.4;
      if ((0,esm_typeof/* default */.Z)(infinite) === ( true ? "undefined" : 0)) infinite = false;

      //Conversion between percentage and decimal
      viewport = parseFloat(viewport) / 100.0;

      //Make it go back and forth
      var reverse = infinite ? 1 : 0;

      //Set the initial state of the element
      TweenMax.set($el, {
        css: fromCSS
      });

      //
      var fromIsString = Object.prototype.toString.call(fromCSS) == '[object String]' ? true : false;
      if (fromIsString) {
        toCSS = toCSS.replace(/\./, '');
      } else {
        tl.to($el, myDuration, {
          css: toCSS,
          ease: myEase,
          delay: myDelay
        });
        $el[0].animation = tl;
      }

      //
      var scrollUpdate = function scrollUpdate() {
        var spyTop = $el[0].getBoundingClientRect().top;

        //Prevent asynchronous loading of repeated calls
        var actived = $el.data('activated');
        if (spyTop < window.innerHeight * viewport) {
          if ((0,esm_typeof/* default */.Z)(actived) === ( true ? "undefined" : 0)) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.delay(myDelay * 1000).queue('fx', function () {
                $(this).addClass(toCSS).dequeue();
              });
            } else {
              $el[0].animation.play();

              //Other animation
              //------------------------

              //Image transition
              spyImageTrans('show');
            }

            //Prevents front-end javascripts that are activated in the background to repeat loading.
            $el.data('activated', 1);
          } //endif actived
        } else {
          if ((0,esm_typeof/* default */.Z)(actived) !== ( true ? "undefined" : 0) && reverse === 1) {
            if (fromIsString) {
              //Add class when element becomes visible
              $el.removeClass(toCSS);
            } else {
              $el[0].animation.reverse();

              //Other animation
              //------------------------

              //Image transition
              spyImageTrans('hide');
            }
            $el.removeData('activated');
          } //endif actived
        }
      };

      // Add function to the element that should be used as the scrollable area.
      var throttleFunc = UixThrottle(scrollUpdate, 5);
      window.removeEventListener('scroll', throttleFunc);
      window.removeEventListener('touchmove', throttleFunc);
      window.addEventListener('scroll', throttleFunc);
      window.addEventListener('touchmove', throttleFunc);
      throttleFunc();

      /*
      * The transition effect of each group of images
      *
      * @return {Void}
      * #Usage: 
      <ul data-uix-anim='{"viewport":"90%","from":{"y":0},"to":{"y":0},"ease":"Power2.easeOut","duration":0.8,"delay":0.2,"infinite":true}' data-img-ids='["[data-imgshow]"]'>
      <li data-imgshow="1"><img src="logo-1.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-2.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-3.jpg" alt=""></li>
      <li data-imgshow="1"><img src="logo-4.jpg" alt=""></li>
      <ul>
             */
      function spyImageTrans(type) {
        var _imgIds = $el.data('img-ids');
        if ((0,esm_typeof/* default */.Z)(_imgIds) !== ( true ? "undefined" : 0)) {
          //add
          if (type == 'show') {
            _imgIds.forEach(function (element) {
              $(element).each(function (index) {
                $(this).delay(50 * index).queue('fx', function () {
                  $(this).addClass('is-active');
                  $(this).dequeue();
                });
              });
            });
          } else {
            //remove 
            _imgIds.forEach(function (element) {
              $(element).removeClass('is-active');
            });
          }
        }
      }
    }); //end each        
  };

  module.components.documentReady.push(module.SCROLL_REVEAL.documentReady);
  return /*#__PURE__*/_createClass(function SCROLL_REVEAL() {
    _classCallCheck(this, SCROLL_REVEAL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/scrollspy-animate/js/index.js


/* 
 *************************************
 * <!-- Scrollspy Animate -->
 *************************************
 */

var SCROLLSPY_ANIM = function (module, $, window, document) {
  if (window.SCROLLSPY_ANIM === null) return false;
  module.SCROLLSPY_ANIM = module.SCROLLSPY_ANIM || {};
  module.SCROLLSPY_ANIM.version = '0.0.7';
  module.SCROLLSPY_ANIM.documentReady = function ($) {
    // Remove pixi.js banner from the console
    PIXI.utils.skipHello();
    var $el = $('#scrollspy-animate-demo'),
      panelHeight = 0;

    //Prevent this module from loading in other pages
    if ($el.length == 0) return false;
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var curSprite;
    var filterSprite;

    //-------- Text Affect
    if (Modernizr.webgl) {
      var $txtContainer = $el.find('.row canvas'),
        text = $txtContainer.data('txt').split(''),
        tHeight = 45,
        tWidth = 25,
        renderer = new PIXI.Application({
          width: tWidth * (text.length + 2),
          height: tHeight * 2,
          antialias: true,
          transparent: true,
          resolution: 1,
          autoResize: 1,
          view: document.getElementById('scrollspy-animate-demo--txt')
        });
      var stage = new PIXI.Container();
      filterSprite = PIXI.Sprite.from($txtContainer.data('filter-texture'));
      filterSprite.texture.baseTexture.wrapMode = PIXI.WRAP_MODES.REPEAT;
      var filter = new PIXI.filters.DisplacementFilter(filterSprite);
      var txtStyle = new PIXI.TextStyle({
        fontSize: tHeight,
        letterSpacing: 0,
        breakWords: true,
        dropShadow: true,
        dropShadowAngle: Math.PI / 6,
        dropShadowAlpha: 0.5,
        dropShadowColor: '#333',
        dropShadowBlur: 1,
        fill: 'white',
        fontFamily: 'Arial Black',
        fontStyle: 'normal',
        fontWeight: 'bold',
        wordWrap: false,
        align: 'left'
      });
      curSprite = new PIXI.Text($txtContainer.data('txt'), txtStyle);
      curSprite.x = 0;
      curSprite.y = 0;
      renderer.stage.addChild(curSprite);
      curSprite.anchor.set(0);
      curSprite.scale.set(1);
      filterSprite.anchor.set(0);
      filterSprite.scale.set(0.3);
      filterSprite.x = -50;
      filterSprite.y = 0;
      renderer.stage.filterArea = renderer.screen;
      renderer.stage.addChild(curSprite, filterSprite);
      renderer.stage.filters = [filter];
      var ticker = new PIXI.Ticker();
      ticker.autoStart = true;
      ticker.add(function (delta) {
        filterSprite.y += 0.2 * delta;

        // Render updated scene
        renderer.render(stage);
      });
    }
    function scrollUpdate() {
      var elHeight = $el.height(),
        elOffsetTop = $el.offset().top - panelHeight;
      var scrolled = $(window).scrollTop(),
        translateTitle = scrolled / 2,
        translateBackground = scrolled / 3,
        scale = scrolled / elHeight,
        backgroundScale = 1,
        // + scale / 10
        titleScale = 1 - scale * 0.1,
        titleOpacity = 1 - scale,
        scrollProgress = (scrolled - elOffsetTop) / (elHeight - windowHeight / 6);

      //-------- Animation
      var spyTop = $el[0].getBoundingClientRect().top;
      if (spyTop < window.innerHeight) {
        $el.find('.row').css({
          'transition': 'none',
          'transform': 'translateY(' + translateTitle + 'px) scale(' + titleScale + ')',
          'opacity': titleOpacity
        });
        $('body').removeClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      } else {
        $('body').addClass('js-uix-content-part').removeClass('js-uix-bottom-part');
      }

      //-------- Display progress
      $el.find('.row h3 em').text(scrollProgress.toFixed(2));
      if (Modernizr.webgl) {
        TweenMax.set(filterSprite, {
          x: windowHeight * scrollProgress
        });
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
  };
  module.components.documentReady.push(module.SCROLLSPY_ANIM.documentReady);
  return /*#__PURE__*/_createClass(function SCROLLSPY_ANIM() {
    _classCallCheck(this, SCROLLSPY_ANIM);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/show-more-less/js/index.js


/* 
 *************************************
 * <!-- Show More Less -->
 *************************************
 */


var SHOW_MORELESS = function (module, $, window, document) {
  if (window.SHOW_MORELESS === null) return false;
  module.SHOW_MORELESS = module.SHOW_MORELESS || {};
  module.SHOW_MORELESS.version = '0.0.3';
  module.SHOW_MORELESS.documentReady = function ($) {
    $('.uix-more-btn__link').each(function () {
      var $btn = $(this),
        $con = $btn.parent().prev('.uix-more-btn'),
        $btnTxt = $btn.find('> span'),
        defaultHeight = $con.height();
      $btn.off('click').on('click', function (e) {
        e.preventDefault();
        var expanded = $(this).attr('aria-expanded') == 'true' ? false : true;
        if (expanded) {
          $con.addClass('is-active').attr('aria-expanded', true);
          $(this).addClass('is-active').attr('aria-expanded', true);

          //to open
          // - temporarilty set height:auto
          // - tween from height:0
          TweenMax.set($con, {
            height: 'auto'
          });
          TweenMax.from($con, 0.5, {
            height: defaultHeight
          });

          //change text
          $btnTxt.eq(0).hide();
          $btnTxt.eq(1).show();
        } else {
          $con.removeClass('is-active').attr('aria-expanded', false);
          $(this).removeClass('is-active').attr('aria-expanded', false);

          //to close
          TweenMax.to($con, 0.5, {
            height: defaultHeight
          });

          //change text
          $btnTxt.eq(0).show();
          $btnTxt.eq(1).hide();
        }
      });
    });
  };
  module.components.documentReady.push(module.SHOW_MORELESS.documentReady);
  return /*#__PURE__*/_createClass(function SHOW_MORELESS() {
    _classCallCheck(this, SHOW_MORELESS);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/skew-on-scroll/js/index.js


/* 
 *************************************
 * <!-- Skew Based On Velocity of Scroll -->
 *************************************
 */

var SKEW_ON_SCROLL = function (module, $, window, document) {
  if (window.SKEW_ON_SCROLL === null) return false;
  module.SKEW_ON_SCROLL = module.SKEW_ON_SCROLL || {};
  module.SKEW_ON_SCROLL.version = '0.0.1';
  module.SKEW_ON_SCROLL.documentReady = function ($) {
    $('.uix-skewscroll-container').each(function () {
      var $this = $(this),
        $animObj = $this.find('p'),
        ease = 0.15;
      var followY = 0;
      TweenMax.set($animObj, {
        transformOrigin: "center left"
      });
      TweenMax.ticker.addEventListener('tick', function () {
        followY += (window.scrollY - followY) * ease;
        var dy = (window.scrollY - followY) / 20;
        dy = Math.min(Math.max(dy, -15), 15);
        TweenLite.set($animObj, {
          skewY: dy
        });
      });
    });
  };
  module.components.documentReady.push(module.SKEW_ON_SCROLL.documentReady);
  return /*#__PURE__*/_createClass(function SKEW_ON_SCROLL() {
    _classCallCheck(this, SKEW_ON_SCROLL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/smooth-scrolling-anchor-link/js/index.js


/* 
 *************************************
 * <!-- Smooth Scrolling When Clicking An Anchor Link -->
 *************************************
 */


var SMOOTH_SCROLLING_ANCHORLINK = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_ANCHORLINK === null) return false;
  module.SMOOTH_SCROLLING_ANCHORLINK = module.SMOOTH_SCROLLING_ANCHORLINK || {};
  module.SMOOTH_SCROLLING_ANCHORLINK.version = '0.0.8';
  module.SMOOTH_SCROLLING_ANCHORLINK.documentReady = function ($) {
    //Prevent this module from loading in other pages
    if ($('body').hasClass('onepage')) return false;
    var browserURL = window.location.href;

    //Prevent anchor behaviour
    //Do not add off() to this
    $('a').on('click', function (e) {
      if ($(this).data('smooth-scrolling') != false) {
        var linkURL = $(this).attr('href'),
          locIndex,
          locURL;
        if (linkURL.indexOf('#') >= 0 && linkURL != '#') {
          e.preventDefault();
          var locArr = linkURL.split('#');
          locIndex = locArr[1];
          locURL = locArr[0];
          if (browserURL.indexOf(locURL) < 0) {
            window.location.href = locURL + '#!!' + locIndex;
          }
        }
      }
    });

    //Page automatically slide to jump to the corresponding position
    if (browserURL.indexOf('#!!') >= 0) {
      var curndex = browserURL.split('#!!'),
        $target = $('#' + curndex[1]);

      //Smooth scrolling
      if ($target.length) {
        TweenMax.to(window, 0.5, {
          scrollTo: {
            y: $target.offset().top,
            autoKill: false
          },
          ease: Power2.easeOut,
          onComplete: function onComplete() {
            //Fixed an error that offset().top returns wrong value
            var spyTop = $target[0].getBoundingClientRect().top;
            if (spyTop < 0 || spyTop > 30) {
              $('a[href*="#' + curndex[1] + '"]').trigger('click');
            }
          }
        });
      }
    }

    //Hyperlink click event
    //Do not add off() to this
    $('a[href*="#"]').on('click', function (e) {
      if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname && $(this).attr('href') != '#' & $(this).attr('href').indexOf('#?') < 0) {
        // Figure out element to scroll to
        var target = $(this.hash);
        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
        // Does a scroll target exist?
        if (target.length) {
          // Only prevent default if animation is actually gonna happen
          e.preventDefault();
          TweenMax.to(window, 0.5, {
            scrollTo: {
              y: target.offset().top,
              autoKill: false
            },
            ease: Power2.easeOut,
            onComplete: function onComplete() {
              // Callback after animation
              // Must change focus!
              var $target = $(target);
              $target.focus();
              if ($target.is(':focus')) {
                // Checking if the target was focused
                return false;
              } else {
                $target.attr('tabindex', '-1'); // Adding tabindex for elements not focusable
                $target.focus();
              }
            }
          });
        }
      }
    });
  };
  module.components.documentReady.push(module.SMOOTH_SCROLLING_ANCHORLINK.documentReady);
  return /*#__PURE__*/_createClass(function SMOOTH_SCROLLING_ANCHORLINK() {
    _classCallCheck(this, SMOOTH_SCROLLING_ANCHORLINK);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/smooth-scrolling-page/js/index.js


/* 
 *************************************
 * <!-- Smooth Scrolling Page -->
 *************************************
 */

var SMOOTH_SCROLLING_PAGE = function (module, $, window, document) {
  if (window.SMOOTH_SCROLLING_PAGE === null) return false;
  module.SMOOTH_SCROLLING_PAGE = module.SMOOTH_SCROLLING_PAGE || {};
  module.SMOOTH_SCROLLING_PAGE.version = '0.1.4';
  module.SMOOTH_SCROLLING_PAGE.pageLoaded = function () {
    //Prevent this module from loading in other pages
    //--------------
    if (!$('body').hasClass('smooth-scrolling-page')) return false;

    // Core params
    //--------------
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var html = document.documentElement,
      body = document.body,
      scroller = {
        target: '#uix-scrollspy-area',
        ease: 0.05,
        // <= scroll speed
        endY: 0,
        y: 0,
        resizeRequest: 1,
        scrollRequest: 0
      };
    var requestId = null;
    var lastScrollTop = 0; // Determine the direction of scrolling

    TweenMax.set(scroller.target, {
      rotation: 0.01,
      force3D: true
    });

    //Increase the viewport to display the visual area
    var elTop = $(scroller.target).offset().top;

    // Scrolling Progress
    //--------------
    var tlTarget1 = '#app-scrolling-progress1';
    var tlTarget2 = '#app-scrolling-progress2';
    var tlTarget3 = '#app-scrolling-progress3';
    TweenMax.set(tlTarget1, {
      toAlpha: 1
    });

    // time should be adjusted relative to window width or height
    // Animation progress has nothing to do with time

    //
    //
    var time = 10;
    var time02 = 2;
    var timestop01 = time / 9.9999;
    var timestop02 = time / 8.1;
    var tlAction = new TimelineMax({
      paused: true
    }).to(tlTarget1, time, {
      height: $(scroller.target).height() - windowHeight * 2 - 200
    }).to(tlTarget1, time02, {
      height: $(scroller.target).height() - windowHeight * 2
    }).to(tlTarget1, time, {
      width: 15
    }, 0).to(tlTarget2, 0.3, {
      rotation: -10,
      scale: 0.5,
      transformOrigin: 'center'
    }, timestop01).to(tlTarget3, 0.3, {
      rotation: 1125,
      scale: 0.1,
      transformOrigin: 'center'
    }, timestop02);

    //
    //
    var scene2_progress = 0;
    var scene2Action = new TimelineMax({
      paused: true
    }).to('#app-scene-2 p', 0.3, {
      x: 100
    }, 0);

    //
    //
    var scene3_progress = 0;
    var scene3Action = new TimelineMax({
      paused: true
    }).to('#app-scene-3 p', 0.3, {
      x: 200
    }, 0);

    // Core Actions
    //--------------

    var initSmoothScrollingPageWrapper = 'js-uix-smooth-scrolling-page-wrapper';
    if (!$('body').hasClass(initSmoothScrollingPageWrapper)) {
      $('body').addClass(initSmoothScrollingPageWrapper);
      $(scroller.target).wrap('<div id="uix-scrollspy-area__wrapper" style="overflow:hidden;position:fixed;height:100%;width:100%;top:0;left:0;right:0;bottom:0;"></div>').css('margin-top', elTop + 'px');
    }
    function scrollAnimate() {
      var resized = scroller.resizeRequest > 0;
      if (resized) {
        var height = $(scroller.target).height();
        body.style.height = parseFloat(height + elTop) + "px";
        scroller.resizeRequest = 0;
      }
      var scrollY = window.pageYOffset || html.scrollTop || body.scrollTop || 0;
      scroller.endY = scrollY;
      scroller.y += (scrollY - scroller.y) * scroller.ease;
      if (Math.abs(scrollY - scroller.y) < 0.05 || resized) {
        scroller.y = scrollY;
        scroller.scrollRequest = 0;
      }
      TweenMax.set(scroller.target, {
        y: -scroller.y,
        onComplete: function onComplete() {

          //-----Spy scrollTop and elements of page

          //your code here...
        }
      });

      // update requestId
      requestId = scroller.scrollRequest > 0 ? requestAnimationFrame(scrollAnimate) : null;

      //+++++++++++++++++++++++++++++++++++++++++++++++++
      // Custom Functions
      //+++++++++++++++++++++++++++++++++++++++++++++++++
      var scrolled = scroller.y,
        topSpacing = window.innerWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin 

      //----------------------------------------------------------------------------------
      //--------------------------------- Scrollspy Animate -------------------------------	
      //----------------------------------------------------------------------------------   

      // Parallax 
      //-------------------------------------	
      $('.uix-scrollspy-animate--parallax__wrapper').each(function () {
        var $wrapper = $(this);
        var $target = $wrapper.find('.uix-scrollspy-animate--parallax');
        var rect = $target[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($wrapper.data('scrollspy-speed'));

        //
        $wrapper.css({
          'overflow': 'hidden',
          'height': rect.height - rect.height * 0.3
        });
        $target.css({
          'margin-top': -rect.height * 0.15
        });

        //
        TweenMax.set($wrapper, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * speed) + ')',
            'transition': 'none'
          }
        });
        TweenMax.set($target, {
          css: {
            'transform': 'matrix(1, 0, 0, 1, 0, ' + (0 - spyTop * (speed / 2)) + ')',
            'transition': 'none'
          }
        });
      });

      // Transparency
      //-------------------------------------	
      $('.uix-scrollspy-animate--transparency').each(function () {
        var $this = $(this);
        var rect = $this[0].getBoundingClientRect();
        var spyTop = rect.top;
        var speed = -parseFloat($this.data('scrollspy-speed'));
        var scale = (0 - spyTop * speed) / rect.height,
          elOpacity = scale;
        TweenMax.set($this, {
          alpha: $this.data('scrollspy-reverse') ? 1 - elOpacity : elOpacity
        });
      });

      //----------------------------------------------------------------------------------
      //--------------------------------- Scrolling Progress -------------------------------	
      //----------------------------------------------------------------------------------   

      var scrollDistance = $(scroller.target).height(),
        visibleAreaDistance = windowHeight,
        scrollPercent = scrolled / (scrollDistance - visibleAreaDistance);

      //
      console.log('Body progress: ' + scrollPercent);
      var progressBlobs = scrollPercent * 1; // slower (= <) or faster and/or change height of 'scrollDistance'
      var scrollDir = scrolled > lastScrollTop ? 'down' : 'up';
      TweenMax.to(tlAction, 1, {
        progress: progressBlobs,
        ease: Sine.easeOut
      });

      //----------------------------------------------------------------------------------
      //---------------------- SCROLLING PROGRESS HELPER ----------------------------------	
      //----------------------------------------------------------------------------------   
      var triggerViewport = 0.5;

      //Scene 2 progress
      //-----------------
      var scene2_height = $('#app-scene-2').outerHeight(true),
        // do not use .height()
        scene2_spyTop = $('#app-scene-2')[0].getBoundingClientRect().top;
      var scene2_scrollPercent = parseFloat(scene2_spyTop / scene2_height) - triggerViewport;
      if (scene2_scrollPercent <= 0 && scene2_scrollPercent >= -1) {
        console.log('Scene 2 progress: ' + Math.abs(scene2_scrollPercent));
        scene2_progress = Math.abs(scene2_scrollPercent);
      }
      TweenMax.to(scene2Action, 1, {
        progress: scene2_progress
      });

      //Scene 3 progress
      //-----------------
      var scene3_height = $('#app-scene-3').outerHeight(true),
        // do not use .height()
        scene3_spyTop = $('#app-scene-3')[0].getBoundingClientRect().top;
      var scene3_scrollPercent = parseFloat(scene3_spyTop / scene3_height) - triggerViewport;
      if (scene3_scrollPercent <= 0 && scene3_scrollPercent >= -1) {
        console.log('Scene 3 progress: ' + Math.abs(scene3_scrollPercent));
        scene3_progress = Math.abs(scene3_scrollPercent);
      }
      TweenMax.to(scene3Action, 1, {
        progress: scene3_progress
      });

      //----------------------------------------------------------------------------------
      //---------------------------------------------------------------------------------	
      //----------------------------------------------------------------------------------  

      //
      lastScrollTop = scrolled;
    } //end scrollAnimate()

    function scrollUpdate() {
      scroller.scrollRequest++;
      if (!requestId) {
        requestId = requestAnimationFrame(scrollAnimate);
      }
    }

    // Add function to the element that should be used as the scrollable area.
    var throttleFunc = UixThrottle(scrollUpdate, 5);
    window.removeEventListener('scroll', throttleFunc);
    window.removeEventListener('touchmove', throttleFunc);
    window.addEventListener('scroll', throttleFunc);
    window.addEventListener('touchmove', throttleFunc);
    throttleFunc();
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        scroller.resizeRequest++;
        if (!requestId) {
          requestId = requestAnimationFrame(scrollAnimate);
        }
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);
  };
  module.components.pageLoaded.push(module.SMOOTH_SCROLLING_PAGE.pageLoaded);
  return /*#__PURE__*/_createClass(function SMOOTH_SCROLLING_PAGE() {
    _classCallCheck(this, SMOOTH_SCROLLING_PAGE);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/sticky-elements/js/index.js



/* 
 *************************************
 *  <!-- Sticky Elements -->
 *************************************
 */



var STICKY_EL = function (module, $, window, document) {
  if (window.STICKY_EL === null) return false;
  module.STICKY_EL = module.STICKY_EL || {};
  module.STICKY_EL.version = '0.0.8';
  module.STICKY_EL.pageLoaded = function () {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var topSpacing = windowWidth <= 768 ? 0 : $('.uix-header__container').outerHeight(true); //with margin

    //prepend a placeholder
    $('.js-uix-sticky-el').each(function () {
      var $el = $(this),
        elHeight = $el.outerHeight(true),
        //with margin
        elClass = $el.attr('class').replace('js-uix-sticky-el', ''),
        tempID = 'sticky-' + UixGUID.create();
      $el.attr('data-sticky-id', tempID);
      if (!$el.hasClass('is-placeholder')) {
        $('<div class="' + elClass + ' is-placeholder"></div>').css({
          'height': elHeight + 'px',
          'width': '100%',
          'display': 'none',
          'visibility': 'hidden'
        }).attr('data-sticky-id', tempID).insertBefore($el);
      }
    });

    //  Initialize
    stickyInit(windowWidth);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        stickyInit(windowWidth);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize Sticky Elements settings
     *
     * @param  {Number} w         - Returns width of browser viewport
     * @return {Void}
     */
    function stickyInit(w) {
      if (w > 768) {
        $('.js-uix-sticky-el').each(function () {
          var $el = $(this),
            elTop = $el.offset().top,
            oWidth = $el.width(),
            clsID = $el.data('sticky-id'),
            $ph = $('[data-sticky-id="' + clsID + '"].is-placeholder');
          function scrollUpdate() {
            var scrolled = $(window).scrollTop(),
              spyTop = parseFloat(scrolled + window.innerHeight);

            //------
            if (parseFloat(scrolled + topSpacing) > elTop) {
              $el.addClass('is-active').css({
                'width': oWidth + 'px',
                'top': topSpacing + 'px'
              });
              $ph.css('display', 'block');
            } else {
              $el.removeClass('is-active').css({
                'top': 0
              });
              $ph.css('display', 'none');
            }

            //------
            if ((0,esm_typeof/* default */.Z)($el.data('stop-trigger')) != ( true ? "undefined" : 0) && $($el.data('stop-trigger')).length > 0) {
              var diff = (0,esm_typeof/* default */.Z)($el.data('stop-trigger-diff')) != ( true ? "undefined" : 0) && $el.data('stop-trigger-diff').length > 0 ? UixMath.evaluate($el.data('stop-trigger-diff').replace(/\s/g, '').replace(/\%\h/g, windowHeight).replace(/\%\w/g, windowWidth)) : 0,
                targetTop = $($el.data('stop-trigger')).offset().top - diff;

              //Detecting when user scrolls to bottom of div
              if (spyTop >= targetTop) {
                $el.css({
                  'top': parseFloat(topSpacing - (spyTop - targetTop)) + 'px'
                });
              } else {
                if ($el.length > 0 && $el.position().top < topSpacing) {
                  $el.css({
                    'top': topSpacing + 'px'
                  });
                }
              }
            }
          }

          // Add function to the element that should be used as the scrollable area.
          var throttleFunc = UixThrottle(scrollUpdate, 5);
          window.removeEventListener('scroll', throttleFunc);
          window.removeEventListener('touchmove', throttleFunc);
          window.addEventListener('scroll', throttleFunc);
          window.addEventListener('touchmove', throttleFunc);
          throttleFunc();
        }); //endif $( '.js-uix-sticky-el' )
      } else {
        $('.js-uix-sticky-el').removeClass('is-active');
        $('[data-sticky-id].is-placeholder').css('display', 'none');
      } // endif w > 768
    }
  };

  module.components.pageLoaded.push(module.STICKY_EL.pageLoaded);
  return /*#__PURE__*/_createClass(function STICKY_EL() {
    _classCallCheck(this, STICKY_EL);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-map/js/china.js


/* 
 *************************************
 * <!-- SVG Map (China) -->
 *************************************
 */


var SVG_MAP_CHINA = function (module, $, window, document) {
  if (window.SVG_MAP_CHINA === null) return false;
  module.SVG_MAP_CHINA = module.SVG_MAP_CHINA || {};
  module.SVG_MAP_CHINA.version = '0.0.2';
  module.SVG_MAP_CHINA.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--china');
    $(document).off('click.SVG_MAP_CHINA').on('click.SVG_MAP_CHINA', '.uix-svgmap--china__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
        goText = $(this).text();
      var svgCurName = '',
        svgNameIndex = 0;
      $('.uix-svgmap--china .uix-svgmap--china__name').each(function () {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          return false;
        }
      });
      svgNameIndex = $('.uix-svgmap--china .uix-svgmap--china__name[data-title="' + svgCurName + '"]').index();

      //Hide all elements
      svgMapRestore(1);

      //Display current element
      svgMapActive(svgNameIndex, goText);
    });

    //Restore all elements
    //Do not add off() to this
    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });
    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('circle').css({
        'r': 6,
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--china__name').each(function () {
        $(this).css({
          'transform': 'translate(0,15px)',
          'z-index': 1,
          'opacity': alpha
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--china__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }
    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('circle').eq(index).css({
          'r': 15,
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--china__name').eq(index).css({
          'transform': 'translate(0,25px)',
          'z-index': 2,
          'opacity': 1
        }).text(text);
        $(this).find('.uix-svgmap--china__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };
  module.components.documentReady.push(module.SVG_MAP_CHINA.documentReady);
  return /*#__PURE__*/_createClass(function SVG_MAP_CHINA() {
    _classCallCheck(this, SVG_MAP_CHINA);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-map/js/world.js


/* 
 *************************************
 * <!-- SVG Map (World) -->
 *************************************
 */


var SVG_MAP_WORLD = function (module, $, window, document) {
  if (window.SVG_MAP_WORLD === null) return false;
  module.SVG_MAP_WORLD = module.SVG_MAP_WORLD || {};
  module.SVG_MAP_WORLD.version = '0.0.2';
  module.SVG_MAP_WORLD.documentReady = function ($) {
    var $svgEl = $('.uix-svgmap--world');
    $(document).off('click.SVG_MAP_WORLD').on('click.SVG_MAP_WORLD', '.uix-svgmap--world__trigger a', function (e) {
      // stop propagation of this event, it will never reach body in bubbling phase.
      e.stopPropagation();
      var goName = $(this).data('title'),
        goText = $(this).text();
      var svgCurName = '',
        svgNameIndex = 0;
      $('.uix-svgmap--world .uix-svgmap--world__name').each(function (index) {
        if (goName == $(this).data('title')) {
          svgCurName = $(this).data('title');
          svgNameIndex = index;
          return false;
        }
      });

      //Hide all elements
      svgMapRestore(1);

      //Display current element
      svgMapActive(svgNameIndex, goText);
    });

    //Restore all elements
    //Do not add off() to this
    $(document.body).on('click', function (e) {
      svgMapRestore(2);
    });
    function svgMapRestore(type) {
      var alpha = type == 1 ? 0.3 : 1;
      $svgEl.children().removeClass('is-show');
      $svgEl.find('path').css({
        'z-index': 1,
        'opacity': alpha
      });
      $svgEl.find('.uix-svgmap--world__name').each(function () {
        $(this).css({
          'z-index': 1,
          'opacity': alpha,
          'font-size': '3px'
        }).text($(this).data('title'));
      });
      $svgEl.find('.uix-svgmap--world__num').css({
        'font-size': '6px',
        'z-index': 1,
        'opacity': alpha
      });
    }
    function svgMapActive(index, text) {
      $svgEl.each(function () {
        $(this).children().eq(index).addClass('is-show');
        $(this).find('path').eq(index).css({
          'z-index': 2,
          'opacity': 1
        });
        $(this).find('.uix-svgmap--world__name').eq(index).css({
          'z-index': 2,
          'opacity': 1,
          'font-size': '10px'
        }).text(text);
        $(this).find('.uix-svgmap--world__num').eq(index).css({
          'font-size': '10px',
          'z-index': 2,
          'opacity': 1
        });
      });
    }
  };
  module.components.documentReady.push(module.SVG_MAP_WORLD.documentReady);
  return /*#__PURE__*/_createClass(function SVG_MAP_WORLD() {
    _classCallCheck(this, SVG_MAP_WORLD);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./src/components/svg-mask-slider/js/index.js



/* 
 *************************************
 * <!-- SVG Mask Slider -->
 *************************************
 */


var SVG_MASK_SLIDER = function (module, $, window, document) {
  if (window.SVG_MASK_SLIDER === null) return false;
  module.SVG_MASK_SLIDER = module.SVG_MASK_SLIDER || {};
  module.SVG_MASK_SLIDER.version = '0.0.5';
  module.SVG_MASK_SLIDER.pageLoaded = function () {
    var windowWidth = window.innerWidth,
      windowHeight = window.innerHeight;
    var animDelay = 0;
    var animSpeed = 1000;
    var $sliderWrapper = $('.uix-svgMask-slider');
    var svgAnimating = false;

    //
    sliderInit(false);
    function windowUpdate() {
      // Check window width has actually changed and it's not just iOS triggering a resize event on scroll
      if (window.innerWidth != windowWidth) {
        // Update the window width for next time
        windowWidth = window.innerWidth;

        // Do stuff here
        sliderInit(true);
      }
    }

    // Add function to the window that should be resized
    var debounceFuncWindow = UixDebounce(windowUpdate, 50);
    window.removeEventListener('resize', debounceFuncWindow);
    window.addEventListener('resize', debounceFuncWindow);

    /*
     * Initialize slideshow
     *
     * @param  {Boolean} resize            - Determine whether the window size changes.
     * @return {Void}
     */
    function sliderInit(resize) {
      $sliderWrapper.each(function () {
        var $this = $(this);
        var $items = $this.find('.uix-svgMask-slider__item'),
          $first = $items.first(),
          activated = $this.data('activated');
        var nativeItemW, nativeItemH;
        if ((0,esm_typeof/* default */.Z)(activated) === ( true ? "undefined" : 0) || activated === 0) {
          //Get parameter configuration from the data-* attribute of HTML
          var dataControlsPagination = $this.data('controls-pagination'),
            dataControlsArrows = $this.data('controls-arrows'),
            dataDraggable = $this.data('draggable'),
            dataDraggableCursor = $this.data('draggable-cursor'),
            dataCountTotal = $this.data('count-total'),
            dataCountCur = $this.data('count-now'),
            dataSpeed = $this.data('speed');
          if ((0,esm_typeof/* default */.Z)(dataControlsPagination) === ( true ? "undefined" : 0)) dataControlsPagination = '.uix-svgMask-slider__pagination';
          if ((0,esm_typeof/* default */.Z)(dataControlsArrows) === ( true ? "undefined" : 0) || dataControlsArrows == false) dataControlsArrows = '.uix-svgMask-slider__arrows';
          if ((0,esm_typeof/* default */.Z)(dataDraggable) === ( true ? "undefined" : 0)) dataDraggable = false;
          if ((0,esm_typeof/* default */.Z)(dataDraggableCursor) === ( true ? "undefined" : 0) || dataDraggableCursor == false) dataDraggableCursor = 'move';
          if ((0,esm_typeof/* default */.Z)(dataCountTotal) === ( true ? "undefined" : 0)) dataCountTotal = 'p.count em.count';
          if ((0,esm_typeof/* default */.Z)(dataCountCur) === ( true ? "undefined" : 0)) dataCountCur = 'p.count em.current';

          //Autoplay parameters
          var dataAuto = $this.data('auto'),
            dataTiming = $this.data('timing'),
            dataLoop = $this.data('loop');
          if ((0,esm_typeof/* default */.Z)(dataAuto) === ( true ? "undefined" : 0)) dataAuto = false;
          if ((0,esm_typeof/* default */.Z)(dataTiming) === ( true ? "undefined" : 0)) dataTiming = 10000;
          if ((0,esm_typeof/* default */.Z)(dataLoop) === ( true ? "undefined" : 0)) dataLoop = false;

          //Autoplay times
          var playTimes;
          //A function called "timer" once every second (like a digital watch).
          $this[0].animatedSlides;

          //Get the animation speed
          //-------------------------------------	
          if ((0,esm_typeof/* default */.Z)(dataSpeed) != ( true ? "undefined" : 0) && dataSpeed != false) {
            animSpeed = dataSpeed;
          }

          //Get the duration of the animation
          //-------------------------------------	
          animDelay = animSpeed;

          //Get timeline elements
          //-------------------------------------	
          var txtTimeline = new TimelineMax({
            delay: 0
          });
          var txtMaskTimeline = new TimelineMax({
            delay: 0
          });
          txtTimeline.to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 0
          }).to($items.find('svg image'), 0.2, {
            scale: 1.1
          }, '-=0.1').to($this.find('.uix-svgMask-slider__inner'), 0.9, {
            ease: Circ.easeOut,
            scale: 0.85
          }, '-=0.2').to($this.find('.uix-svgMask-slider__inner'), 0.75, {
            ease: Elastic.easeOut.config(4, 1.5),
            scale: 1
          }).pause();
          txtMaskTimeline.to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: 0
            }
          }).to($items.find('.uix-svgMask-slider__txt__content'), 0.1, {
            opacity: 1
          }, "-=0.1").to($items.find('svg image'), 0.2, {
            scale: 1
          }, '-=0.1').to($items.find('.uix-svgMask-slider__txt__mask'), 0.6, {
            css: {
              marginLeft: '-100vw'
            }
          });

          //Initialize the properties of each Item
          //-------------------------------------	
          $items.each(function (index) {
            var _id = UixGUID.create();
            var _item = $(this);
            _item.find('clipPath').attr('id', _id + '-img');
            _item.find('image').attr('clip-path', 'url(#' + _id + '-img)');
            _item.delay(animDelay * index).queue('fx', function () {
              $(this).addClass('is-loaded').dequeue();
            });
          });

          //Initialize the first item container
          //-------------------------------------		
          $items.addClass('next');
          setTimeout(function () {
            $first.addClass('is-active');
          }, animDelay);

          //
          var imgURL = $first.find('img').attr('src');
          if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
            var img = new Image();
            img.onload = function () {
              $this.css('height', $this.width() * (this.height / this.width) + 'px');
              nativeItemW = this.width;
              nativeItemH = this.height;

              //Initialize all the items to the stage
              addItemsToStage($this, nativeItemW, nativeItemH, dataControlsPagination, dataControlsArrows, dataLoop, dataDraggable, dataDraggableCursor, dataCountTotal, dataCountCur, txtTimeline, txtMaskTimeline);
            };
            img.src = imgURL;
          }

          //Autoplay Slider
          //-------------------------------------		
          if (!resize) {
            if (dataAuto && !isNaN(parseFloat(dataTiming)) && isFinite(dataTiming)) {
              sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              var autoplayEnter = function autoplayEnter() {
                clearInterval($this[0].animatedSlides);
              };
              var autoplayLeave = function autoplayLeave() {
                sliderAutoPlay(playTimes, dataTiming, dataLoop, $this, dataCountTotal, dataCountCur, dataControlsPagination, dataControlsArrows);
              };

              // Do not use the `off()` method, otherwise it will cause the second mouseenter to be invalid
              $this.on('mouseenter', autoplayEnter);
              $this.on('mouseleave', autoplayLeave);

              // To determine if it is a touch screen.
              if (Modernizr.touchevents) {
                $this.on('pointerenter', autoplayEnter);
                $this.on('pointerleave', autoplayLeave);
              }
            }
          }

          //Prevents front-end javascripts that are activated with AJAX to repeat loading.
          $this.data('activated', 1);
        } //endif activated
      });
    }

    /*
    * Trigger slider autoplay
    *
    * @param  {Function} playTimes            - Number of times.
    * @param  {Number} timing                 - Autoplay interval.
    * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
    * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
    * @return {Void}                          - The constructor.
    */
    function sliderAutoPlay(playTimes, timing, loop, slider, countTotalID, countCurID, paginationID, arrowsID) {
      var items = slider.find('.uix-svgMask-slider__item'),
        total = items.length;
      slider[0].animatedSlides = setInterval(function () {
        playTimes = parseFloat(items.filter('.is-active').index());
        playTimes++;
        if (!loop) {
          if (playTimes < total && playTimes >= 0) sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        } else {
          if (playTimes == total) playTimes = 0;
          if (playTimes < 0) playTimes = total - 1;
          sliderUpdates(playTimes, slider, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
        }
      }, timing);
    }

    /*
    * Initialize all the items to the stage
    *
    * @param  {Element} slider                 - Current selector of each slider.
    * @param  {Number} nativeItemW            - Returns the intrinsic width of the image.
    * @param  {Number} nativeItemH            - Returns the intrinsic height of the image.
     * @param  {String} paginationID           - Navigation ID for paging control of each slide.
     * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
     * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop. 
     * @param  {Boolean} draggable             - Allow drag and drop on the slider.
     * @param  {String} draggableCursor        - Drag & Drop Change icon/cursor while dragging.
     * @param  {String} countTotalID           - Total number ID or class of counter.
     * @param  {String} countCurID             - Current number ID or class of counter.
     * @param  {Function} tl1                  - Timeline animation of text field.
     * @param  {Function} tl2                  - Timeline animation of text mask field.
    * @return {Void}
    */
    function addItemsToStage(slider, nativeItemW, nativeItemH, paginationID, arrowsID, loop, draggable, draggableCursor, countTotalID, countCurID, tl1, tl2) {
      var $this = slider,
        $items = $this.find('.uix-svgMask-slider__item'),
        $first = $items.first(),
        itemsTotal = $items.length;

      //If arrows does not exist on the page, it will be added by default, 
      //and the drag and drop function will be activated.
      if ($(arrowsID).length == 0) {
        $('body').prepend('<div style="display:none;" class="uix-svgMask-slider__arrows ' + arrowsID.replace('#', '').replace('.', '') + '"><a href="#" class="uix-svgMask-slider__arrows--prev"></a><a href="#" class="uix-svgMask-slider__arrows--next"></a></div>');
      }

      //Add identifiers for the first and last items
      $items.last().addClass('last');
      $items.first().addClass('first');

      //Prevent bubbling
      if (itemsTotal == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
      }

      //Pagination dots 
      //-------------------------------------	
      var _dot = '',
        _dotActive = '';
      _dot += '<ul>';
      for (var i = 0; i < itemsTotal; i++) {
        _dotActive = i == 0 ? 'class="is-active"' : '';
        _dot += '<li><a ' + _dotActive + ' data-index="' + i + '" href="javascript:"></a></li>';
      }
      _dot += '</ul>';
      if ($(paginationID).html() == '') $(paginationID).html(_dot);
      $(paginationID).find('li a').off('click').on('click', function (e) {
        e.preventDefault();
        if (svgAnimating) return false;

        //Prevent buttons' events from firing multiple times
        var $btn = $(this);
        if ($btn.attr('aria-disabled') == 'true') return false;
        $(paginationID).find('li a').attr('aria-disabled', 'true');
        $(paginationID).find('li a').delay(animDelay).queue(function (next) {
          $(paginationID).find('li a').attr('aria-disabled', 'false');
          next();
        });

        //
        if (!$(this).hasClass('is-active')) {
          //Text animation from timeline
          tl1.restart();
          setTimeout(function () {
            tl2.restart();
          }, 1500);

          //Determine the direction
          var curDir = 'prev';
          if ($(this).attr('data-index') > parseFloat($items.filter('.is-active').index())) {
            curDir = 'next';
          }
          sliderUpdates($(this).attr('data-index'), $this, curDir, countTotalID, countCurID, paginationID, arrowsID, loop);

          //Pause the auto play event
          clearInterval($this[0].animatedSlides);
        }
      });

      //Next/Prev buttons
      //-------------------------------------		
      var _prev = $(arrowsID).find('.uix-svgMask-slider__arrows--prev'),
        _next = $(arrowsID).find('.uix-svgMask-slider__arrows--next');
      $(arrowsID).find('a').attr('href', 'javascript:');
      $(arrowsID).find('a').removeClass('is-disabled');
      if (!loop) {
        _prev.addClass('is-disabled');
      }
      _prev.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        prevMove();
      });
      _next.off('click').on('click', function (e) {
        e.preventDefault();

        //Pause the auto play event
        clearInterval($this[0].animatedSlides);

        //Move animation
        nextMove();
      });
      function prevMove() {
        if (svgAnimating) return false;

        //Prevent buttons' events from firing multiple times
        if (_prev.attr('aria-disabled') == 'true') return false;
        _prev.attr('aria-disabled', 'true');
        _prev.delay(animDelay).queue(function (next) {
          _prev.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_prev.hasClass('is-disabled')) return false;

        //Text animation from timeline
        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500);

        //
        sliderUpdates(parseFloat($items.filter('.is-active').index()) - 1, $this, 'prev', countTotalID, countCurID, paginationID, arrowsID, loop);
      }
      function nextMove() {
        if (svgAnimating) return false;

        //Prevent buttons' events from firing multiple times
        if (_next.attr('aria-disabled') == 'true') return false;
        _next.attr('aria-disabled', 'true');
        _next.delay(animDelay).queue(function (next) {
          _next.attr('aria-disabled', 'false');
          next();
        });

        //
        if (_next.hasClass('is-disabled')) return false;

        //Text animation from timeline
        tl1.restart();
        setTimeout(function () {
          tl2.restart();
        }, 1500);

        //
        sliderUpdates(parseFloat($items.filter('.is-active').index()) + 1, $this, 'next', countTotalID, countCurID, paginationID, arrowsID, loop);
      }

      //Added touch method to mobile device and desktop
      //-------------------------------------	
      var $dragTrigger = $this.find('.uix-svgMask-slider__inner');
      var mouseX, mouseY;
      var isMoving = false;

      //Avoid images causing mouseup to fail
      $dragTrigger.find('img').css({
        'pointer-events': 'none',
        'user-select': 'none'
      });

      //Make the cursor a move icon when a user hovers over an item
      if (draggable && draggableCursor != '' && draggableCursor != false) $dragTrigger.css('cursor', draggableCursor);

      //draggable for touch devices
      if (Modernizr.touchevents) draggable = true;
      if (draggable) {
        $dragTrigger[0].removeEventListener('mousedown', dragStart);
        document.removeEventListener('mouseup', dragEnd);
        $dragTrigger[0].removeEventListener('touchstart', dragStart);
        document.removeEventListener('touchend', dragEnd);

        //
        $dragTrigger[0].addEventListener('mousedown', dragStart);
        $dragTrigger[0].addEventListener('touchstart', dragStart);
      }
      function dragStart(e) {
        //Do not use "e.preventDefault()" to avoid prevention page scroll on drag in IOS and Android
        var touches = e.touches;
        if (touches && touches.length) {
          mouseX = touches[0].clientX;
          mouseY = touches[0].clientY;
        } else {
          mouseX = e.clientX;
          mouseY = e.clientY;
        }
        document.addEventListener('mouseup', dragEnd);
        document.addEventListener('mousemove', dragProcess);
        document.addEventListener('touchend', dragEnd);
        document.addEventListener('touchmove', dragProcess);
      }
      function dragProcess(e) {
        var touches = e.touches;
        var offsetX, offsetY;
        if (touches && touches.length) {
          offsetX = mouseX - touches[0].clientX, offsetY = mouseY - touches[0].clientY;
        } else {
          offsetX = mouseX - e.clientX, offsetY = mouseY - e.clientY;
        }

        //--- left
        if (offsetX >= 50) {
          if (!isMoving) {
            isMoving = true;
            nextMove();
          }
        }

        //--- right
        if (offsetX <= -50) {
          if (!isMoving) {
            isMoving = true;
            prevMove();
          }
        }

        //--- up
        if (offsetY >= 50) {}

        //--- down
        if (offsetY <= -50) {}
      }
      function dragEnd(e) {
        document.removeEventListener('mousemove', dragProcess);
        document.removeEventListener('touchmove', dragProcess);

        //restore move action status
        setTimeout(function () {
          isMoving = false;
        }, animDelay);
      }
    }

    /*
     * Transition Between Slides
     *
     * @param  {Number} elementIndex           - Index of current slider.
     * @param  {Element} slider                 - Selector of the slider .
     * @param  {String} dir                    - Switching direction indicator.
           * @param  {String} countTotalID           - Total number ID or class of counter.
           * @param  {String} countCurID             - Current number ID or class of counter.
           * @param  {String} paginationID           - Navigation ID for paging control of each slide.
           * @param  {String} arrowsID               - Previous/Next arrow navigation ID.
           * @param  {Boolean} loop                  - Gives the slider a seamless infinite loop.
     * @return {Void}
     */
    function sliderUpdates(elementIndex, slider, dir, countTotalID, countCurID, paginationID, arrowsID, loop) {
      var $items = slider.find('.uix-svgMask-slider__item'),
        total = $items.length;

      //Prevent bubbling
      if (total == 1) {
        $(paginationID).hide();
        $(arrowsID).hide();
        return false;
      }

      //Transition Interception
      //-------------------------------------
      if (loop) {
        if (elementIndex == total) elementIndex = 0;
        if (elementIndex < 0) elementIndex = total - 1;
      } else {
        $(arrowsID).find('a').removeClass('is-disabled');
        if (elementIndex == total - 1) $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
        if (elementIndex == 0) $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
      }

      // To determine if it is a touch screen.
      if (Modernizr.touchevents) {
        if (elementIndex == total) elementIndex = total - 1;
        if (elementIndex < 0) elementIndex = 0;

        //Prevent bubbling
        if (!loop) {
          //first item
          if (elementIndex == 0) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--prev').addClass('is-disabled');
          }

          //last item
          if (elementIndex == total - 1) {
            $(arrowsID).find('.uix-svgMask-slider__arrows--next').addClass('is-disabled');
          }
        }
      }

      // call the current item
      //-------------------------------------
      var $current = $items.eq(elementIndex);

      //Determine the direction and add class to switching direction indicator.
      var dirIndicatorClass = '';
      if (dir == 'prev') dirIndicatorClass = 'prev';
      if (dir == 'next') dirIndicatorClass = 'next';

      //Add transition class to Controls Pagination
      $(paginationID).find('li a').removeClass('leave');
      $(paginationID).find('li a.is-active').removeClass('is-active').addClass('leave');
      $(paginationID).find('li a[data-index="' + elementIndex + '"]').addClass('is-active').removeClass('leave');

      //Add transition class to each item
      $items.removeClass('leave prev next');
      $items.addClass(dirIndicatorClass);
      slider.find('.uix-svgMask-slider__item.is-active').removeClass('is-active').addClass('leave ' + dirIndicatorClass);
      $current.addClass('is-active ' + dirIndicatorClass).removeClass('leave');

      //SVG Animation
      //-------------------------------------
      if (!svgAnimating) {
        //don't animate if already animating
        svgAnimating = true;
        var path1 = '1 0.5 1 540.5 1 1080.5 0 1080.5 4 1080.5 4 540.5 4 0.5 0 0.5 1 0.5',
          path2 = '0.5 0.5 0.5 540.5 0.5 1080.5 1519.5 1080.5 1531.5 1080.5 1066.5 525.5 601.5 1.5 589.5 1.5 0.5 0.5',
          path3 = '0.5 0.5 0.5 540.5 0.5 1080.5 960.5 1080.5 1920.5 1080.5 1920.5 540.5 1920.5 0.5 960.5 0.5 0.5 0.5';
        if (dir == 'next') {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(180deg)'
          });
        } else {
          $current.find('polygon').css({
            'transform-origin': 'center',
            'transform': 'rotate(0)'
          });
        }

        //----
        //@required: MorphSVGPlugin
        /*
        TweenMax.set( $current.find('polygon')[0], {
        	attr: {
        			  points: path1
        		  },
        	onComplete: function() {
        			TweenMax.to( this.target, animSpeed/1000, {
        			morphSVG: path2,
        			delay: 0,
        			ease: Power2.easeOut,
        			onComplete: function() {
        					TweenMax.to( this.target, animSpeed/1000, {
        					morphSVG: path3,
        					delay: 0,
        					ease: Power2.easeInOut,
        					onComplete: function() {
        						svgAnimating = false;
        					}
        				});	
        					}
        		});	
        		}
        });
        */

        TweenMax.set($current.find('polygon')[0], {
          attr: {
            points: path1
          },
          onComplete: function onComplete() {
            anime.timeline({
              loop: false
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path2
              }],
              duration: animSpeed,
              easing: "easeOutExpo"
            }).add({
              targets: $current.find('polygon')[0],
              points: [{
                value: path3
              }],
              duration: animSpeed,
              easing: "easeOutExpo",
              complete: function complete() {
                svgAnimating = false;
              }
            });
          }
        });
      } //endif svgAnimating

      //Display counter
      //-------------------------------------
      $(countTotalID).text(total);
      $(countCurID).text(parseFloat(elementIndex) + 1);

      //Reset the default height of item
      //-------------------------------------	
      itemDefaultInit(slider, $current);
    }

    /*
     * Initialize the default height of item
     *
           * @param  {Element} slider                 - Selector of the slider .
     * @param  {Element} currentLlement         - Current selector of each slider.
     * @return {Void}
     */
    function itemDefaultInit(slider, currentLlement) {
      //
      var imgURL = currentLlement.find('img').attr('src');
      if ((0,esm_typeof/* default */.Z)(imgURL) != ( true ? "undefined" : 0)) {
        var img = new Image();
        img.onload = function () {
          slider.css('height', currentLlement.closest('.uix-svgMask-slider__outline').width() * (this.height / this.width) + 'px');
        };
        img.src = imgURL;
      }
    }
  };
  module.components.pageLoaded.push(module.SVG_MASK_SLIDER.pageLoaded);
  return /*#__PURE__*/_createClass(function SVG_MASK_SLIDER() {
    _classCallCheck(this, SVG_MASK_SLIDER);
    this.module = module;
  });
}(UixModuleInstance, jQuery, window, document);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/ssr-window/package/ssr-window.esm.js

/**
 * SSR Window 3.0.0
 * Better handling for window object in SSR environment
 * https://github.com/nolimits4web/ssr-window
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 15, 2021
 */
/* eslint-disable no-param-reassign */
function isObject(obj) {
  return obj !== null && (0,esm_typeof/* default */.Z)(obj) === 'object' && 'constructor' in obj && obj.constructor === Object;
}
function extend(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach(function (key) {
    if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
      extend(target[key], src[key]);
    }
  });
}
var ssrDocument = {
  body: {},
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  activeElement: {
    blur: function blur() {},
    nodeName: ''
  },
  querySelector: function querySelector() {
    return null;
  },
  querySelectorAll: function querySelectorAll() {
    return [];
  },
  getElementById: function getElementById() {
    return null;
  },
  createEvent: function createEvent() {
    return {
      initEvent: function initEvent() {}
    };
  },
  createElement: function createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute: function setAttribute() {},
      getElementsByTagName: function getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS: function createElementNS() {
    return {};
  },
  importNode: function importNode() {
    return null;
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  }
};
function getDocument() {
  var doc = typeof document !== 'undefined' ? document : {};
  extend(doc, ssrDocument);
  return doc;
}
var ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ''
  },
  location: {
    hash: '',
    host: '',
    hostname: '',
    href: '',
    origin: '',
    pathname: '',
    protocol: '',
    search: ''
  },
  history: {
    replaceState: function replaceState() {},
    pushState: function pushState() {},
    go: function go() {},
    back: function back() {}
  },
  CustomEvent: function CustomEvent() {
    return this;
  },
  addEventListener: function addEventListener() {},
  removeEventListener: function removeEventListener() {},
  getComputedStyle: function getComputedStyle() {
    return {
      getPropertyValue: function getPropertyValue() {
        return '';
      }
    };
  },
  Image: function Image() {},
  Date: function Date() {},
  screen: {},
  setTimeout: function setTimeout() {},
  clearTimeout: function clearTimeout() {},
  matchMedia: function matchMedia() {
    return {};
  },
  requestAnimationFrame: function requestAnimationFrame(callback) {
    if (typeof setTimeout === 'undefined') {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame: function cancelAnimationFrame(id) {
    if (typeof setTimeout === 'undefined') {
      return;
    }
    clearTimeout(id);
  }
};
function ssr_window_esm_getWindow() {
  var win = typeof window !== 'undefined' ? window : {};
  extend(win, ssrWindow);
  return win;
}

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/dom7/package/dom7.esm.js
/**
 * Dom7 3.0.0
 * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
 * https://framework7.io/docs/dom7.html
 *
 * Copyright 2021, Vladimir Kharlampidi
 *
 * Licensed under MIT
 *
 * Released on: February 15, 2021
 */

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;
  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;
    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);
      _cache.set(Class, Wrapper);
    }
    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}

/* eslint-disable no-proto */
function makeReactive(obj) {
  var proto = obj.__proto__;
  Object.defineProperty(obj, '__proto__', {
    get: function get() {
      return proto;
    },
    set: function set(value) {
      proto.__proto__ = value;
    }
  });
}
var Dom7 = /*#__PURE__*/function (_Array) {
  _inheritsLoose(Dom7, _Array);
  function Dom7(items) {
    var _this;
    _this = _Array.call.apply(_Array, [this].concat(items)) || this;
    makeReactive(_assertThisInitialized(_this));
    return _this;
  }
  return Dom7;
}( /*#__PURE__*/_wrapNativeSuper(Array));
function arrayFlat(arr) {
  if (arr === void 0) {
    arr = [];
  }
  var res = [];
  arr.forEach(function (el) {
    if (Array.isArray(el)) {
      res.push.apply(res, arrayFlat(el));
    } else {
      res.push(el);
    }
  });
  return res;
}
function arrayFilter(arr, callback) {
  return Array.prototype.filter.call(arr, callback);
}
function arrayUnique(arr) {
  var uniqueArray = [];
  for (var i = 0; i < arr.length; i += 1) {
    if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
  }
  return uniqueArray;
}
function toCamelCase(string) {
  return string.toLowerCase().replace(/-(.)/g, function (match, group) {
    return group.toUpperCase();
  });
}
function qsa(selector, context) {
  if (typeof selector !== 'string') {
    return [selector];
  }
  var a = [];
  var res = context.querySelectorAll(selector);
  for (var i = 0; i < res.length; i += 1) {
    a.push(res[i]);
  }
  return a;
}
function dom7_esm_$(selector, context) {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  var arr = [];
  if (!context && selector instanceof Dom7) {
    return selector;
  }
  if (!selector) {
    return new Dom7(arr);
  }
  if (typeof selector === 'string') {
    var html = selector.trim();
    if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
      var toCreate = 'div';
      if (html.indexOf('<li') === 0) toCreate = 'ul';
      if (html.indexOf('<tr') === 0) toCreate = 'tbody';
      if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
      if (html.indexOf('<tbody') === 0) toCreate = 'table';
      if (html.indexOf('<option') === 0) toCreate = 'select';
      var tempParent = document.createElement(toCreate);
      tempParent.innerHTML = html;
      for (var i = 0; i < tempParent.childNodes.length; i += 1) {
        arr.push(tempParent.childNodes[i]);
      }
    } else {
      arr = qsa(selector.trim(), context || document);
    } // arr = qsa(selector, document);
  } else if (selector.nodeType || selector === window || selector === document) {
    arr.push(selector);
  } else if (Array.isArray(selector)) {
    if (selector instanceof Dom7) return selector;
    arr = selector;
  }
  return new Dom7(arrayUnique(arr));
}
dom7_esm_$.fn = Dom7.prototype;
function addClass() {
  for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
    classes[_key] = arguments[_key];
  }
  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList;
    (_el$classList = el.classList).add.apply(_el$classList, classNames);
  });
  return this;
}
function removeClass() {
  for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    classes[_key2] = arguments[_key2];
  }
  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    var _el$classList2;
    (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
  });
  return this;
}
function toggleClass() {
  for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    classes[_key3] = arguments[_key3];
  }
  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  this.forEach(function (el) {
    classNames.forEach(function (className) {
      el.classList.toggle(className);
    });
  });
}
function hasClass() {
  for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    classes[_key4] = arguments[_key4];
  }
  var classNames = arrayFlat(classes.map(function (c) {
    return c.split(' ');
  }));
  return arrayFilter(this, function (el) {
    return classNames.filter(function (className) {
      return el.classList.contains(className);
    }).length > 0;
  }).length > 0;
}
function attr(attrs, value) {
  if (arguments.length === 1 && typeof attrs === 'string') {
    // Get attr
    if (this[0]) return this[0].getAttribute(attrs);
    return undefined;
  } // Set attrs

  for (var i = 0; i < this.length; i += 1) {
    if (arguments.length === 2) {
      // String
      this[i].setAttribute(attrs, value);
    } else {
      // Object
      for (var attrName in attrs) {
        this[i][attrName] = attrs[attrName];
        this[i].setAttribute(attrName, attrs[attrName]);
      }
    }
  }
  return this;
}
function removeAttr(attr) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].removeAttribute(attr);
  }
  return this;
}
function prop(props, value) {
  if (arguments.length === 1 && typeof props === 'string') {
    // Get prop
    if (this[0]) return this[0][props];
  } else {
    // Set props
    for (var i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i][props] = value;
      } else {
        // Object
        for (var propName in props) {
          this[i][propName] = props[propName];
        }
      }
    }
    return this;
  }
  return this;
}
function data(key, value) {
  var el;
  if (typeof value === 'undefined') {
    el = this[0];
    if (!el) return undefined; // Get value

    if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
      return el.dom7ElementDataStorage[key];
    }
    var dataKey = el.getAttribute("data-" + key);
    if (dataKey) {
      return dataKey;
    }
    return undefined;
  } // Set value

  for (var i = 0; i < this.length; i += 1) {
    el = this[i];
    if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
    el.dom7ElementDataStorage[key] = value;
  }
  return this;
}
function removeData(key) {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
      el.dom7ElementDataStorage[key] = null;
      delete el.dom7ElementDataStorage[key];
    }
  }
}
function dataset() {
  var el = this[0];
  if (!el) return undefined;
  var dataset = {}; // eslint-disable-line

  if (el.dataset) {
    for (var dataKey in el.dataset) {
      dataset[dataKey] = el.dataset[dataKey];
    }
  } else {
    for (var i = 0; i < el.attributes.length; i += 1) {
      var _attr = el.attributes[i];
      if (_attr.name.indexOf('data-') >= 0) {
        dataset[toCamelCase(_attr.name.split('data-')[1])] = _attr.value;
      }
    }
  }
  for (var key in dataset) {
    if (dataset[key] === 'false') dataset[key] = false;else if (dataset[key] === 'true') dataset[key] = true;else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
  }
  return dataset;
}
function val(value) {
  if (typeof value === 'undefined') {
    // get value
    var el = this[0];
    if (!el) return undefined;
    if (el.multiple && el.nodeName.toLowerCase() === 'select') {
      var values = [];
      for (var i = 0; i < el.selectedOptions.length; i += 1) {
        values.push(el.selectedOptions[i].value);
      }
      return values;
    }
    return el.value;
  } // set value

  for (var _i = 0; _i < this.length; _i += 1) {
    var _el = this[_i];
    if (Array.isArray(value) && _el.multiple && _el.nodeName.toLowerCase() === 'select') {
      for (var j = 0; j < _el.options.length; j += 1) {
        _el.options[j].selected = value.indexOf(_el.options[j].value) >= 0;
      }
    } else {
      _el.value = value;
    }
  }
  return this;
}
function value(value) {
  return this.val(value);
}
function transform(transform) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transform = transform;
  }
  return this;
}
function transition(duration) {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
  }
  return this;
}
function on() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }
  var eventType = args[0],
    targetSelector = args[1],
    listener = args[2],
    capture = args[3];
  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }
  if (!capture) capture = false;
  function handleLiveEvent(e) {
    var target = e.target;
    if (!target) return;
    var eventData = e.target.dom7EventData || [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    if (dom7_esm_$(target).is(targetSelector)) listener.apply(target, eventData);else {
      var _parents = dom7_esm_$(target).parents(); // eslint-disable-line

      for (var k = 0; k < _parents.length; k += 1) {
        if (dom7_esm_$(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
      }
    }
  }
  function handleEvent(e) {
    var eventData = e && e.target ? e.target.dom7EventData || [] : [];
    if (eventData.indexOf(e) < 0) {
      eventData.unshift(e);
    }
    listener.apply(this, eventData);
  }
  var events = eventType.split(' ');
  var j;
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (!targetSelector) {
      for (j = 0; j < events.length; j += 1) {
        var event = events[j];
        if (!el.dom7Listeners) el.dom7Listeners = {};
        if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
        el.dom7Listeners[event].push({
          listener: listener,
          proxyListener: handleEvent
        });
        el.addEventListener(event, handleEvent, capture);
      }
    } else {
      // Live events
      for (j = 0; j < events.length; j += 1) {
        var _event = events[j];
        if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
        if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];
        el.dom7LiveListeners[_event].push({
          listener: listener,
          proxyListener: handleLiveEvent
        });
        el.addEventListener(_event, handleLiveEvent, capture);
      }
    }
  }
  return this;
}
function off() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }
  var eventType = args[0],
    targetSelector = args[1],
    listener = args[2],
    capture = args[3];
  if (typeof args[1] === 'function') {
    eventType = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }
  if (!capture) capture = false;
  var events = eventType.split(' ');
  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];
    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      var handlers = void 0;
      if (!targetSelector && el.dom7Listeners) {
        handlers = el.dom7Listeners[event];
      } else if (targetSelector && el.dom7LiveListeners) {
        handlers = el.dom7LiveListeners[event];
      }
      if (handlers && handlers.length) {
        for (var k = handlers.length - 1; k >= 0; k -= 1) {
          var handler = handlers[k];
          if (listener && handler.listener === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          } else if (!listener) {
            el.removeEventListener(event, handler.proxyListener, capture);
            handlers.splice(k, 1);
          }
        }
      }
    }
  }
  return this;
}
function once() {
  var dom = this;
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }
  var eventName = args[0],
    targetSelector = args[1],
    listener = args[2],
    capture = args[3];
  if (typeof args[1] === 'function') {
    eventName = args[0];
    listener = args[1];
    capture = args[2];
    targetSelector = undefined;
  }
  function onceHandler() {
    for (var _len8 = arguments.length, eventArgs = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      eventArgs[_key8] = arguments[_key8];
    }
    listener.apply(this, eventArgs);
    dom.off(eventName, targetSelector, onceHandler, capture);
    if (onceHandler.dom7proxy) {
      delete onceHandler.dom7proxy;
    }
  }
  onceHandler.dom7proxy = listener;
  return dom.on(eventName, targetSelector, onceHandler, capture);
}
function trigger() {
  var window = ssr_window_esm_getWindow();
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }
  var events = args[0].split(' ');
  var eventData = args[1];
  for (var i = 0; i < events.length; i += 1) {
    var event = events[i];
    for (var j = 0; j < this.length; j += 1) {
      var el = this[j];
      if (window.CustomEvent) {
        var evt = new window.CustomEvent(event, {
          detail: eventData,
          bubbles: true,
          cancelable: true
        });
        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
  }
  return this;
}
function transitionEnd(callback) {
  var dom = this;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('transitionend', fireCallBack);
  }
  if (callback) {
    dom.on('transitionend', fireCallBack);
  }
  return this;
}
function animationEnd(callback) {
  var dom = this;
  function fireCallBack(e) {
    if (e.target !== this) return;
    callback.call(this, e);
    dom.off('animationend', fireCallBack);
  }
  if (callback) {
    dom.on('animationend', fireCallBack);
  }
  return this;
}
function width() {
  var window = getWindow();
  if (this[0] === window) {
    return window.innerWidth;
  }
  if (this.length > 0) {
    return parseFloat(this.css('width'));
  }
  return null;
}
function dom7_esm_outerWidth(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles = this.styles();
      return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
    }
    return this[0].offsetWidth;
  }
  return null;
}
function height() {
  var window = getWindow();
  if (this[0] === window) {
    return window.innerHeight;
  }
  if (this.length > 0) {
    return parseFloat(this.css('height'));
  }
  return null;
}
function dom7_esm_outerHeight(includeMargins) {
  if (this.length > 0) {
    if (includeMargins) {
      var _styles2 = this.styles();
      return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
    }
    return this[0].offsetHeight;
  }
  return null;
}
function offset() {
  if (this.length > 0) {
    var window = ssr_window_esm_getWindow();
    var document = getDocument();
    var el = this[0];
    var box = el.getBoundingClientRect();
    var body = document.body;
    var clientTop = el.clientTop || body.clientTop || 0;
    var clientLeft = el.clientLeft || body.clientLeft || 0;
    var scrollTop = el === window ? window.scrollY : el.scrollTop;
    var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
    return {
      top: box.top + scrollTop - clientTop,
      left: box.left + scrollLeft - clientLeft
    };
  }
  return null;
}
function hide() {
  for (var i = 0; i < this.length; i += 1) {
    this[i].style.display = 'none';
  }
  return this;
}
function show() {
  var window = getWindow();
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.style.display === 'none') {
      el.style.display = '';
    }
    if (window.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
      // Still not visible
      el.style.display = 'block';
    }
  }
  return this;
}
function styles() {
  var window = ssr_window_esm_getWindow();
  if (this[0]) return window.getComputedStyle(this[0], null);
  return {};
}
function css(props, value) {
  var window = ssr_window_esm_getWindow();
  var i;
  if (arguments.length === 1) {
    if (typeof props === 'string') {
      // .css('width')
      if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
    } else {
      // .css({ width: '100px' })
      for (i = 0; i < this.length; i += 1) {
        for (var _prop in props) {
          this[i].style[_prop] = props[_prop];
        }
      }
      return this;
    }
  }
  if (arguments.length === 2 && typeof props === 'string') {
    // .css('width', '100px')
    for (i = 0; i < this.length; i += 1) {
      this[i].style[props] = value;
    }
    return this;
  }
  return this;
}
function each(callback) {
  if (!callback) return this;
  this.forEach(function (el, index) {
    callback.apply(el, [el, index]);
  });
  return this;
}
function filter(callback) {
  var result = arrayFilter(this, callback);
  return dom7_esm_$(result);
}
function html(html) {
  if (typeof html === 'undefined') {
    return this[0] ? this[0].innerHTML : null;
  }
  for (var i = 0; i < this.length; i += 1) {
    this[i].innerHTML = html;
  }
  return this;
}
function dom7_esm_text(text) {
  if (typeof text === 'undefined') {
    return this[0] ? this[0].textContent.trim() : null;
  }
  for (var i = 0; i < this.length; i += 1) {
    this[i].textContent = text;
  }
  return this;
}
function is(selector) {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  var el = this[0];
  var compareWith;
  var i;
  if (!el || typeof selector === 'undefined') return false;
  if (typeof selector === 'string') {
    if (el.matches) return el.matches(selector);
    if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
    if (el.msMatchesSelector) return el.msMatchesSelector(selector);
    compareWith = dom7_esm_$(selector);
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  if (selector === document) {
    return el === document;
  }
  if (selector === window) {
    return el === window;
  }
  if (selector.nodeType || selector instanceof Dom7) {
    compareWith = selector.nodeType ? [selector] : selector;
    for (i = 0; i < compareWith.length; i += 1) {
      if (compareWith[i] === el) return true;
    }
    return false;
  }
  return false;
}
function index() {
  var child = this[0];
  var i;
  if (child) {
    i = 0; // eslint-disable-next-line

    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1) i += 1;
    }
    return i;
  }
  return undefined;
}
function eq(index) {
  if (typeof index === 'undefined') return this;
  var length = this.length;
  if (index > length - 1) {
    return dom7_esm_$([]);
  }
  if (index < 0) {
    var returnIndex = length + index;
    if (returnIndex < 0) return dom7_esm_$([]);
    return dom7_esm_$([this[returnIndex]]);
  }
  return dom7_esm_$([this[index]]);
}
function append() {
  var newChild;
  var document = getDocument();
  for (var k = 0; k < arguments.length; k += 1) {
    newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];
    for (var i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = document.createElement('div');
        tempDiv.innerHTML = newChild;
        while (tempDiv.firstChild) {
          this[i].appendChild(tempDiv.firstChild);
        }
      } else if (newChild instanceof Dom7) {
        for (var j = 0; j < newChild.length; j += 1) {
          this[i].appendChild(newChild[j]);
        }
      } else {
        this[i].appendChild(newChild);
      }
    }
  }
  return this;
}
function appendTo(parent) {
  dom7_esm_$(parent).append(this);
  return this;
}
function prepend(newChild) {
  var document = getDocument();
  var i;
  var j;
  for (i = 0; i < this.length; i += 1) {
    if (typeof newChild === 'string') {
      var tempDiv = document.createElement('div');
      tempDiv.innerHTML = newChild;
      for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
        this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
      }
    } else if (newChild instanceof Dom7) {
      for (j = 0; j < newChild.length; j += 1) {
        this[i].insertBefore(newChild[j], this[i].childNodes[0]);
      }
    } else {
      this[i].insertBefore(newChild, this[i].childNodes[0]);
    }
  }
  return this;
}
function prependTo(parent) {
  dom7_esm_$(parent).prepend(this);
  return this;
}
function insertBefore(selector) {
  var before = dom7_esm_$(selector);
  for (var i = 0; i < this.length; i += 1) {
    if (before.length === 1) {
      before[0].parentNode.insertBefore(this[i], before[0]);
    } else if (before.length > 1) {
      for (var j = 0; j < before.length; j += 1) {
        before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
      }
    }
  }
}
function insertAfter(selector) {
  var after = dom7_esm_$(selector);
  for (var i = 0; i < this.length; i += 1) {
    if (after.length === 1) {
      after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
    } else if (after.length > 1) {
      for (var j = 0; j < after.length; j += 1) {
        after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
      }
    }
  }
}
function next(selector) {
  if (this.length > 0) {
    if (selector) {
      if (this[0].nextElementSibling && dom7_esm_$(this[0].nextElementSibling).is(selector)) {
        return dom7_esm_$([this[0].nextElementSibling]);
      }
      return dom7_esm_$([]);
    }
    if (this[0].nextElementSibling) return dom7_esm_$([this[0].nextElementSibling]);
    return dom7_esm_$([]);
  }
  return dom7_esm_$([]);
}
function nextAll(selector) {
  var nextEls = [];
  var el = this[0];
  if (!el) return dom7_esm_$([]);
  while (el.nextElementSibling) {
    var _next = el.nextElementSibling; // eslint-disable-line

    if (selector) {
      if (dom7_esm_$(_next).is(selector)) nextEls.push(_next);
    } else nextEls.push(_next);
    el = _next;
  }
  return dom7_esm_$(nextEls);
}
function prev(selector) {
  if (this.length > 0) {
    var el = this[0];
    if (selector) {
      if (el.previousElementSibling && dom7_esm_$(el.previousElementSibling).is(selector)) {
        return dom7_esm_$([el.previousElementSibling]);
      }
      return dom7_esm_$([]);
    }
    if (el.previousElementSibling) return dom7_esm_$([el.previousElementSibling]);
    return dom7_esm_$([]);
  }
  return dom7_esm_$([]);
}
function prevAll(selector) {
  var prevEls = [];
  var el = this[0];
  if (!el) return dom7_esm_$([]);
  while (el.previousElementSibling) {
    var _prev = el.previousElementSibling; // eslint-disable-line

    if (selector) {
      if (dom7_esm_$(_prev).is(selector)) prevEls.push(_prev);
    } else prevEls.push(_prev);
    el = _prev;
  }
  return dom7_esm_$(prevEls);
}
function siblings(selector) {
  return this.nextAll(selector).add(this.prevAll(selector));
}
function dom7_esm_parent(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode !== null) {
      if (selector) {
        if (dom7_esm_$(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
      } else {
        parents.push(this[i].parentNode);
      }
    }
  }
  return dom7_esm_$(parents);
}
function parents(selector) {
  var parents = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var _parent = this[i].parentNode; // eslint-disable-line

    while (_parent) {
      if (selector) {
        if (dom7_esm_$(_parent).is(selector)) parents.push(_parent);
      } else {
        parents.push(_parent);
      }
      _parent = _parent.parentNode;
    }
  }
  return dom7_esm_$(parents);
}
function closest(selector) {
  var closest = this; // eslint-disable-line

  if (typeof selector === 'undefined') {
    return dom7_esm_$([]);
  }
  if (!closest.is(selector)) {
    closest = closest.parents(selector).eq(0);
  }
  return closest;
}
function find(selector) {
  var foundElements = [];
  for (var i = 0; i < this.length; i += 1) {
    var found = this[i].querySelectorAll(selector);
    for (var j = 0; j < found.length; j += 1) {
      foundElements.push(found[j]);
    }
  }
  return dom7_esm_$(foundElements);
}
function children(selector) {
  var children = []; // eslint-disable-line

  for (var i = 0; i < this.length; i += 1) {
    var childNodes = this[i].children;
    for (var j = 0; j < childNodes.length; j += 1) {
      if (!selector || dom7_esm_$(childNodes[j]).is(selector)) {
        children.push(childNodes[j]);
      }
    }
  }
  return dom7_esm_$(children);
}
function remove() {
  for (var i = 0; i < this.length; i += 1) {
    if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
  }
  return this;
}
function detach() {
  return this.remove();
}
function add() {
  var dom = this;
  var i;
  var j;
  for (var _len10 = arguments.length, els = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
    els[_key10] = arguments[_key10];
  }
  for (i = 0; i < els.length; i += 1) {
    var toAdd = dom7_esm_$(els[i]);
    for (j = 0; j < toAdd.length; j += 1) {
      dom.push(toAdd[j]);
    }
  }
  return dom;
}
function empty() {
  for (var i = 0; i < this.length; i += 1) {
    var el = this[i];
    if (el.nodeType === 1) {
      for (var j = 0; j < el.childNodes.length; j += 1) {
        if (el.childNodes[j].parentNode) {
          el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
        }
      }
      el.textContent = '';
    }
  }
  return this;
}
function scrollTo() {
  var window = getWindow();
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var left = args[0],
    top = args[1],
    duration = args[2],
    easing = args[3],
    callback = args[4];
  if (args.length === 4 && typeof easing === 'function') {
    callback = easing;
    left = args[0];
    top = args[1];
    duration = args[2];
    callback = args[3];
    easing = args[4];
  }
  if (typeof easing === 'undefined') easing = 'swing';
  return this.each(function animate() {
    var el = this;
    var currentTop;
    var currentLeft;
    var maxTop;
    var maxLeft;
    var newTop;
    var newLeft;
    var scrollTop; // eslint-disable-line

    var scrollLeft; // eslint-disable-line

    var animateTop = top > 0 || top === 0;
    var animateLeft = left > 0 || left === 0;
    if (typeof easing === 'undefined') {
      easing = 'swing';
    }
    if (animateTop) {
      currentTop = el.scrollTop;
      if (!duration) {
        el.scrollTop = top;
      }
    }
    if (animateLeft) {
      currentLeft = el.scrollLeft;
      if (!duration) {
        el.scrollLeft = left;
      }
    }
    if (!duration) return;
    if (animateTop) {
      maxTop = el.scrollHeight - el.offsetHeight;
      newTop = Math.max(Math.min(top, maxTop), 0);
    }
    if (animateLeft) {
      maxLeft = el.scrollWidth - el.offsetWidth;
      newLeft = Math.max(Math.min(left, maxLeft), 0);
    }
    var startTime = null;
    if (animateTop && newTop === currentTop) animateTop = false;
    if (animateLeft && newLeft === currentLeft) animateLeft = false;
    function render(time) {
      if (time === void 0) {
        time = new Date().getTime();
      }
      if (startTime === null) {
        startTime = time;
      }
      var progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
      var easeProgress = easing === 'linear' ? progress : 0.5 - Math.cos(progress * Math.PI) / 2;
      var done;
      if (animateTop) scrollTop = currentTop + easeProgress * (newTop - currentTop);
      if (animateLeft) scrollLeft = currentLeft + easeProgress * (newLeft - currentLeft);
      if (animateTop && newTop > currentTop && scrollTop >= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateTop && newTop < currentTop && scrollTop <= newTop) {
        el.scrollTop = newTop;
        done = true;
      }
      if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
        el.scrollLeft = newLeft;
        done = true;
      }
      if (done) {
        if (callback) callback();
        return;
      }
      if (animateTop) el.scrollTop = scrollTop;
      if (animateLeft) el.scrollLeft = scrollLeft;
      window.requestAnimationFrame(render);
    }
    window.requestAnimationFrame(render);
  });
} // scrollTop(top, duration, easing, callback) {

function scrollTop() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var top = args[0],
    duration = args[1],
    easing = args[2],
    callback = args[3];
  if (args.length === 3 && typeof easing === 'function') {
    top = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }
  var dom = this;
  if (typeof top === 'undefined') {
    if (dom.length > 0) return dom[0].scrollTop;
    return null;
  }
  return dom.scrollTo(undefined, top, duration, easing, callback);
}
function scrollLeft() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  var left = args[0],
    duration = args[1],
    easing = args[2],
    callback = args[3];
  if (args.length === 3 && typeof easing === 'function') {
    left = args[0];
    duration = args[1];
    callback = args[2];
    easing = args[3];
  }
  var dom = this;
  if (typeof left === 'undefined') {
    if (dom.length > 0) return dom[0].scrollLeft;
    return null;
  }
  return dom.scrollTo(left, undefined, duration, easing, callback);
}
function animate(initialProps, initialParams) {
  var window = getWindow();
  var els = this;
  var a = {
    props: Object.assign({}, initialProps),
    params: Object.assign({
      duration: 300,
      easing: 'swing' // or 'linear'

      /* Callbacks
      begin(elements)
      complete(elements)
      progress(elements, complete, remaining, start, tweenValue)
      */
    }, initialParams),
    elements: els,
    animating: false,
    que: [],
    easingProgress: function easingProgress(easing, progress) {
      if (easing === 'swing') {
        return 0.5 - Math.cos(progress * Math.PI) / 2;
      }
      if (typeof easing === 'function') {
        return easing(progress);
      }
      return progress;
    },
    stop: function stop() {
      if (a.frameId) {
        window.cancelAnimationFrame(a.frameId);
      }
      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      a.que = [];
    },
    done: function done(complete) {
      a.animating = false;
      a.elements.each(function (el) {
        var element = el;
        delete element.dom7AnimateInstance;
      });
      if (complete) complete(els);
      if (a.que.length > 0) {
        var que = a.que.shift();
        a.animate(que[0], que[1]);
      }
    },
    animate: function animate(props, params) {
      if (a.animating) {
        a.que.push([props, params]);
        return a;
      }
      var elements = []; // Define & Cache Initials & Units

      a.elements.each(function (el, index) {
        var initialFullValue;
        var initialValue;
        var unit;
        var finalValue;
        var finalFullValue;
        if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;
        elements[index] = {
          container: el
        };
        Object.keys(props).forEach(function (prop) {
          initialFullValue = window.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
          initialValue = parseFloat(initialFullValue);
          unit = initialFullValue.replace(initialValue, '');
          finalValue = parseFloat(props[prop]);
          finalFullValue = props[prop] + unit;
          elements[index][prop] = {
            initialFullValue: initialFullValue,
            initialValue: initialValue,
            unit: unit,
            finalValue: finalValue,
            finalFullValue: finalFullValue,
            currentValue: initialValue
          };
        });
      });
      var startTime = null;
      var time;
      var elementsDone = 0;
      var propsDone = 0;
      var done;
      var began = false;
      a.animating = true;
      function render() {
        time = new Date().getTime();
        var progress;
        var easeProgress; // let el;

        if (!began) {
          began = true;
          if (params.begin) params.begin(els);
        }
        if (startTime === null) {
          startTime = time;
        }
        if (params.progress) {
          // eslint-disable-next-line
          params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), startTime + params.duration - time < 0 ? 0 : startTime + params.duration - time, startTime);
        }
        elements.forEach(function (element) {
          var el = element;
          if (done || el.done) return;
          Object.keys(props).forEach(function (prop) {
            if (done || el.done) return;
            progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
            easeProgress = a.easingProgress(params.easing, progress);
            var _el$prop = el[prop],
              initialValue = _el$prop.initialValue,
              finalValue = _el$prop.finalValue,
              unit = _el$prop.unit;
            el[prop].currentValue = initialValue + easeProgress * (finalValue - initialValue);
            var currentValue = el[prop].currentValue;
            if (finalValue > initialValue && currentValue >= finalValue || finalValue < initialValue && currentValue <= finalValue) {
              el.container.style[prop] = finalValue + unit;
              propsDone += 1;
              if (propsDone === Object.keys(props).length) {
                el.done = true;
                elementsDone += 1;
              }
              if (elementsDone === elements.length) {
                done = true;
              }
            }
            if (done) {
              a.done(params.complete);
              return;
            }
            el.container.style[prop] = currentValue + unit;
          });
        });
        if (done) return; // Then call

        a.frameId = window.requestAnimationFrame(render);
      }
      a.frameId = window.requestAnimationFrame(render);
      return a;
    }
  };
  if (a.elements.length === 0) {
    return els;
  }
  var animateInstance;
  for (var i = 0; i < a.elements.length; i += 1) {
    if (a.elements[i].dom7AnimateInstance) {
      animateInstance = a.elements[i].dom7AnimateInstance;
    } else a.elements[i].dom7AnimateInstance = a;
  }
  if (!animateInstance) {
    animateInstance = a;
  }
  if (initialProps === 'stop') {
    animateInstance.stop();
  } else {
    animateInstance.animate(a.props, a.params);
  }
  return els;
}
function stop() {
  var els = this;
  for (var i = 0; i < els.length; i += 1) {
    if (els[i].dom7AnimateInstance) {
      els[i].dom7AnimateInstance.stop();
    }
  }
}
var noTrigger = 'resize scroll'.split(' ');
function shortcut(name) {
  function eventHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === 'undefined') {
      for (var i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();else {
            dom7_esm_$(this[i]).trigger(name);
          }
        }
      }
      return this;
    }
    return this.on.apply(this, [name].concat(args));
  }
  return eventHandler;
}
var click = shortcut('click');
var dom7_esm_blur = shortcut('blur');
var dom7_esm_focus = shortcut('focus');
var focusin = shortcut('focusin');
var focusout = shortcut('focusout');
var keyup = shortcut('keyup');
var keydown = shortcut('keydown');
var keypress = shortcut('keypress');
var dom7_esm_submit = shortcut('submit');
var change = shortcut('change');
var mousedown = shortcut('mousedown');
var mousemove = shortcut('mousemove');
var mouseup = shortcut('mouseup');
var mouseenter = shortcut('mouseenter');
var mouseleave = shortcut('mouseleave');
var mouseout = shortcut('mouseout');
var mouseover = shortcut('mouseover');
var touchstart = shortcut('touchstart');
var touchend = shortcut('touchend');
var touchmove = shortcut('touchmove');
var resize = shortcut('resize');
var dom7_esm_scroll = shortcut('scroll');
/* harmony default export */ const dom7_esm = ((/* unused pure expression or super */ null && (dom7_esm_$)));

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/dom.js

var Methods = {
  addClass: addClass,
  removeClass: removeClass,
  hasClass: hasClass,
  toggleClass: toggleClass,
  attr: attr,
  removeAttr: removeAttr,
  transform: transform,
  transition: transition,
  on: on,
  off: off,
  trigger: trigger,
  transitionEnd: transitionEnd,
  outerWidth: dom7_esm_outerWidth,
  outerHeight: dom7_esm_outerHeight,
  styles: styles,
  offset: offset,
  css: css,
  each: each,
  html: html,
  text: dom7_esm_text,
  is: is,
  index: index,
  eq: eq,
  append: append,
  prepend: prepend,
  next: next,
  nextAll: nextAll,
  prev: prev,
  prevAll: prevAll,
  parent: dom7_esm_parent,
  parents: parents,
  closest: closest,
  find: find,
  children: children,
  filter: filter,
  remove: remove
};
Object.keys(Methods).forEach(function (methodName) {
  Object.defineProperty(dom7_esm_$.fn, methodName, {
    value: Methods[methodName],
    writable: true
  });
});
/* harmony default export */ const dom = (dom7_esm_$);
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/utils.js


function deleteProps(obj) {
  var object = obj;
  Object.keys(object).forEach(function (key) {
    try {
      object[key] = null;
    } catch (e) {
      // no getter for object
    }
    try {
      delete object[key];
    } catch (e) {
      // something got wrong
    }
  });
}
function nextTick(callback) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function utils_getComputedStyle(el) {
  var window = ssr_window_esm_getWindow();
  var style;
  if (window.getComputedStyle) {
    style = window.getComputedStyle(el, null);
  }
  if (!style && el.currentStyle) {
    style = el.currentStyle;
  }
  if (!style) {
    style = el.style;
  }
  return style;
}
function getTranslate(el) {
  var axis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
  var window = ssr_window_esm_getWindow();
  var matrix;
  var curTransform;
  var transformMatrix;
  var curStyle = utils_getComputedStyle(el, null);
  if (window.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(',').length > 6) {
      curTransform = curTransform.split(', ').map(function (a) {
        return a.replace(',', '.');
      }).join(', ');
    }
    // Some old versions of Webkit choke when 'none' is passed; pass
    // empty string instead in this case
    transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
    matrix = transformMatrix.toString().split(',');
  }
  if (axis === 'x') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[4]);
  }
  if (axis === 'y') {
    // Latest Chrome and webkits Fix
    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
    // Crazy IE10 Matrix
    else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
    // Normal Browsers
    else curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function utils_isObject(o) {
  return (0,esm_typeof/* default */.Z)(o) === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
}
function utils_extend() {
  var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
  var noExtend = ['__proto__', 'constructor', 'prototype'];
  for (var i = 1; i < arguments.length; i += 1) {
    var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];
    if (nextSource !== undefined && nextSource !== null) {
      var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      });
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== undefined && desc.enumerable) {
          if (utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else if (!utils_isObject(to[nextKey]) && utils_isObject(nextSource[nextKey])) {
            to[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to[nextKey] = nextSource[nextKey];
            } else {
              utils_extend(to[nextKey], nextSource[nextKey]);
            }
          } else {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to;
}
function bindModuleMethods(instance, obj) {
  Object.keys(obj).forEach(function (key) {
    if (utils_isObject(obj[key])) {
      Object.keys(obj[key]).forEach(function (subKey) {
        if (typeof obj[key][subKey] === 'function') {
          obj[key][subKey] = obj[key][subKey].bind(instance);
        }
      });
    }
    instance[key] = obj[key];
  });
}
function classesToSelector() {
  var classes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return ".".concat(classes.trim().replace(/([\.:\/])/g, '\\$1') // eslint-disable-line
  .replace(/ /g, '.'));
}

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-support.js

var support;
function calcSupport() {
  var window = ssr_window_esm_getWindow();
  var document = getDocument();
  return {
    touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
    pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
    observer: function checkObserver() {
      return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
    }(),
    passiveListener: function checkPassiveListener() {
      var supportsPassive = false;
      try {
        var opts = Object.defineProperty({}, 'passive', {
          // eslint-disable-next-line
          get: function get() {
            supportsPassive = true;
          }
        });
        window.addEventListener('testPassiveListener', null, opts);
      } catch (e) {
        // No support
      }
      return supportsPassive;
    }(),
    gestures: function checkGestures() {
      return 'ongesturestart' in window;
    }()
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-device.js


var device;
function calcDevice() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    userAgent = _ref.userAgent;
  var support = getSupport();
  var window = ssr_window_esm_getWindow();
  var platform = window.navigator.platform;
  var ua = userAgent || window.navigator.userAgent;
  var device = {
    ios: false,
    android: false
  };
  var screenWidth = window.screen.width;
  var screenHeight = window.screen.height;
  var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
  var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
  var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
  var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  var windows = platform === 'Win32';
  var macos = platform === 'MacIntel';

  // iPadOs 13 fix
  var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];
  if (!ipad && macos && support.touch && iPadScreens.indexOf("".concat(screenWidth, "x").concat(screenHeight)) >= 0) {
    ipad = ua.match(/(Version)\/([\d.]+)/);
    if (!ipad) ipad = [0, 1, '13_0_0'];
    macos = false;
  }

  // Android
  if (android && !windows) {
    device.os = 'android';
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = 'ios';
    device.ios = true;
  }

  // Export object
  return device;
}
function getDevice() {
  var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  if (!device) {
    device = calcDevice(overrides);
  }
  return device;
}

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/utils/get-browser.js

var get_browser_browser;
function calcBrowser() {
  var window = ssr_window_esm_getWindow();
  function isSafari() {
    var ua = window.navigator.userAgent.toLowerCase();
    return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
  }
  return {
    isEdge: !!window.navigator.userAgent.match(/Edge/g),
    isSafari: isSafari(),
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
  };
}
function getBrowser() {
  if (!get_browser_browser) {
    get_browser_browser = calcBrowser();
  }
  return get_browser_browser;
}

;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/modules/resize/resize.js


var supportsResizeObserver = function supportsResizeObserver() {
  var window = ssr_window_esm_getWindow();
  return typeof window.ResizeObserver !== 'undefined';
};
/* harmony default export */ const resize_resize = ({
  name: 'resize',
  create: function create() {
    var swiper = this;
    utils_extend(swiper, {
      resize: {
        observer: null,
        createObserver: function createObserver() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.resize.observer = new ResizeObserver(function (entries) {
            var width = swiper.width,
              height = swiper.height;
            var newWidth = width;
            var newHeight = height;
            entries.forEach(function (_ref) {
              var contentBoxSize = _ref.contentBoxSize,
                contentRect = _ref.contentRect,
                target = _ref.target;
              if (target && target !== swiper.el) return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width || newHeight !== height) {
              swiper.resize.resizeHandler();
            }
          });
          swiper.resize.observer.observe(swiper.el);
        },
        removeObserver: function removeObserver() {
          if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
            swiper.resize.observer.unobserve(swiper.el);
            swiper.resize.observer = null;
          }
        },
        resizeHandler: function resizeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('beforeResize');
          swiper.emit('resize');
        },
        orientationChangeHandler: function orientationChangeHandler() {
          if (!swiper || swiper.destroyed || !swiper.initialized) return;
          swiper.emit('orientationchange');
        }
      }
    });
  },
  on: {
    init: function init(swiper) {
      var window = ssr_window_esm_getWindow();
      if (swiper.params.resizeObserver && supportsResizeObserver()) {
        swiper.resize.createObserver();
        return;
      }
      // Emit resize
      window.addEventListener('resize', swiper.resize.resizeHandler);

      // Emit orientationchange
      window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    },
    destroy: function destroy(swiper) {
      var window = ssr_window_esm_getWindow();
      swiper.resize.removeObserver();
      window.removeEventListener('resize', swiper.resize.resizeHandler);
      window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/modules/observer/observer.js

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


var Observer = {
  attach: function attach(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var window = ssr_window_esm_getWindow();
    var swiper = this;
    var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
    var observer = new ObserverFunc(function (mutations) {
      // The observerUpdate event should only be triggered
      // once despite the number of mutations.  Additional
      // triggers are redundant and are very costly
      if (mutations.length === 1) {
        swiper.emit('observerUpdate', mutations[0]);
        return;
      }
      var observerUpdate = function observerUpdate() {
        swiper.emit('observerUpdate', mutations[0]);
      };
      if (window.requestAnimationFrame) {
        window.requestAnimationFrame(observerUpdate);
      } else {
        window.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
      childList: typeof options.childList === 'undefined' ? true : options.childList,
      characterData: typeof options.characterData === 'undefined' ? true : options.characterData
    });
    swiper.observer.observers.push(observer);
  },
  init: function init() {
    var swiper = this;
    if (!swiper.support.observer || !swiper.params.observer) return;
    if (swiper.params.observeParents) {
      var containerParents = swiper.$el.parents();
      for (var i = 0; i < containerParents.length; i += 1) {
        swiper.observer.attach(containerParents[i]);
      }
    }
    // Observe container
    swiper.observer.attach(swiper.$el[0], {
      childList: swiper.params.observeSlideChildren
    });

    // Observe wrapper
    swiper.observer.attach(swiper.$wrapperEl[0], {
      attributes: false
    });
  },
  destroy: function destroy() {
    var swiper = this;
    swiper.observer.observers.forEach(function (observer) {
      observer.disconnect();
    });
    swiper.observer.observers = [];
  }
};
/* harmony default export */ const observer = ({
  name: 'observer',
  params: {
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  },
  create: function create() {
    var swiper = this;
    bindModuleMethods(swiper, {
      observer: _objectSpread(_objectSpread({}, Observer), {}, {
        observers: []
      })
    });
  },
  on: {
    init: function init(swiper) {
      swiper.observer.init();
    },
    destroy: function destroy(swiper) {
      swiper.observer.destroy();
    }
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/modular.js

/* harmony default export */ const modular = ({
  useParams: function useParams(instanceParams) {
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      // Extend params
      if (module.params) {
        utils_extend(instanceParams, module.params);
      }
    });
  },
  useModules: function useModules() {
    var modulesParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var instance = this;
    if (!instance.modules) return;
    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {};

      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }

      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  }
});
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events-emitter.js

/* eslint-disable no-underscore-dangle */

/* harmony default export */ const events_emitter = ({
  on: function on(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
      self.eventsListeners[event][method](handler);
    });
    return self;
  },
  once: function once(events, handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    function onceHandler() {
      self.off(events, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self, args);
    }
    onceHandler.__emitterProxy = handler;
    return self.on(events, onceHandler, priority);
  },
  onAny: function onAny(handler, priority) {
    var self = this;
    if (typeof handler !== 'function') return self;
    var method = priority ? 'unshift' : 'push';
    if (self.eventsAnyListeners.indexOf(handler) < 0) {
      self.eventsAnyListeners[method](handler);
    }
    return self;
  },
  offAny: function offAny(handler) {
    var self = this;
    if (!self.eventsAnyListeners) return self;
    var index = self.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self.eventsAnyListeners.splice(index, 1);
    }
    return self;
  },
  off: function off(events, handler) {
    var self = this;
    if (!self.eventsListeners) return self;
    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  },
  emit: function emit() {
    var self = this;
    if (!self.eventsListeners) return self;
    var events;
    var data;
    var context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }
    data.unshift(context);
    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
        self.eventsAnyListeners.forEach(function (eventHandler) {
          eventHandler.apply(context, [event].concat(_toConsumableArray(data)));
        });
      }
      if (self.eventsListeners && self.eventsListeners[event]) {
        self.eventsListeners[event].forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  }
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSize.js

function updateSize() {
  var swiper = this;
  var width;
  var height;
  var $el = swiper.$el;
  if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
    width = swiper.params.width;
  } else {
    width = $el[0].clientWidth;
  }
  if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
    height = swiper.params.height;
  } else {
    height = $el[0].clientHeight;
  }
  if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
    return;
  }

  // Subtract paddings
  width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
  height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
  if (Number.isNaN(width)) width = 0;
  if (Number.isNaN(height)) height = 0;
  utils_extend(swiper, {
    width: width,
    height: height,
    size: swiper.isHorizontal() ? width : height
  });
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlides.js


function updateSlides() {
  var swiper = this;
  var getDirectionLabel = function getDirectionLabel(property) {
    if (swiper.isHorizontal()) {
      return property;
    }
    // prettier-ignore
    return {
      'width': 'height',
      'margin-top': 'margin-left',
      'margin-bottom ': 'margin-right',
      'margin-left': 'margin-top',
      'margin-right': 'margin-bottom',
      'padding-left': 'padding-top',
      'padding-right': 'padding-bottom',
      'marginRight': 'marginBottom'
    }[property];
  };
  var getDirectionPropertyValue = function getDirectionPropertyValue(node, label) {
    return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
  };
  var params = swiper.params;
  var $wrapperEl = swiper.$wrapperEl,
    swiperSize = swiper.size,
    rtl = swiper.rtlTranslate,
    wrongRTL = swiper.wrongRTL;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
  var slides = $wrapperEl.children(".".concat(swiper.params.slideClass));
  var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
  var snapGrid = [];
  var slidesGrid = [];
  var slidesSizesGrid = [];
  function slidesForMargin(slideEl, slideIndex) {
    if (!params.cssMode) return true;
    if (slideIndex === slides.length - 1) {
      return false;
    }
    return true;
  }
  var offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === 'function') {
    offsetBefore = params.slidesOffsetBefore.call(swiper);
  }
  var offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === 'function') {
    offsetAfter = params.slidesOffsetAfter.call(swiper);
  }
  var previousSnapGridLength = swiper.snapGrid.length;
  var previousSlidesGridLength = swiper.slidesGrid.length;
  var spaceBetween = params.spaceBetween;
  var slidePosition = -offsetBefore;
  var prevSlideSize = 0;
  var index = 0;
  if (typeof swiperSize === 'undefined') {
    return;
  }
  if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
  }
  swiper.virtualSize = -spaceBetween;

  // reset margins
  if (rtl) slides.css({
    marginLeft: '',
    marginTop: ''
  });else slides.css({
    marginRight: '',
    marginBottom: ''
  });
  var slidesNumberEvenToRows;
  if (params.slidesPerColumn > 1) {
    if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
      slidesNumberEvenToRows = slidesLength;
    } else {
      slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
    }
    if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
      slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
    }
  }

  // Calc slides
  var slideSize;
  var slidesPerColumn = params.slidesPerColumn;
  var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
  var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
  for (var i = 0; i < slidesLength; i += 1) {
    slideSize = 0;
    var slide = slides.eq(i);
    if (params.slidesPerColumn > 1) {
      // Set slides order
      var newSlideOrderIndex = void 0;
      var column = void 0;
      var row = void 0;
      if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
        var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
        var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
        var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
        row = Math.floor(slideIndexInGroup / columnsInGroup);
        column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
        newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
        slide.css({
          '-webkit-box-ordinal-group': newSlideOrderIndex,
          '-moz-box-ordinal-group': newSlideOrderIndex,
          '-ms-flex-order': newSlideOrderIndex,
          '-webkit-order': newSlideOrderIndex,
          order: newSlideOrderIndex
        });
      } else if (params.slidesPerColumnFill === 'column') {
        column = Math.floor(i / slidesPerColumn);
        row = i - column * slidesPerColumn;
        if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
          row += 1;
          if (row >= slidesPerColumn) {
            row = 0;
            column += 1;
          }
        }
      } else {
        row = Math.floor(i / slidesPerRow);
        column = i - row * slidesPerRow;
      }
      slide.css(getDirectionLabel('margin-top'), row !== 0 && params.spaceBetween && "".concat(params.spaceBetween, "px"));
    }
    if (slide.css('display') === 'none') continue; // eslint-disable-line

    if (params.slidesPerView === 'auto') {
      var slideStyles = getComputedStyle(slide[0]);
      var currentTransform = slide[0].style.transform;
      var currentWebKitTransform = slide[0].style.webkitTransform;
      if (currentTransform) {
        slide[0].style.transform = 'none';
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = 'none';
      }
      if (params.roundLengths) {
        slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
      } else {
        // eslint-disable-next-line
        var width = getDirectionPropertyValue(slideStyles, 'width');
        var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
        var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
        var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
        var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
        var boxSizing = slideStyles.getPropertyValue('box-sizing');
        if (boxSizing && boxSizing === 'border-box') {
          slideSize = width + marginLeft + marginRight;
        } else {
          var _slide$ = slide[0],
            clientWidth = _slide$.clientWidth,
            offsetWidth = _slide$.offsetWidth;
          slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide[0].style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide[0].style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths) slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths) slideSize = Math.floor(slideSize);
      if (slides[i]) {
        slides[i].style[getDirectionLabel('width')] = "".concat(slideSize, "px");
      }
    }
    if (slides[i]) {
      slides[i].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths) slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
  var newSlidesGrid;
  if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
    $wrapperEl.css({
      width: "".concat(swiper.virtualSize + params.spaceBetween, "px")
    });
  }
  if (params.setWrapperSize) {
    $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + params.spaceBetween, "px")));
  }
  if (params.slidesPerColumn > 1) {
    swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
    swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
    $wrapperEl.css(_defineProperty({}, getDirectionLabel('width'), "".concat(swiper.virtualSize + params.spaceBetween, "px")));
    if (params.centeredSlides) {
      newSlidesGrid = [];
      for (var _i = 0; _i < snapGrid.length; _i += 1) {
        var slidesGridItem = snapGrid[_i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
      }
      snapGrid = newSlidesGrid;
    }
  }

  // Remove last grid elements depending on width
  if (!params.centeredSlides) {
    newSlidesGrid = [];
    for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
      var _slidesGridItem = snapGrid[_i2];
      if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);
      if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
        newSlidesGrid.push(_slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper.virtualSize - swiperSize);
    }
  }
  if (snapGrid.length === 0) snapGrid = [0];
  if (params.spaceBetween !== 0) {
    var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
    slides.filter(slidesForMargin).css(_defineProperty({}, key, "".concat(spaceBetween, "px")));
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    var allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    allSlidesSize -= params.spaceBetween;
    var maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map(function (snap) {
      if (snap < 0) return -offsetBefore;
      if (snap > maxSnap) return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    var _allSlidesSize = 0;
    slidesSizesGrid.forEach(function (slideSizeValue) {
      _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
    });
    _allSlidesSize -= params.spaceBetween;
    if (_allSlidesSize < swiperSize) {
      var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
      snapGrid.forEach(function (snap, snapIndex) {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach(function (snap, snapIndex) {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  utils_extend(swiper, {
    slides: slides,
    snapGrid: snapGrid,
    slidesGrid: slidesGrid,
    slidesSizesGrid: slidesSizesGrid
  });
  if (slidesLength !== previousSlidesLength) {
    swiper.emit('slidesLengthChange');
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper.params.watchOverflow) swiper.checkOverflow();
    swiper.emit('snapGridLengthChange');
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper.emit('slidesGridLengthChange');
  }
  if (params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateSlidesOffset();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateAutoHeight.js
function updateAutoHeight(speed) {
  var swiper = this;
  var activeSlides = [];
  var newHeight = 0;
  var i;
  if (typeof speed === 'number') {
    swiper.setTransition(speed);
  } else if (speed === true) {
    swiper.setTransition(swiper.params.speed);
  }
  // Find slides currently in view
  if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
    if (swiper.params.centeredSlides) {
      swiper.visibleSlides.each(function (slide) {
        activeSlides.push(slide);
      });
    } else {
      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
        var index = swiper.activeIndex + i;
        if (index > swiper.slides.length) break;
        activeSlides.push(swiper.slides.eq(index)[0]);
      }
    }
  } else {
    activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
  }

  // Find new height from highest slide in view
  for (i = 0; i < activeSlides.length; i += 1) {
    if (typeof activeSlides[i] !== 'undefined') {
      var height = activeSlides[i].offsetHeight;
      newHeight = height > newHeight ? height : newHeight;
    }
  }

  // Update Height
  if (newHeight) swiper.$wrapperEl.css('height', "".concat(newHeight, "px"));
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesOffset.js
function updateSlidesOffset() {
  var swiper = this;
  var slides = swiper.slides;
  for (var i = 0; i < slides.length; i += 1) {
    slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesProgress.js

function updateSlidesProgress() {
  var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this && this.translate || 0;
  var swiper = this;
  var params = swiper.params;
  var slides = swiper.slides,
    rtl = swiper.rtlTranslate;
  if (slides.length === 0) return;
  if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
  var offsetCenter = -translate;
  if (rtl) offsetCenter = translate;

  // Visible Slides
  slides.removeClass(params.slideVisibleClass);
  swiper.visibleSlidesIndexes = [];
  swiper.visibleSlides = [];
  for (var i = 0; i < slides.length; i += 1) {
    var slide = slides[i];
    var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);
    if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
      var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
      var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
      if (isVisible) {
        swiper.visibleSlides.push(slide);
        swiper.visibleSlidesIndexes.push(i);
        slides.eq(i).addClass(params.slideVisibleClass);
      }
    }
    slide.progress = rtl ? -slideProgress : slideProgress;
  }
  swiper.visibleSlides = dom(swiper.visibleSlides);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateProgress.js

function updateProgress(translate) {
  var swiper = this;
  if (typeof translate === 'undefined') {
    var multiplier = swiper.rtlTranslate ? -1 : 1;
    // eslint-disable-next-line
    translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
  }
  var params = swiper.params;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  var progress = swiper.progress,
    isBeginning = swiper.isBeginning,
    isEnd = swiper.isEnd;
  var wasBeginning = isBeginning;
  var wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate - swiper.minTranslate()) / translatesDiff;
    isBeginning = progress <= 0;
    isEnd = progress >= 1;
  }
  utils_extend(swiper, {
    progress: progress,
    isBeginning: isBeginning,
    isEnd: isEnd
  });
  if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
  if (isBeginning && !wasBeginning) {
    swiper.emit('reachBeginning toEdge');
  }
  if (isEnd && !wasEnd) {
    swiper.emit('reachEnd toEdge');
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper.emit('fromEdge');
  }
  swiper.emit('progress', progress);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateSlidesClasses.js
function updateSlidesClasses() {
  var swiper = this;
  var slides = swiper.slides,
    params = swiper.params,
    $wrapperEl = swiper.$wrapperEl,
    activeIndex = swiper.activeIndex,
    realIndex = swiper.realIndex;
  var isVirtual = swiper.virtual && params.virtual.enabled;
  slides.removeClass("".concat(params.slideActiveClass, " ").concat(params.slideNextClass, " ").concat(params.slidePrevClass, " ").concat(params.slideDuplicateActiveClass, " ").concat(params.slideDuplicateNextClass, " ").concat(params.slideDuplicatePrevClass));
  var activeSlide;
  if (isVirtual) {
    activeSlide = swiper.$wrapperEl.find(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(activeIndex, "\"]"));
  } else {
    activeSlide = slides.eq(activeIndex);
  }

  // Active classes
  activeSlide.addClass(params.slideActiveClass);
  if (params.loop) {
    // Duplicate to all looped slides
    if (activeSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]")).addClass(params.slideDuplicateActiveClass);
    }
  }
  // Next Slide
  var nextSlide = activeSlide.nextAll(".".concat(params.slideClass)).eq(0).addClass(params.slideNextClass);
  if (params.loop && nextSlide.length === 0) {
    nextSlide = slides.eq(0);
    nextSlide.addClass(params.slideNextClass);
  }
  // Prev Slide
  var prevSlide = activeSlide.prevAll(".".concat(params.slideClass)).eq(0).addClass(params.slidePrevClass);
  if (params.loop && prevSlide.length === 0) {
    prevSlide = slides.eq(-1);
    prevSlide.addClass(params.slidePrevClass);
  }
  if (params.loop) {
    // Duplicate to all looped slides
    if (nextSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(nextSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicateNextClass);
    }
    if (prevSlide.hasClass(params.slideDuplicateClass)) {
      $wrapperEl.children(".".concat(params.slideClass, ":not(.").concat(params.slideDuplicateClass, ")[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
    } else {
      $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, "[data-swiper-slide-index=\"").concat(prevSlide.attr('data-swiper-slide-index'), "\"]")).addClass(params.slideDuplicatePrevClass);
    }
  }
  swiper.emitSlidesClasses();
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateActiveIndex.js

function updateActiveIndex(newActiveIndex) {
  var swiper = this;
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  var slidesGrid = swiper.slidesGrid,
    snapGrid = swiper.snapGrid,
    params = swiper.params,
    previousIndex = swiper.activeIndex,
    previousRealIndex = swiper.realIndex,
    previousSnapIndex = swiper.snapIndex;
  var activeIndex = newActiveIndex;
  var snapIndex;
  if (typeof activeIndex === 'undefined') {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
          activeIndex = i;
        } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
          activeIndex = i + 1;
        }
      } else if (translate >= slidesGrid[i]) {
        activeIndex = i;
      }
    }
    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
    }
  }
  if (snapGrid.indexOf(translate) >= 0) {
    snapIndex = snapGrid.indexOf(translate);
  } else {
    var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper.snapIndex = snapIndex;
      swiper.emit('snapIndexChange');
    }
    return;
  }

  // Get real index
  var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
  utils_extend(swiper, {
    snapIndex: snapIndex,
    realIndex: realIndex,
    previousIndex: previousIndex,
    activeIndex: activeIndex
  });
  swiper.emit('activeIndexChange');
  swiper.emit('snapIndexChange');
  if (previousRealIndex !== realIndex) {
    swiper.emit('realIndexChange');
  }
  if (swiper.initialized || swiper.params.runCallbacksOnInit) {
    swiper.emit('slideChange');
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/updateClickedSlide.js

function updateClickedSlide(e) {
  var swiper = this;
  var params = swiper.params;
  var slide = dom(e.target).closest(".".concat(params.slideClass))[0];
  var slideFound = false;
  var slideIndex;
  if (slide) {
    for (var i = 0; i < swiper.slides.length; i += 1) {
      if (swiper.slides[i] === slide) {
        slideFound = true;
        slideIndex = i;
        break;
      }
    }
  }
  if (slide && slideFound) {
    swiper.clickedSlide = slide;
    if (swiper.virtual && swiper.params.virtual.enabled) {
      swiper.clickedIndex = parseInt(dom(slide).attr('data-swiper-slide-index'), 10);
    } else {
      swiper.clickedIndex = slideIndex;
    }
  } else {
    swiper.clickedSlide = undefined;
    swiper.clickedIndex = undefined;
    return;
  }
  if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
    swiper.slideToClickedSlide();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/update/index.js









/* harmony default export */ const update = ({
  updateSize: updateSize,
  updateSlides: updateSlides,
  updateAutoHeight: updateAutoHeight,
  updateSlidesOffset: updateSlidesOffset,
  updateSlidesProgress: updateSlidesProgress,
  updateProgress: updateProgress,
  updateSlidesClasses: updateSlidesClasses,
  updateActiveIndex: updateActiveIndex,
  updateClickedSlide: updateClickedSlide
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/getTranslate.js

function getSwiperTranslate() {
  var axis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isHorizontal() ? 'x' : 'y';
  var swiper = this;
  var params = swiper.params,
    rtl = swiper.rtlTranslate,
    translate = swiper.translate,
    $wrapperEl = swiper.$wrapperEl;
  if (params.virtualTranslate) {
    return rtl ? -translate : translate;
  }
  if (params.cssMode) {
    return translate;
  }
  var currentTranslate = getTranslate($wrapperEl[0], axis);
  if (rtl) currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/setTranslate.js
function setTranslate(translate, byController) {
  var swiper = this;
  var rtl = swiper.rtlTranslate,
    params = swiper.params,
    $wrapperEl = swiper.$wrapperEl,
    wrapperEl = swiper.wrapperEl,
    progress = swiper.progress;
  var x = 0;
  var y = 0;
  var z = 0;
  if (swiper.isHorizontal()) {
    x = rtl ? -translate : translate;
  } else {
    y = translate;
  }
  if (params.roundLengths) {
    x = Math.floor(x);
    y = Math.floor(y);
  }
  if (params.cssMode) {
    wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
  } else if (!params.virtualTranslate) {
    $wrapperEl.transform("translate3d(".concat(x, "px, ").concat(y, "px, ").concat(z, "px)"));
  }
  swiper.previousTranslate = swiper.translate;
  swiper.translate = swiper.isHorizontal() ? x : y;

  // Check if we need to update progress
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper.updateProgress(translate);
  }
  swiper.emit('setTranslate', swiper.translate, byController);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/minTranslate.js
function minTranslate() {
  return -this.snapGrid[0];
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/maxTranslate.js
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/translateTo.js

function translateTo() {
  var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var translateBounds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var internal = arguments.length > 4 ? arguments[4] : undefined;
  var swiper = this;
  var params = swiper.params,
    wrapperEl = swiper.wrapperEl;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  var minTranslate = swiper.minTranslate();
  var maxTranslate = swiper.maxTranslate();
  var newTranslate;
  if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate;

  // Update progress
  swiper.updateProgress(newTranslate);
  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;
        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', -newTranslate), _defineProperty(_wrapperEl$scrollTo, "behavior", 'smooth'), _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      }
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionEnd');
    }
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.emit('transitionStart');
    }
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onTranslateToWrapperTransitionEnd) {
        swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
          swiper.onTranslateToWrapperTransitionEnd = null;
          delete swiper.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper.emit('transitionEnd');
          }
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/translate/index.js





/* harmony default export */ const translate = ({
  getTranslate: getSwiperTranslate,
  setTranslate: setTranslate,
  minTranslate: minTranslate,
  maxTranslate: maxTranslate,
  translateTo: translateTo
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/setTransition.js
function setTransition(duration, byController) {
  var swiper = this;
  if (!swiper.params.cssMode) {
    swiper.$wrapperEl.transition(duration);
  }
  swiper.emit('setTransition', duration, byController);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/transitionStart.js
function transitionStart() {
  var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var direction = arguments.length > 1 ? arguments[1] : undefined;
  var swiper = this;
  var activeIndex = swiper.activeIndex,
    params = swiper.params,
    previousIndex = swiper.previousIndex;
  if (params.cssMode) return;
  if (params.autoHeight) {
    swiper.updateAutoHeight();
  }
  var dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit('transitionStart');
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionStart');
      return;
    }
    swiper.emit('slideChangeTransitionStart');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionStart');
    } else {
      swiper.emit('slidePrevTransitionStart');
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/transitionEnd.js
function transitionEnd_transitionEnd() {
  var runCallbacks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var direction = arguments.length > 1 ? arguments[1] : undefined;
  var swiper = this;
  var activeIndex = swiper.activeIndex,
    previousIndex = swiper.previousIndex,
    params = swiper.params;
  swiper.animating = false;
  if (params.cssMode) return;
  swiper.setTransition(0);
  var dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
  }
  swiper.emit('transitionEnd');
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === 'reset') {
      swiper.emit('slideResetTransitionEnd');
      return;
    }
    swiper.emit('slideChangeTransitionEnd');
    if (dir === 'next') {
      swiper.emit('slideNextTransitionEnd');
    } else {
      swiper.emit('slidePrevTransitionEnd');
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/transition/index.js



/* harmony default export */ const core_transition = ({
  setTransition: setTransition,
  transitionStart: transitionStart,
  transitionEnd: transitionEnd_transitionEnd
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideTo.js


function slideTo() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var internal = arguments.length > 3 ? arguments[3] : undefined;
  if (typeof index !== 'number' && typeof index !== 'string') {
    throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [".concat((0,esm_typeof/* default */.Z)(index), "] given."));
  }
  if (typeof index === 'string') {
    /**
     * The `index` argument converted from `string` to `number`.
     * @type {number}
     */
    var indexAsNumber = parseInt(index, 10);

    /**
     * Determines whether the `index` argument is a valid `number`
     * after being converted from the `string` type.
     * @type {boolean}
     */
    var isValidNumber = isFinite(indexAsNumber);
    if (!isValidNumber) {
      throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [".concat(index, "] given."));
    }

    // Knowing that the converted `index` is a valid number,
    // we can update the original argument's value.
    index = indexAsNumber;
  }
  var swiper = this;
  var slideIndex = index;
  if (slideIndex < 0) slideIndex = 0;
  var params = swiper.params,
    snapGrid = swiper.snapGrid,
    slidesGrid = swiper.slidesGrid,
    previousIndex = swiper.previousIndex,
    activeIndex = swiper.activeIndex,
    rtl = swiper.rtlTranslate,
    wrapperEl = swiper.wrapperEl;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return false;
  }
  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
    swiper.emit('beforeSlideChangeStart');
  }
  var translate = -snapGrid[snapIndex];

  // Update progress
  swiper.updateProgress(translate);

  // Normalize slideIndex
  if (params.normalizeSlideIndex) {
    for (var i = 0; i < slidesGrid.length; i += 1) {
      var normalizedTranslate = -Math.floor(translate * 100);
      var normalizedGird = Math.floor(slidesGrid[i] * 100);
      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
      if (typeof slidesGrid[i + 1] !== 'undefined') {
        if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
          slideIndex = i;
        } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
          slideIndex = i + 1;
        }
      } else if (normalizedTranslate >= normalizedGird) {
        slideIndex = i;
      }
    }
  }
  // Directions locks
  if (swiper.initialized && slideIndex !== activeIndex) {
    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
      return false;
    }
    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) return false;
    }
  }
  var direction;
  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';

  // Update Index
  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
    swiper.updateActiveIndex(slideIndex);
    // Update Height
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }
    swiper.updateSlidesClasses();
    if (params.effect !== 'slide') {
      swiper.setTranslate(translate);
    }
    if (direction !== 'reset') {
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    var isH = swiper.isHorizontal();
    var t = -translate;
    if (rtl) {
      t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
    }
    if (speed === 0) {
      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
    } else {
      // eslint-disable-next-line
      if (wrapperEl.scrollTo) {
        var _wrapperEl$scrollTo;
        wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo, "behavior", 'smooth'), _wrapperEl$scrollTo));
      } else {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      }
    }
    return true;
  }
  if (speed === 0) {
    swiper.setTransition(0);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    swiper.transitionEnd(runCallbacks, direction);
  } else {
    swiper.setTransition(speed);
    swiper.setTranslate(translate);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit('beforeTransitionStart', speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (!swiper.animating) {
      swiper.animating = true;
      if (!swiper.onSlideToWrapperTransitionEnd) {
        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
          if (!swiper || swiper.destroyed) return;
          if (e.target !== this) return;
          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
          swiper.onSlideToWrapperTransitionEnd = null;
          delete swiper.onSlideToWrapperTransitionEnd;
          swiper.transitionEnd(runCallbacks, direction);
        };
      }
      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
    }
  }
  return true;
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToLoop.js
function slideToLoop() {
  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;
  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var internal = arguments.length > 3 ? arguments[3] : undefined;
  var swiper = this;
  var newIndex = index;
  if (swiper.params.loop) {
    newIndex += swiper.loopedSlides;
  }
  return swiper.slideTo(newIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideNext.js
/* eslint no-unused-vars: "off" */
function slideNext() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  var params = swiper.params,
    animating = swiper.animating;
  var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slidePrev.js
/* eslint no-unused-vars: "off" */
function slidePrev() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  var params = swiper.params,
    animating = swiper.animating,
    snapGrid = swiper.snapGrid,
    slidesGrid = swiper.slidesGrid,
    rtlTranslate = swiper.rtlTranslate;
  if (params.loop) {
    if (animating && params.loopPreventsSlide) return false;
    swiper.loopFix();
    // eslint-disable-next-line
    swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
  }
  var translate = rtlTranslate ? swiper.translate : -swiper.translate;
  function normalize(val) {
    if (val < 0) return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  var normalizedTranslate = normalize(translate);
  var normalizedSnapGrid = snapGrid.map(function (val) {
    return normalize(val);
  });
  var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
  var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === 'undefined' && params.cssMode) {
    snapGrid.forEach(function (snap) {
      if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
    });
  }
  var prevIndex;
  if (typeof prevSnap !== 'undefined') {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
  }
  return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideReset.js
/* eslint no-unused-vars: "off" */
function slideReset() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var swiper = this;
  return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToClosest.js
/* eslint no-unused-vars: "off" */
function slideToClosest() {
  var speed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.params.speed;
  var runCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var internal = arguments.length > 2 ? arguments[2] : undefined;
  var threshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
  var swiper = this;
  var index = swiper.activeIndex;
  var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
  var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
  var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
  if (translate >= swiper.snapGrid[snapIndex]) {
    // The current translate is on or after the current snap index, so the choice
    // is between the current index and the one after it.
    var currentSnap = swiper.snapGrid[snapIndex];
    var nextSnap = swiper.snapGrid[snapIndex + 1];
    if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper.params.slidesPerGroup;
    }
  } else {
    // The current translate is before the current snap index, so the choice
    // is between the current index and the one before it.
    var prevSnap = swiper.snapGrid[snapIndex - 1];
    var _currentSnap = swiper.snapGrid[snapIndex];
    if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
      index -= swiper.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper.slidesGrid.length - 1);
  return swiper.slideTo(index, speed, runCallbacks, internal);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/slideToClickedSlide.js


function slideToClickedSlide() {
  var swiper = this;
  var params = swiper.params,
    $wrapperEl = swiper.$wrapperEl;
  var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
  var slideToIndex = swiper.clickedIndex;
  var realIndex;
  if (params.loop) {
    if (swiper.animating) return;
    realIndex = parseInt(dom(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
        nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
      swiper.loopFix();
      slideToIndex = $wrapperEl.children(".".concat(params.slideClass, "[data-swiper-slide-index=\"").concat(realIndex, "\"]:not(.").concat(params.slideDuplicateClass, ")")).eq(0).index();
      nextTick(function () {
        swiper.slideTo(slideToIndex);
      });
    } else {
      swiper.slideTo(slideToIndex);
    }
  } else {
    swiper.slideTo(slideToIndex);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/slide/index.js







/* harmony default export */ const slide = ({
  slideTo: slideTo,
  slideToLoop: slideToLoop,
  slideNext: slideNext,
  slidePrev: slidePrev,
  slideReset: slideReset,
  slideToClosest: slideToClosest,
  slideToClickedSlide: slideToClickedSlide
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopCreate.js


function loopCreate() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
    $wrapperEl = swiper.$wrapperEl;
  // Remove duplicated slides
  $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass)).remove();
  var slides = $wrapperEl.children(".".concat(params.slideClass));
  if (params.loopFillGroupWithBlank) {
    var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;
    if (blankSlidesNum !== params.slidesPerGroup) {
      for (var i = 0; i < blankSlidesNum; i += 1) {
        var blankNode = dom(document.createElement('div')).addClass("".concat(params.slideClass, " ").concat(params.slideBlankClass));
        $wrapperEl.append(blankNode);
      }
      slides = $wrapperEl.children(".".concat(params.slideClass));
    }
  }
  if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
  swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
  swiper.loopedSlides += params.loopAdditionalSlides;
  if (swiper.loopedSlides > slides.length) {
    swiper.loopedSlides = slides.length;
  }
  var prependSlides = [];
  var appendSlides = [];
  slides.each(function (el, index) {
    var slide = dom(el);
    if (index < swiper.loopedSlides) {
      appendSlides.push(el);
    }
    if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
      prependSlides.push(el);
    }
    slide.attr('data-swiper-slide-index', index);
  });
  for (var _i = 0; _i < appendSlides.length; _i += 1) {
    $wrapperEl.append(dom(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
  for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
    $wrapperEl.prepend(dom(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopFix.js
function loopFix() {
  var swiper = this;
  swiper.emit('beforeLoopFix');
  var activeIndex = swiper.activeIndex,
    slides = swiper.slides,
    loopedSlides = swiper.loopedSlides,
    allowSlidePrev = swiper.allowSlidePrev,
    allowSlideNext = swiper.allowSlideNext,
    snapGrid = swiper.snapGrid,
    rtl = swiper.rtlTranslate;
  var newIndex;
  swiper.allowSlidePrev = true;
  swiper.allowSlideNext = true;
  var snapTranslate = -snapGrid[activeIndex];
  var diff = snapTranslate - swiper.getTranslate();

  // Fix For Negative Oversliding
  if (activeIndex < loopedSlides) {
    newIndex = slides.length - loopedSlides * 3 + activeIndex;
    newIndex += loopedSlides;
    var slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  } else if (activeIndex >= slides.length - loopedSlides) {
    // Fix For Positive Oversliding
    newIndex = -slides.length + activeIndex + loopedSlides;
    newIndex += loopedSlides;
    var _slideChanged = swiper.slideTo(newIndex, 0, false, true);
    if (_slideChanged && diff !== 0) {
      swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
    }
  }
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  swiper.emit('loopFix');
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/loopDestroy.js
function loopDestroy() {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
    params = swiper.params,
    slides = swiper.slides;
  $wrapperEl.children(".".concat(params.slideClass, ".").concat(params.slideDuplicateClass, ",.").concat(params.slideClass, ".").concat(params.slideBlankClass)).remove();
  slides.removeAttr('data-swiper-slide-index');
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/loop/index.js



/* harmony default export */ const loop = ({
  loopCreate: loopCreate,
  loopFix: loopFix,
  loopDestroy: loopDestroy
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/setGrabCursor.js
function setGrabCursor(moving) {
  var swiper = this;
  if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
  var el = swiper.el;
  el.style.cursor = 'move';
  el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
  el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
  el.style.cursor = moving ? 'grabbing' : 'grab';
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/unsetGrabCursor.js
function unsetGrabCursor() {
  var swiper = this;
  if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
    return;
  }
  swiper.el.style.cursor = '';
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/grab-cursor/index.js


/* harmony default export */ const grab_cursor = ({
  setGrabCursor: setGrabCursor,
  unsetGrabCursor: unsetGrabCursor
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/appendSlide.js

function appendSlide(slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
    params = swiper.params;
  if (params.loop) {
    swiper.loopDestroy();
  }
  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.append(slides[i]);
    }
  } else {
    $wrapperEl.append(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/prependSlide.js

function prependSlide(slides) {
  var swiper = this;
  var params = swiper.params,
    $wrapperEl = swiper.$wrapperEl,
    activeIndex = swiper.activeIndex;
  if (params.loop) {
    swiper.loopDestroy();
  }
  var newActiveIndex = activeIndex + 1;
  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var i = 0; i < slides.length; i += 1) {
      if (slides[i]) $wrapperEl.prepend(slides[i]);
    }
    newActiveIndex = activeIndex + slides.length;
  } else {
    $wrapperEl.prepend(slides);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  swiper.slideTo(newActiveIndex, 0, false);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/addSlide.js

function addSlide(index, slides) {
  var swiper = this;
  var $wrapperEl = swiper.$wrapperEl,
    params = swiper.params,
    activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
  }
  var baseLength = swiper.slides.length;
  if (index <= 0) {
    swiper.prependSlide(slides);
    return;
  }
  if (index >= baseLength) {
    swiper.appendSlide(slides);
    return;
  }
  var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
  var slidesBuffer = [];
  for (var i = baseLength - 1; i >= index; i -= 1) {
    var currentSlide = swiper.slides.eq(i);
    currentSlide.remove();
    slidesBuffer.unshift(currentSlide);
  }
  if ((0,esm_typeof/* default */.Z)(slides) === 'object' && 'length' in slides) {
    for (var _i = 0; _i < slides.length; _i += 1) {
      if (slides[_i]) $wrapperEl.append(slides[_i]);
    }
    newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
  } else {
    $wrapperEl.append(slides);
  }
  for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
    $wrapperEl.append(slidesBuffer[_i2]);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/removeSlide.js

function removeSlide(slidesIndexes) {
  var swiper = this;
  var params = swiper.params,
    $wrapperEl = swiper.$wrapperEl,
    activeIndex = swiper.activeIndex;
  var activeIndexBuffer = activeIndex;
  if (params.loop) {
    activeIndexBuffer -= swiper.loopedSlides;
    swiper.loopDestroy();
    swiper.slides = $wrapperEl.children(".".concat(params.slideClass));
  }
  var newActiveIndex = activeIndexBuffer;
  var indexToRemove;
  if ((0,esm_typeof/* default */.Z)(slidesIndexes) === 'object' && 'length' in slidesIndexes) {
    for (var i = 0; i < slidesIndexes.length; i += 1) {
      indexToRemove = slidesIndexes[i];
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    }
    newActiveIndex = Math.max(newActiveIndex, 0);
  } else {
    indexToRemove = slidesIndexes;
    if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
    newActiveIndex = Math.max(newActiveIndex, 0);
  }
  if (params.loop) {
    swiper.loopCreate();
  }
  if (!(params.observer && swiper.support.observer)) {
    swiper.update();
  }
  if (params.loop) {
    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
  } else {
    swiper.slideTo(newActiveIndex, 0, false);
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/removeAllSlides.js
function removeAllSlides() {
  var swiper = this;
  var slidesIndexes = [];
  for (var i = 0; i < swiper.slides.length; i += 1) {
    slidesIndexes.push(i);
  }
  swiper.removeSlide(slidesIndexes);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/manipulation/index.js





/* harmony default export */ const manipulation = ({
  appendSlide: appendSlide,
  prependSlide: prependSlide,
  addSlide: addSlide,
  removeSlide: removeSlide,
  removeAllSlides: removeAllSlides
});
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchStart.js



function onTouchStart(event) {
  var swiper = this;
  var document = getDocument();
  var window = ssr_window_esm_getWindow();
  var data = swiper.touchEventsData;
  var params = swiper.params,
    touches = swiper.touches;
  if (swiper.animating && params.preventInteractionOnTransition) {
    return;
  }
  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  var $targetEl = dom(e.target);
  if (params.touchEventsTarget === 'wrapper') {
    if (!$targetEl.closest(swiper.wrapperEl).length) return;
  }
  data.isTouchEvent = e.type === 'touchstart';
  if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
  if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
  if (data.isTouched && data.isMoved) return;

  // change target el for shadow root componenet
  var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';
  if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
    $targetEl = dom(event.path[0]);
  }
  if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : ".".concat(params.noSwipingClass))[0]) {
    swiper.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!$targetEl.closest(params.swipeHandler)[0]) return;
  }
  touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
  touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
  var startX = touches.currentX;
  var startY = touches.currentY;

  // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

  var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === 'prevent') {
      event.preventDefault();
    } else {
      return;
    }
  }
  utils_extend(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: undefined,
    startMoving: undefined
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper.allowClick = true;
  swiper.updateSize();
  swiper.swipeDirection = undefined;
  if (params.threshold > 0) data.allowThresholdMove = false;
  if (e.type !== 'touchstart') {
    var preventDefault = true;
    if ($targetEl.is(data.formElements)) preventDefault = false;
    if (document.activeElement && dom(document.activeElement).is(data.formElements) && document.activeElement !== $targetEl[0]) {
      document.activeElement.blur();
    }
    var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
      e.preventDefault();
    }
  }
  swiper.emit('touchStart', e);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchMove.js



function onTouchMove(event) {
  var document = getDocument();
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
    touches = swiper.touches,
    rtl = swiper.rtlTranslate;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    return;
  }
  if (data.isTouchEvent && e.type !== 'touchmove') return;
  var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
  var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
  var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
  if (e.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper.allowTouchMove) {
    // isMoved = true;
    swiper.allowClick = false;
    if (data.isTouched) {
      utils_extend(touches, {
        startX: pageX,
        startY: pageY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
    if (swiper.isVertical()) {
      // Vertical
      if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
      return;
    }
  }
  if (data.isTouchEvent && document.activeElement) {
    if (e.target === document.activeElement && dom(e.target).is(data.formElements)) {
      data.isMoved = true;
      swiper.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper.emit('touchMove', e);
  }
  if (e.targetTouches && e.targetTouches.length > 1) return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  var diffX = touches.currentX - touches.startX;
  var diffY = touches.currentY - touches.startY;
  if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;
  if (typeof data.isScrolling === 'undefined') {
    var touchAngle;
    if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      // eslint-disable-next-line
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper.emit('touchMoveOpposite', e);
  }
  if (typeof data.startMoving === 'undefined') {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper.allowClick = false;
  if (!params.cssMode && e.cancelable) {
    e.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e.stopPropagation();
  }
  if (!data.isMoved) {
    if (params.loop) {
      swiper.loopFix();
    }
    data.startTranslate = swiper.getTranslate();
    swiper.setTransition(0);
    if (swiper.animating) {
      swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
    }
    data.allowMomentumBounce = false;
    // Grab Cursor
    if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(true);
    }
    swiper.emit('sliderFirstMove', e);
  }
  swiper.emit('sliderMove', e);
  data.isMoved = true;
  var diff = swiper.isHorizontal() ? diffX : diffY;
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) diff = -diff;
  swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
  data.currentTranslate = diff + data.startTranslate;
  var disableParentSwiper = true;
  var resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
  } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
    disableParentSwiper = false;
    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
  }
  if (disableParentSwiper) {
    e.preventedByNestedSwiper = true;
  }

  // Directions locks
  if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }

  // Threshold
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode) return;

  // Update active index in free mode
  if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
  }
  if (params.freeMode) {
    // Velocity
    if (data.velocities.length === 0) {
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
        time: data.touchStartTime
      });
    }
    data.velocities.push({
      position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
      time: now()
    });
  }
  // Update progress
  swiper.updateProgress(data.currentTranslate);
  // Update translate
  swiper.setTranslate(data.currentTranslate);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onTouchEnd.js

function onTouchEnd(event) {
  var swiper = this;
  var data = swiper.touchEventsData;
  var params = swiper.params,
    touches = swiper.touches,
    rtl = swiper.rtlTranslate,
    $wrapperEl = swiper.$wrapperEl,
    slidesGrid = swiper.slidesGrid,
    snapGrid = swiper.snapGrid;
  var e = event;
  if (e.originalEvent) e = e.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper.emit('touchEnd', e);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  // Return Grab Cursor
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
    swiper.setGrabCursor(false);
  }

  // Time diff
  var touchEndTime = now();
  var timeDiff = touchEndTime - data.touchStartTime;

  // Tap, doubleTap, Click
  if (swiper.allowClick) {
    swiper.updateClickedSlide(e);
    swiper.emit('tap click', e);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper.emit('doubleTap doubleClick', e);
    }
  }
  data.lastClickTime = now();
  nextTick(function () {
    if (!swiper.destroyed) swiper.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  var currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper.translate : -swiper.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode) {
    if (currentPos < -swiper.minTranslate()) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (currentPos > -swiper.maxTranslate()) {
      if (swiper.slides.length < snapGrid.length) {
        swiper.slideTo(snapGrid.length - 1);
      } else {
        swiper.slideTo(swiper.slides.length - 1);
      }
      return;
    }
    if (params.freeModeMomentum) {
      if (data.velocities.length > 1) {
        var lastMoveEvent = data.velocities.pop();
        var velocityEvent = data.velocities.pop();
        var distance = lastMoveEvent.position - velocityEvent.position;
        var time = lastMoveEvent.time - velocityEvent.time;
        swiper.velocity = distance / time;
        swiper.velocity /= 2;
        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
          swiper.velocity = 0;
        }
        // this implies that the user stopped moving a finger then released.
        // There would be no events with distance zero, so the last event is stale.
        if (time > 150 || now() - lastMoveEvent.time > 300) {
          swiper.velocity = 0;
        }
      } else {
        swiper.velocity = 0;
      }
      swiper.velocity *= params.freeModeMomentumVelocityRatio;
      data.velocities.length = 0;
      var momentumDuration = 1000 * params.freeModeMomentumRatio;
      var momentumDistance = swiper.velocity * momentumDuration;
      var newPosition = swiper.translate + momentumDistance;
      if (rtl) newPosition = -newPosition;
      var doBounce = false;
      var afterBouncePosition;
      var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
      var needsLoopFix;
      if (newPosition < swiper.maxTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition + swiper.maxTranslate() < -bounceAmount) {
            newPosition = swiper.maxTranslate() - bounceAmount;
          }
          afterBouncePosition = swiper.maxTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.maxTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (newPosition > swiper.minTranslate()) {
        if (params.freeModeMomentumBounce) {
          if (newPosition - swiper.minTranslate() > bounceAmount) {
            newPosition = swiper.minTranslate() + bounceAmount;
          }
          afterBouncePosition = swiper.minTranslate();
          doBounce = true;
          data.allowMomentumBounce = true;
        } else {
          newPosition = swiper.minTranslate();
        }
        if (params.loop && params.centeredSlides) needsLoopFix = true;
      } else if (params.freeModeSticky) {
        var nextSlide;
        for (var j = 0; j < snapGrid.length; j += 1) {
          if (snapGrid[j] > -newPosition) {
            nextSlide = j;
            break;
          }
        }
        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
          newPosition = snapGrid[nextSlide];
        } else {
          newPosition = snapGrid[nextSlide - 1];
        }
        newPosition = -newPosition;
      }
      if (needsLoopFix) {
        swiper.once('transitionEnd', function () {
          swiper.loopFix();
        });
      }
      // Fix duration
      if (swiper.velocity !== 0) {
        if (rtl) {
          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
        } else {
          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
        }
        if (params.freeModeSticky) {
          // If freeModeSticky is active and the user ends a swipe with a slow-velocity
          // event, then durations can be 20+ seconds to slide one (or zero!) slides.
          // It's easy to see this when simulating touch with mouse events. To fix this,
          // limit single-slide swipes to the default slide duration. This also has the
          // nice side effect of matching slide speed if the user stopped moving before
          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
          // For faster swipes, also apply limits (albeit higher ones).
          var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
          var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
          if (moveDistance < currentSlideSize) {
            momentumDuration = params.speed;
          } else if (moveDistance < 2 * currentSlideSize) {
            momentumDuration = params.speed * 1.5;
          } else {
            momentumDuration = params.speed * 2.5;
          }
        }
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }
      if (params.freeModeMomentumBounce && doBounce) {
        swiper.updateProgress(afterBouncePosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        swiper.animating = true;
        $wrapperEl.transitionEnd(function () {
          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
          swiper.emit('momentumBounce');
          swiper.setTransition(params.speed);
          setTimeout(function () {
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }, 0);
        });
      } else if (swiper.velocity) {
        swiper.updateProgress(newPosition);
        swiper.setTransition(momentumDuration);
        swiper.setTranslate(newPosition);
        swiper.transitionStart(true, swiper.swipeDirection);
        if (!swiper.animating) {
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed) return;
            swiper.transitionEnd();
          });
        }
      } else {
        swiper.emit('_freeModeNoMomentumRelease');
        swiper.updateProgress(newPosition);
      }
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    } else if (params.freeModeSticky) {
      swiper.slideToClosest();
      return;
    } else if (params.freeMode) {
      swiper.emit('_freeModeNoMomentumRelease');
    }
    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
      swiper.updateProgress();
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    return;
  }

  // Find current slide
  var stopIndex = 0;
  var groupSize = swiper.slidesSizesGrid[0];
  for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i + _increment] !== 'undefined') {
      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
        stopIndex = i;
        groupSize = slidesGrid[i + _increment] - slidesGrid[i];
      }
    } else if (currentPos >= slidesGrid[i]) {
      stopIndex = i;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }

  // Find current slide size
  var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    // Long touches
    if (!params.longSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    if (swiper.swipeDirection === 'next') {
      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
    if (swiper.swipeDirection === 'prev') {
      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
    }
  } else {
    // Short swipes
    if (!params.shortSwipes) {
      swiper.slideTo(swiper.activeIndex);
      return;
    }
    var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper.swipeDirection === 'next') {
        swiper.slideTo(stopIndex + increment);
      }
      if (swiper.swipeDirection === 'prev') {
        swiper.slideTo(stopIndex);
      }
    } else if (e.target === swiper.navigation.nextEl) {
      swiper.slideTo(stopIndex + increment);
    } else {
      swiper.slideTo(stopIndex);
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onResize.js
function onResize() {
  var swiper = this;
  var params = swiper.params,
    el = swiper.el;
  if (el && el.offsetWidth === 0) return;

  // Breakpoints
  if (params.breakpoints) {
    swiper.setBreakpoint();
  }

  // Save locks
  var allowSlideNext = swiper.allowSlideNext,
    allowSlidePrev = swiper.allowSlidePrev,
    snapGrid = swiper.snapGrid;

  // Disable locks on resize
  swiper.allowSlideNext = true;
  swiper.allowSlidePrev = true;
  swiper.updateSize();
  swiper.updateSlides();
  swiper.updateSlidesClasses();
  if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
  } else {
    swiper.slideTo(swiper.activeIndex, 0, false, true);
  }
  if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
    swiper.autoplay.run();
  }
  // Return locks after resize
  swiper.allowSlidePrev = allowSlidePrev;
  swiper.allowSlideNext = allowSlideNext;
  if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
    swiper.checkOverflow();
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onClick.js
function onClick(e) {
  var swiper = this;
  if (!swiper.allowClick) {
    if (swiper.params.preventClicks) e.preventDefault();
    if (swiper.params.preventClicksPropagation && swiper.animating) {
      e.stopPropagation();
      e.stopImmediatePropagation();
    }
  }
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/onScroll.js
function onScroll() {
  var swiper = this;
  var wrapperEl = swiper.wrapperEl,
    rtlTranslate = swiper.rtlTranslate;
  swiper.previousTranslate = swiper.translate;
  if (swiper.isHorizontal()) {
    if (rtlTranslate) {
      swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
    } else {
      swiper.translate = -wrapperEl.scrollLeft;
    }
  } else {
    swiper.translate = -wrapperEl.scrollTop;
  }
  // eslint-disable-next-line
  if (swiper.translate === -0) swiper.translate = 0;
  swiper.updateActiveIndex();
  swiper.updateSlidesClasses();
  var newProgress;
  var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper.progress) {
    swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
  }
  swiper.emit('setTranslate', swiper.translate, false);
}
;// CONCATENATED MODULE: ./src/components/swiper/third-party/Swiper/src/components/core/events/index.js







var dummyEventAttached = false;
function dummyEventListener() {}
function attachEvents() {
  var swiper = this;
  var document = getDocument();
  var params = swiper.params,
    touchEvents = swiper.touchEvents,
    el = swiper.el,
    wrapperEl = swiper.wrapperEl,
    device = swiper.device,
    support = swiper.support;
  swiper.onTouchStart = onTouchStart.bind(swiper);
  swiper.onTouchMove = onTouchMove.bind(swiper);
  swiper.onTouchEnd = onTouchEnd.bind(swiper);
  if (params.cssMode) {
    swiper.onScroll = onScroll.bind(swiper);
  }
  swiper.onClick = onClick.bind(swiper);
  var capture = !!params.nested;

  // Touch Events
  if (!support.touch && support.pointerEvents) {
    el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
    document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
    document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
  } else {
    if (support.touch) {
      var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
      el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
        passive: false,
        capture: capture
      } : capture);
      el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
      if (touchEvents.cancel) {
        el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
      }
      if (!dummyEventAttached) {
        document.addEventListener('touchstart', dummyEventListener);
        dummyEventAttached = true;
      }
    }
    if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
      el.addEventListener('mousedown', swiper.onTouchStart, false);
      document.addEventListener('mousemove', swiper.onTouchMove, capture);
      document.addEventListener('mouseup', swiper.onTouchEnd, false);
    }
  }
  // Prevent Links Clicks
  if (params.preventClicks || params.preventClicksPropagation) {
    el.addEventListener('click', swiper.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl.addEventListener('scroll', swiper.onScroll);
  }

  // Resize handler
  if (params.updateOnWindowResize) {
    swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
  } else {
    swiper.on('observerU